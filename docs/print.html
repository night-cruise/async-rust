<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>async in rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="A book which aims to introduce the theory and mechanism of async/await syntax and async runtime in the Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="异步编程.html"><strong aria-hidden="true">2.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="async-await.html"><strong aria-hidden="true">3.</strong> async/await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async-await/async-await的使用.html"><strong aria-hidden="true">3.1.</strong> async/await 的使用</a></li><li class="chapter-item expanded "><a href="async-await/Future-trait.html"><strong aria-hidden="true">3.2.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="async-await/Generator.html"><strong aria-hidden="true">3.3.</strong> Generator</a></li><li class="chapter-item expanded "><a href="async-await/状态机.html"><strong aria-hidden="true">3.4.</strong> 状态机</a></li><li class="chapter-item expanded "><a href="async-await/Pin.html"><strong aria-hidden="true">3.5.</strong> Pin</a></li></ol></li><li class="chapter-item expanded "><a href="IO模型.html"><strong aria-hidden="true">4.</strong> IO 模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="IO模型/阻塞IO.html"><strong aria-hidden="true">4.1.</strong> 阻塞 IO</a></li><li class="chapter-item expanded "><a href="IO模型/非阻塞IO.html"><strong aria-hidden="true">4.2.</strong> 非阻塞 IO</a></li><li class="chapter-item expanded "><a href="IO模型/信号驱动IO.html"><strong aria-hidden="true">4.3.</strong> 信号驱动 IO</a></li><li class="chapter-item expanded "><a href="IO模型/IO多路复用.html"><strong aria-hidden="true">4.4.</strong> IO 多路复用</a></li><li class="chapter-item expanded "><a href="IO模型/异步IO.html"><strong aria-hidden="true">4.5.</strong> 异步 IO</a></li></ol></li><li class="chapter-item expanded "><a href="Epoll.html"><strong aria-hidden="true">5.</strong> Epoll</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Epoll/Epoll介绍.html"><strong aria-hidden="true">5.1.</strong> Epoll 介绍</a></li><li class="chapter-item expanded "><a href="Epoll/Epoll-server-example.html"><strong aria-hidden="true">5.2.</strong> Epoll server example</a></li></ol></li><li class="chapter-item expanded "><a href="异步运行时.html"><strong aria-hidden="true">6.</strong> 异步运行时</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="异步运行时/epoll.html"><strong aria-hidden="true">6.1.</strong> epoll</a></li><li class="chapter-item expanded "><a href="异步运行时/reactor.html"><strong aria-hidden="true">6.2.</strong> reactor</a></li><li class="chapter-item expanded "><a href="异步运行时/async_io.html"><strong aria-hidden="true">6.3.</strong> async_io</a></li><li class="chapter-item expanded "><a href="异步运行时/task.html"><strong aria-hidden="true">6.4.</strong> task</a></li><li class="chapter-item expanded "><a href="异步运行时/executor.html"><strong aria-hidden="true">6.5.</strong> executor</a></li><li class="chapter-item expanded "><a href="异步运行时/example.html"><strong aria-hidden="true">6.6.</strong> example</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async in rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/night-cruise/async-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>本书主要介绍 Rust 中 <code>async/await</code> 语法和异步运行时的原理和工作机制，并不涉实际的异步代码编写。全书的内容主要分为以下几个章节：</p>
<ul>
<li>
<p><strong>异步编程</strong>：介绍 Rust 异步编程的基础概念，以及在 Rust 中应用的异步模型。</p>
</li>
<li>
<p><strong>async/await</strong>：介绍Rust为支持异步编程而提供的语言层面的支持，包括 <code>async/await</code> 语法和它们的工作原理。</p>
</li>
<li>
<p><strong>IO 模型</strong>：介绍几种主要的 IO 模型，包括阻塞 IO、非阻塞 IO、IO 多路复用和异步 IO，其中 IO 多路复用是后文介绍 <code>Epoll</code> 的基础。</p>
</li>
<li>
<p><strong>Epoll</strong>：介绍 <code>Epoll</code> 的工作原理并提供一个简单的 <code>Epoll</code> server 的实现例子。<code>Epoll</code> 是 Linux 中 IO 多路复用的一种实现，是后文介绍异步运行时的基础。</p>
</li>
<li>
<p><strong>异步运行时</strong>：通过实现一个简单的异步运行时来介绍 <code>Reactor</code>、<code>Waker</code>、<code>Executor</code>、<code>Task</code> 的基本概念。</p>
</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">https://rust-lang.github.io/async-book/03_async_await/01_chapter.html</a></li>
<li><a href="https://www.zhihu.com/question/389262477/answer/1566255353">https://www.zhihu.com/question/389262477/answer/1566255353</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.async.html">https://doc.rust-lang.org/std/keyword.async.html</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.await.html">https://doc.rust-lang.org/std/keyword.await.html</a></li>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html">https://doc.rust-lang.org/std/future/trait.Future.html</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html#futures-in-rust">https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html#futures-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/std/task/struct.Context.html">https://doc.rust-lang.org/std/task/struct.Context.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/02_execution/02_future.html">https://rust-lang.github.io/async-book/02_execution/02_future.html</a></li>
<li><a href="https://github.com/ZhangHanDong/inviting-rust">https://github.com/ZhangHanDong/inviting-rust</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Generator.html">https://doc.rust-lang.org/std/ops/trait.Generator.html</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/enum.GeneratorState.html">https://doc.rust-lang.org/std/ops/enum.GeneratorState.html</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/master/library/core/src/future/mod.rs">https://github.com/rust-lang/rust/blob/master/library/core/src/future/mod.rs</a></li>
<li><a href="https://ipotato.me/article/70">https://ipotato.me/article/70</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/4_generators_async_await.html">https://cfsamson.github.io/books-futures-explained/4_generators_async_await.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html">https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/5_pin.html">https://cfsamson.github.io/books-futures-explained/5_pin.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">https://rust-lang.github.io/async-book/04_pinning/01_chapter.html</a></li>
<li><a href="https://folyd.com/blog/rust-pin-unpin/">https://folyd.com/blog/rust-pin-unpin/</a></li>
<li><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html">https://doc.rust-lang.org/std/pin/struct.Pin.html</a></li>
<li><a href="https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html">https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html</a></li>
<li><a href="https://www.cnblogs.com/alex3714/articles/5876749.html">https://www.cnblogs.com/alex3714/articles/5876749.html</a></li>
<li><a href="https://www.jianshu.com/p/31cdfd6f5a48">https://www.jianshu.com/p/31cdfd6f5a48</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/92617116">https://zhuanlan.zhihu.com/p/92617116</a></li>
<li><a href="https://github.com/zupzup/rust-epoll-example">https://github.com/zupzup/rust-epoll-example</a></li>
<li><a href="https://github.com/mmisono/aa_echo">https://github.com/mmisono/aa_echo</a></li>
<li><a href="https://os.phil-opp.com/async-await">https://os.phil-opp.com/async-await</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<p>为了避免歧义，本书中的异步编程特指在 Rust 中使用 <code>async/await</code> 关键字进行编写异步代码。</p>
<p>通过 <code>async</code> 关键字创建的异步函数或者异步块会返回一个实现了 <code>Future</code> trait 的类型，其本质上是一个协程对象。将 <code>async/await</code> 关键字和异步运行时结合使用就可以实现对多个协程对象的调度执行，从而达到并发执行的效果。</p>
<p>在 Rust 中主要应用的是 进程—线程—协程 异步模型，如下所示：</p>
<p><img src="imgs/async-model.png" alt="" /></p>
<p>下层是进程，进程是持有资源的最小单位；中层是线程，线程不持有资源，是<code>CPU</code>调度的最小单位；上层是协程，协程既不持有资源、也不在意<code>CPU</code>的调度，它仅仅关注的是“协作式的、自然的流程切换”。</p>
<p>异步运行时就负责调度执行上述的协程对象。例如在一个协程在等待 IO 时，这个协程会主动出让自己的执行权给异步运行时，这时异步运行时可以调度运行其他的协程，从而最大化地利用CPU时间片。在 IO 密集型的应用中，异步编程将能够极大地提高执行效率。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">async/await</a></h1>
<p>在 <code>fn</code>、<code>closure</code>、<code>block</code>前使用 <code>async</code> 关键字，会将标记的代码转化为一个 <code>Future</code>。因此，<code>async</code> 标记的代码不会立即运行，只有在 <code>Future</code> 上调用 <code>.await</code> 时才会计算运行 <code>Future</code>。而在 <code>await</code> 一个 <code>Future</code> 时，会暂停当前函数的执行，直到 <code>executor</code> 完成对该 <code>Future</code> 的计算。</p>
<p>以上是对 <code>async/await</code> 语义的基本介绍。在本章中，我们将会更加深入地介绍 <code>async/await</code> 的使用和它们的底层原理。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait-的使用"><a class="header" href="#asyncawait-的使用">async/await 的使用</a></h1>
<p><code>async/await </code>是 Rust 中特殊的语法，它使得让出当前线程的控制权而不阻塞线程成为可能，从而允许在等待一个操作完成时可以运行其他代码。</p>
<p>有两种主要的方式使用 <code>async</code>：<code>async fn</code> 和 <code>async {}</code>。这两中使用方式都会返回一个实现了 <code>Future trait</code> 的值：</p>
<pre><code class="language-rust noplayground">// `foo()` 返回一个实现了 `Future&lt;Output = u8&gt;` 的类型。
// `foo().await` 将会产生一个 u8 类型的值。
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // 这个 `async` 块会产生一个实现了 `Future&lt;Output = u8&gt;` 的类型。
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
</code></pre>
<p><code>async fn</code> 和 <code>async {}</code> 返回的 <code>Future</code> 是惰性的：在真正开始运行之前它什么也不会做。运行一个 <code>Future</code> 的最普遍的方式是 <code>await</code> 这个 <code>Future</code>： <code>Future.await</code>。</p>
<p>当 <code>await</code> 一个 <code>Future</code> 时，会暂停当前函数的运行，直到完成对 <code>Future</code> 的运行。如果这个 <code>Future</code> 被阻塞住了（例如等待网络IO），它会让出当前线程的控制权。当 <code>Future</code> 中的阻塞操作就绪时（例如等待的网络IO返回了响应），<code>executor</code> 会通过 <code>poll</code> 会恢复 <code>Future</code> 的运行。</p>
<h2 id="async-lifetime"><a class="header" href="#async-lifetime">async lifetime</a></h2>
<p>与普通的函数不一样，<code>async fn</code> 会获取引用或其他非静态生命周期的参数，然后返回被这些参数的生命周期约束的 <code>Future</code>：</p>
<pre><code class="language-rust noplayground">async fn foo(x: &amp;u8) -&gt; u8 { *x }

// 这与上面的函数完全等价
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}</code></pre>
<p>这意味着，<code>async fn</code> 返回的 <code>Future</code> 必须在非静态生命周期参数仍然有效时 <code>.await</code>。在大多数情况下，我们在调用 <code>async</code> 函数后会立马 <code>.await</code>（例如 <code>foo(&amp;x).await</code>），因此 <code>async lifetime</code> 不会对执行产生什么影响。但是，如果我们存储这种 <code>Future</code> 或者发送给其他的 <code>task</code> 或者 <code>thread</code>，就可能会造成问题。</p>
<p>把带有引用参数的 <code>async fn</code> 转化为静态 <code>Future</code> 的解决方法是：把参数和对 <code>async fn</code> 的调用封装到 <code>async</code> 块中：</p>
<pre><code class="language-rust noplayground">fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR: `x` does not live long enough
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}</code></pre>
<p>通过把参数移动到 <code>async</code> 块中，我们把它的生命周期扩展到了匹配调用 <code>good</code> 返回的 <code>Future</code> 的生命周期。</p>
<h2 id="async-move"><a class="header" href="#async-move">async move</a></h2>
<p><code>async</code> 块和闭包允许像普通闭包那样使用 <code>move</code> 关键字。一个 <code>async move</code> 块会获取变量的所有权，但是这会导致无法与其他的代码共享这些变量：</p>
<pre><code class="language-rust noplayground">// 不同的 async 块可以访问相同的变量s，只要它们都在s的作用域范围内执行
async fn blocks() {
    let s = String::new(&quot;Hello World&quot;);
    let future_one = async {
        println!(&quot;{:?}&quot;, s);
    };
    let future_two = async {
        println!(&quot;{:?}&quot;, s);
    };
    
    futures::future::join(future_one, future_two); // need run in cargo with futures crate
}

// s 被 move 进行 async 块中，因此只能在该 async 块内才能访问 
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let s = String::from(&quot;Hello World&quot;);
    async move {
        println!(&quot;{:?}&quot;, s);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-trait"><a class="header" href="#future-trait">Future trait</a></h1>
<p>在前文中，我们提到使用 <code>async</code> 标记的 <code>fn</code>、<code>block</code>、<code>closure</code> 都会返回一个 <code>Future</code>，本节将会详细地介绍 <code>Future</code> 的概念。</p>
<p>在标准库中，<code>Future</code> 的定义如下所示：</p>
<pre><code class="language-rust noplayground">pub trait Future {
    type Output;	// Future计算完成时产生的值的类型
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}</code></pre>
<p><code>Future</code> 表示一个异步计算，或者说会在未来完成计算的操作。<code>Future</code> 的核心是 <code>poll</code> 方法，当调用 <code>poll</code> 方法时会尝试计算 <code>Future</code> 得到最终的值。如果值还没有准备好（例如等待某些事件发生），则此方法不会阻塞，而是会直接返回一个结果表示 <code>Future</code> 还没有计算完毕。</p>
<blockquote>
<p>注意：<code>Future trait</code> 中涉及到的 <code>Pin</code> 将会在后面的章节中介绍。</p>
</blockquote>
<h2 id="poll"><a class="header" href="#poll">poll</a></h2>
<p>在上面对 <code>Future</code> 的介绍中，我们简要提到了 <code>poll</code> 方法，下面我们会对 <code>poll</code> 方法进行更详细的介绍。当调用 <code>Future</code> 的 <code>poll</code> 方法时会返回一个枚举类型的值：</p>
<ul>
<li><code>Poll::Pending</code>，表示这个 <code>Future</code> 还没计算完成</li>
<li><code>Poll::Ready(val)</code>，表示这个 <code>Future</code> 计算完毕，并附带计算结果：<code>val</code></li>
</ul>
<p>如果 <code>Future</code> 没有计算完成，例如想要等待一个 IO 事件发生，那么在 <code>poll</code> 方法体内，我们通常会调用传递给 <code>poll</code> 方法的 <code>Context</code> 的 <code>waker</code> 方法拿到一个 <code>Waker</code>（通常把 <code>Waker</code> 叫做唤醒器），然后注册这个 <code>Waker</code> 到一个“事件通知系统”中，最后返回 <code>Pending</code> 表示 <code>Future</code> 没有计算完成。</p>
<p>在未来某一时刻，<code>Future</code> 等待的 IO 事件就绪了，那么“事件通知系统”就会利用我们注册的 Waker 通过某种唤醒机制唤醒这个 <code>Future</code>，通过 <code>poll</code> 继续计算执行该 <code>Future</code>。</p>
<p>通过 <code>Waker</code> 唤醒器，我们可以只在 <code>Future</code> 想要等待的事件就绪时，才去唤醒 <code>Future</code>。这样我们就不需要通过一个死循环不断的调用 <code>poll</code> 方法来驱动 <code>Future</code> 的执行，这是异步编程之所以高效的关键所在。</p>
<h2 id="小栗子"><a class="header" href="#小栗子">小栗子</a></h2>
<p>下面我们使用一个具体的例子来介绍 <code>Future trait</code> 的使用。</p>
<p>假设我们准备读取一个 <code>socket</code>，但是它可能还没有准备好数据。如果数据准备好了，我们就可以读取它然后然后返回 <code>Poll::Ready(data)</code>，但是如果数据没有准备好，我们可以注册一个唤醒器到“事件通知系统”中：</p>
<pre><code class="language-rust noplayground">struct SocketRead&lt;'a&gt; {
	socket: &amp;'a Socket
}

impl&lt;'a&gt; Future for SocketRead&lt;'a&gt; {
	type Output = Vec&lt;u8&gt;;
	
	fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_'&gt;) -&gt; Poll&lt;Self::Output&gt; {
		let data = self.socket.no_block_read::&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;(1024);
		match data {
			Some(data) =&gt; Poll::Ready(data),
			None =&gt; {
				REACTOR.registe_waker_and_event(self.socket, Type::Read, cx.waker().clone());
				Poll::Pending
			}
		}
	}
}</code></pre>
<p>代码中的 <code>REACTOR </code>就是前文中所提到过的“事件通知系统”。当 <code>socket</code> 中有数据可读时，<code>REACTOR </code>就会使用注册的 <code>Waker</code> 唤醒负责 <code>SocketRead </code>，然后调用 <code>poll</code> 方法再次计算该 <code>Future</code>。</p>
<h2 id="leaf--non-leaf-future"><a class="header" href="#leaf--non-leaf-future">Leaf / Non-leaf Future</a></h2>
<p>在前文中我们提到使用 <code>async</code> 关键字可以创建一个 <code>Future</code> 类型，而在上面的小栗子中我们通过实现 <code>Future trait</code> 的方式也创建了一个 <code>Future</code> 类型，那么这两个 <code>Future</code> 有什么区别呢？</p>
<h3 id="leaf-future"><a class="header" href="#leaf-future">Leaf Future</a></h3>
<p>通过为我们的自定义类型实现 <code>Future trait</code> 的方式创建的 <code>Future</code> 被称为 <code>Leaf Future</code>。例如上面的小栗子中的 <code>SocketRead</code> 类型：</p>
<pre><code class="language-rust noplayground">struct SocketRead&lt;'a&gt; {
	socket: &amp;'a Socket
}

impl&lt;'a&gt; Future for SocketRead&lt;'a&gt; {
	/
}</code></pre>
<p><code>Leaf Future</code> 中通常会涉及到对 IO 的操作，例如从一个 <code>socket</code> 中读取数据，并且对 IO 的操作是非阻塞式的。</p>
<p>当调用异步运行时提供的异步读 <code>socket</code> 的方法时就会返回上述的 <code>Future</code>：</p>
<pre><code class="language-rust noplayground">impl async_runtime {
	fn read_socket(&amp;self) -&gt; SocketRead {
		// ...
	}
}

let mut leaf_future: SocketRead = async_runtime.read_socket();</code></pre>
<p>通常情况下，这些 <code>Leaf Future</code> 都是由异步运行时自己创建的，用户只需要使用 <code>async/await</code> 关键字即可。</p>
<h3 id="non-leaf-future"><a class="header" href="#non-leaf-future">Non-leaf Future</a></h3>
<p><code>Non-leaf Future</code> 是我们使用 <code>async</code> 关键字创建 <code>Future</code>，并且会由 <code>async runtime</code> 来调度运行。</p>
<p>在 <code>Non-leaf Future</code> 中可以创建多个 <code>Leaf Future</code>， 并且通过 <code>await</code> <code>Leaf Future</code> 来完成对 IO 的操作：</p>
<pre><code class="language-rust noplayground">let non_leaf_future = async {
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
	
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
	
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
}</code></pre>
<p>在 <code>await</code> 一个 <code>Leaf Future</code> 时，如果返回的是 <code>Pending</code>，那么<code>Non-Leaf Future</code> 就会让出对当前线程的控制权，此时 <code>async runtime</code> 就能够调度执行其他的 <code>Non-Leaf Future</code> 。当 <code>Non-Leaf Future</code> 中的 IO 操作就绪时，<code>async runtime</code> 就会重新激活挂起的 <code>Future</code>，在<strong>上次离开的地方继续运行</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator"><a class="header" href="#generator">Generator</a></h1>
<p><code>Future</code> 的底层依赖于生成器，因此在本节中我们将会介绍生成器的概念，以及生成器是如何转化为 <code>Future</code> 的。</p>
<h2 id="generator-定义"><a class="header" href="#generator-定义">Generator 定义</a></h2>
<p><code>Generator</code> 的定义位于标准库的 <code>ops</code> 模块中，具体如下所示：</p>
<pre><code class="language-rust noplayground">pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}

pub enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}</code></pre>
<p><code>Generator</code> 通常也被称为协程，主要目的是为 <code>async/await</code> 语法提供构建块，但是未来也可能会扩展到为 <code>Iterator</code> 和其他类型提供符合人体工程学的定义。</p>
<p><code>Generator</code> 的关联类型 <code>Yield</code> 对应于使用<code>yield</code> 表达式产出的值的类型。</p>
<p><code>Generator</code> 的关联类型 <code>Return</code> 对应于使用 <code>return</code> 语句或者生成器中的最后一个表达式返回的值的类型。</p>
<blockquote>
<p>注意：<code>Generator trait</code> 中涉及到的 <code>Pin</code> 将会在后面的章节中介绍。</p>
</blockquote>
<h2 id="resume"><a class="header" href="#resume">resume</a></h2>
<p>调用 <code>Generator</code> 的 <code>resume</code> 方法会恢复生成器的运行，如果还没有启动生成器的话则会启动生成器。</p>
<p>在执行生成器的过程中，如果遇到 <code>yield</code> 表达式，那么生成器就会在这个 <code>yield</code> 点挂起，并产出 <code>yield</code> 表达式的值：<code>GeneratorState::Yielded(Y)</code>。当再次调用 <code>resume</code> 方法时生成器就会在挂起的 <code>yield</code> 点恢复运行。</p>
<p>在运行过程中，如果遇到的是 <code>return</code> 语句或者生成器末尾的最后一个表达式，那么生成器执行完毕，并返回 <code>GeneratorState::Complete(R)</code>，<code>R</code> 就是 <code>return</code> 语句或者末尾表达式的值。</p>
<p>如果生成器已经执行完毕，返回了 <code>GeneratorState::Complete</code>，那么当再次调用 <code>Generator</code> 的 <code>resume</code> 方法时将会导致 <code>panic</code>。</p>
<h2 id="generator-使用"><a class="header" href="#generator-使用">Generator 使用</a></h2>
<p>在闭包中使用 <code>yield</code> 关键字就可以创建一个生成器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};


fn main() {
    let mut gen = || {
        let mut i = 1;
        while i &lt; 10 {
            yield i;
            i += 1;
        }
        
        return ();
    };
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(r) =&gt; {
                println!(&quot;Complete: {:?}&quot;, r);
                break;
            }
        }
    }
}</code></pre></pre>
<p>通过为自定义类型实现 <code>Generator trait</code> 来创建生成器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};


fn main() {
    let mut gen = MyGenerator { i: 1, completed: false };
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(r) =&gt; {
                println!(&quot;Complete: {:?}&quot;, r);
                break;
            }
        }
    }
}


struct MyGenerator {
    i: i32,
    completed: bool
}


impl&lt;R&gt; Generator&lt;R&gt; for MyGenerator {
    type Yield = i32;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        if self.completed {
            panic!(&quot;MyGenerator has been completed.&quot;);
        }
        
        let i = self.i;
        if i &lt; 10 {
            self.get_mut().i = i + 1;
            GeneratorState::Yielded(i)
        } else {
            self.get_mut().completed = true;
            GeneratorState::Complete(())
        }
    }
}</code></pre></pre>
<p>把生成器当作迭代器使用：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::iter::Iterator;
use std::ops::{Generator, GeneratorState};


fn main() {
    let gen = MyGenerator { i: 1, completed: false };
    
    for val in gen {
        println!(&quot;Got: {}&quot;, val);
    }

}


struct MyGenerator {
    i: i32,
    completed: bool
}


impl&lt;R&gt; Generator&lt;R&gt; for MyGenerator {
    type Yield = i32;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        if self.completed {
            panic!(&quot;MyGenerator has been completed.&quot;);
        }
        
        let i = self.i;
        if i &lt; 10 {
            self.get_mut().i = i + 1;
            GeneratorState::Yielded(i)
        } else {
            self.get_mut().completed = true;
            GeneratorState::Complete(())
        }
    }
}

impl Iterator for MyGenerator {
    type Item = i32;
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match Pin::new(self).resume(()) {
            GeneratorState::Yielded(y) =&gt; Some(y),
            GeneratorState::Complete(_) =&gt; None
        }
    }
}</code></pre></pre>
<h2 id="from-generator-to-future"><a class="header" href="#from-generator-to-future">From Generator to Future</a></h2>
<p>Rust 的 <code>core</code> 库中的 <code>future</code> 模块定义了将生成器转化为 <code>Future</code> 的函数（为了便于阅读去掉了注释部分）：</p>
<pre><code class="language-rust noplayground">pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
	where T: Generator&lt;ResumeTy, Yield = ()&gt;
{
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
   
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}</code></pre>
<p>从源码中可以看出，实际上我们使用 <code>async</code> 创建的 <code>Future</code> 是一个实现了 <code>Future trait</code> 的结构体 <code>GenFuture</code>，这个结构体的内部是一个生成器。</p>
<p>在我们调用 <code>Future</code> 的 <code>poll</code> 方法时，实际上就是在调用底层的生成器的 <code>resume</code> 方法，并且生成器返回的 <code>GeneratorState::Yielded/Complete(val)</code> 会被分别转化为 <code>poll</code> 的返回类型：<code>Poll::Pending/Ready(val)</code>。</p>
<h2 id="小栗子-1"><a class="header" href="#小栗子-1">小栗子</a></h2>
<p>在本节的最后，我们通过一个小栗子把前面讲的 <code>async/await</code>、<code>Future</code>、<code>Generator</code> 的知识串联起来。</p>
<p>有如下的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
async fn foo() -&gt; i32 {
    10
}

#[inline(never)]
async fn bar() -&gt; i32 {
    foo().await
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://rustc-dev-guide.rust-lang.org/hir.html">HIR</a> 是 Rust 代码编译的中间产物，可以帮助我们直到代码在脱糖后是什么样子。可以使用 Rust <code>Playground</code> 的 <code>HIR</code> 功能编译上述代码，结果如下：</p>
<pre><code class="language-rust noplayground">#[inline(never)]
async fn foo()
    -&gt;
        /*impl Trait*/ #[lang = &quot;from_generator&quot;](move |mut _task_context|
        { { let _t = { 10 }; _t } })

#[inline(never)]
async fn bar()
    -&gt;
        /*impl Trait*/ #[lang = &quot;from_generator&quot;](move |mut _task_context|
        {
                {
                        let _t =
                            {
                                    match #[lang = &quot;into_future&quot;](foo()) {
                                            mut pinned =&gt;
                                                loop {
                                                        match unsafe {
                                                                            #[lang = &quot;poll&quot;](#[lang = &quot;new_unchecked&quot;](&amp;mut pinned),
                                                                                #[lang = &quot;get_context&quot;](_task_context))
                                                                        } {
                                                                #[lang = &quot;Ready&quot;] { 0: result } =&gt; break result,
                                                                #[lang = &quot;Pending&quot;] {} =&gt; { }
                                                            }
                                                        _task_context = (yield ());
                                                    },
                                        }
                                };
                        _t
                    }
            })</code></pre>
<p>原生的 <code>HIR</code> 代码难以阅读，我们将其转化为下面的 Rust 伪代码：</p>
<pre><code class="language-rust noplayground">#[inline(never)]
async fn foo() -&gt; impl Future&lt;Output = i32&gt; {
    from_generator(move |mut _task_context| {
        let _t = 10;
        _t
    })
}

#[inline(never)]
async fn bar() -&gt; impl Future&lt;Output = i32&gt; {
    from_generator(move |mut _task_context| {
        let _t = {
            match into_future(foo()) {
                mut pinned =&gt; {
                    loop {
                        match unsafe Pin::new_unchecked(&amp;mut pinned).poll(get_context(_task_context)) {
                            Poll::Ready(result) =&gt; break result,
                            Poll::Pending =&gt; {}
                        }
                        _task_context = (yield ());
                    }
                }
            }
        };
        _t
    })
}</code></pre>
<p>可以看到 <code>async</code> 函数体内的代码被转化成了一个生成器，然后再调用 <code>from_generator</code> 函数传入生成器创建一个 <code>Future</code> ，这与我们上面介绍的 <code>from_generator</code> 函数的功能一致。</p>
<p><code>await</code> 部分则被转化为了一个无限循环，在循环的内部会调用 <code>await</code> 的 <code>Future</code> 的 <code>poll</code> 方法，如果结果是 <code>Poll::Ready</code>，则终止循环并返回 <code>result</code>，继续执行剩余的代码；如果结果是 <code>Poll::Pending</code>，则会使用 <code>yield</code> 挂起生成器，将控制权转移给调用方。当调用方激活这个挂起的生成器时，生成器就会恢复运行，执行循环体中的代码。</p>
<p>因此，只有当 <code>await</code> 的 <code>Future</code> 执行完毕时，才会继续往下执行 <code>async</code> 块中的代码，这样就确保了能够以同步的方式编写异步代码，让我们能拥有良好的开发体验。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态机"><a class="header" href="#状态机">状态机</a></h1>
<p>在上一节中，我们讲到生成器执行到 <code>yield</code> 表达式时，会在这个 <code>yield</code> 点挂起，当再次激活生成器时会在挂起的 <code>yield</code> 点恢复运行，那么生成器是怎么保存在 <code>yield</code> 点挂起时的状态呢？</p>
<p>事实上，编译器会把生成器转化为一个状态机，状态机中会保存每一个 <code>yield</code> 点的生成器的执行状态。</p>
<p>假如我们写了一个如下所示的生成器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = || {
        yield 1;
        yield 2;

        ()
    };

    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}</code></pre></pre>
<p>编译器会把生成器转化为下面的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = Gen::new();

    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}

enum Gen {
    Enter,
    State1(State1),
    State2(State2),
    Exit
}

struct State1 {
    _x: i32
}

struct State2 {
    _x: i32
}

impl&lt;R&gt; Generator&lt;R&gt; for Gen {
    type Yield = i32;
    type Return = ();

    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        let mut_gen = self.get_mut();
        match std::mem::replace(mut_gen, Gen::Exit) {
            Gen::Enter =&gt; {
                *mut_gen = Gen::State1(State1 { _x: 1 });
                GeneratorState::Yielded(1)
            }
            Gen::State1(_) =&gt; {
                *mut_gen = Gen::State2(State2 { _x: 2 });
                GeneratorState::Yielded(2)
            }
            Gen::State2(_) =&gt; {
                *mut_gen = Gen::Exit;
                GeneratorState::Complete(())
            }
            Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
        }
    }
}

impl Gen {
    fn new() -&gt; Self {
        Self::Enter
    }
}</code></pre></pre>
<p>同时，由于每个 <code>async</code> 函数最终都会生成一个状态机，并且每个可执行文件都会捆绑一个异步运行时，这会导致异步的 Rust 代码在编译后产生更大的二进制体积，这也是 <code>async</code> Rust 的一个小缺点。</p>
<blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin"><a class="header" href="#pin">Pin</a></h1>
<p>前文的 <code>Future trait</code>、<code>Geneartor</code> 和状态机中都出现了 <code>Pin</code>，那么 <code>Pin</code> 到底有什么用呢？ 在本节中，我们将会详细地介绍它。</p>
<h2 id="自引用结构"><a class="header" href="#自引用结构">自引用结构</a></h2>
<p>在 Safe Rust 中，我们无法创建自引用结构体：</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let s = &quot;Hello World&quot;.to_string();
    let _ = SelfReference {
        a: s,
        b: &amp;s
    };
}

struct SelfReference&lt;'a&gt; {
	a: String,
	b: &amp;'a String
}</code></pre></pre>
<p>如果编译，将会发生报错：</p>
<pre><code class="language-rust noplayground">error[E0382]: borrow of moved value: `s`
 --&gt; src/main.rs:5:12
  |
2 |     let s = &quot;Hello World&quot;.to_string();
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     let _ = SelfReference {
4 |         a: s,
  |            - value moved here
5 |         b: &amp;s
  |            ^^ value borrowed here after move</code></pre>
<p>这是因为 <code>s</code> 已经发生了 <code>move</code>，因此 <code>b</code> 就不能借用已经 <code>move</code> 了的 <code>s</code>。</p>
<p>为了创建自引用结构，我们需要使用裸指针：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(&amp;mut self) {
        let ptr_to_a = &amp;self.a as *const _;
        self.b = ptr_to_a;
    }
    
    fn get_a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }
    
    fn get_b(&amp;self) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>编译运行，结果如下所示：</p>
<pre><code class="language-rust noplayground">sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }</code></pre>
<p>接下来，让我们交换 <code>sr_1</code> 和 <code>sr_2</code> 的内存位置的数据，即 <code>sr_1</code> 和 <code>sr_2</code> 互相 <code>move</code> 给对方：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
    
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    println!(&quot;\nAfter swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	 a: String,
</span><span class="boring">	 b: *const String
</span><span class="boring">}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   } 
</span><span class="boring">   fn init(&amp;mut self) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       self.b = ptr_to_a;
</span><span class="boring">   }   
</span><span class="boring">   fn get_a(&amp;self) -&gt; &amp;str {
</span><span class="boring">       &amp;self.a
</span><span class="boring">   }    
</span><span class="boring">   fn get_b(&amp;self) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译运行，结果如下所示：</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<p>可以看出，在交换 <code>sr_1</code> 和 <code>sr_2</code>  后，字段 <code>a</code> 的数据也发生了交换，但是字段 <code>b</code> 的数据没有改变，仍然指向之前的位置，如图所示：</p>
<p><img src="async-await/../imgs/swap_problem.jpg" alt="swap problem" /></p>
<p>这意味着，<code>sr</code>（<code>sr_1</code>、<code>sr_2</code>）将不再是自引用结构体，并保存了一个指向其他对象的裸指针。因此，<code>sr</code> 的字段 <code>b</code> 的生命周期将不再和其结构体本身相关联，我们将难以保证 <code>sr.b</code> 指针不会变成悬垂指针。</p>
<p>在上面的例子中，由于使用 <code>swap</code> 函数导致出现了我们不想要的结果，在后续的代码中对 <code>sr</code> 的使用很可能会出现段错误、UB 等其他类型的错误。</p>
<h2 id="lets-pin-it"><a class="header" href="#lets-pin-it">Let's pin it!</a></h2>
<p>Rust 是一门极为注重内存安全的语言，为了能够安全地使用自引用结构，Rust 发明了 <code>Pin</code>。</p>
<h3 id="pin-1"><a class="header" href="#pin-1">Pin</a></h3>
<p><code>Pin</code> 位于 <code>std</code> 库的 <code>pin</code> 模块中，源代码定义如下所示：</p>
<pre><code class="language-rust noplayground">#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[lang = &quot;pin&quot;]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}</code></pre>
<p><code>Pin</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code> <code>trait</code>，因此 <code>Pin</code> 是一个智能指针。并且 <code>Pin</code> 的内部包裹了另一个指针 <code>P</code>，因此我们一般使用 <code>Pin&lt;P&lt;T&gt;&gt;</code> 的方式来表示一个 <code>Pin</code> 结构（<code>T</code> 是指针 <code>P</code> 指向的类型）。</p>
<p>既然有 <code>Pin</code>，那么自然就有 <code>Unpin</code>，那么 <code>Unpin</code> 是什么呢？<code>Unpin</code> 是一个 <code>auto trait</code>，编译器会默认为所有的类型实现 <code>Unpin</code>，除非这些类型实现了 <code>!Unpin</code>。</p>
<p>要想获取 <code>Pin&lt;P&lt;T&gt;&gt;</code> 中 <code>T</code> 的可变引用 <code>&amp;mut T</code>，可以使用 <code>Pin</code> 提供的 <code>get_mut</code> 方法，这也是 <code>Pin</code> 提供的 <code>api</code> 中<strong>唯一</strong>可以<strong>安全地</strong>获取 <code>&amp;mut T</code> 的方法，其函数签名如下所示：</p>
<pre><code class="language-rust noplayground">pub fn get_mut(self) -&gt; &amp;'a mut T
where
    T: Unpin,</code></pre>
<p>发现了吗？要想安全地拿到 <code>&amp;mut T</code>，<code>T</code> 就必须实现 <code>Unpin</code>。如果 <code>T</code> 实现了 <code>!Unpin</code>，那么就不可能安全地拿到 <code>T</code> 的可变引用，我们自然也就无法使用 <code>std::mem::swap(x: &amp;mut T, y: &amp;mut T)</code> 等类似的函数 <code>move</code> <code>T</code>，就不会发生前文的例子中出现的未定义行为。</p>
<p>因此，<code>Pin&lt;P&lt;T&gt;&gt;</code> 利用 Rust 的类型系统保证：如果 <code>T</code> 实现了 <code>!Unpin</code>，那么就不可能在 Safe Rust 中获取 <code>T</code> 的可变引用。相反，如果 <code>T</code> 实现了 <code>Unpin</code>，那么 <code>Pin</code> 就仅仅是对 <code>P&lt;T&gt;</code> 的一层包装，我么可以随意地拿到 <code>&amp;mut T</code>。</p>
<p>接下来，我们将会使用 <code>Pin</code> 解决上面的那个例子中出现的问题。</p>
<h3 id="pin-to-stack"><a class="header" href="#pin-to-stack">Pin to stack</a></h3>
<p><code>Pin</code> 到栈上是指我们想要 <code>Pin</code> 住的值在栈上，使用 <code>Pin::new_unchecked</code> 函数把 <code>&amp;mut T</code> 包装成 <code>Pin&lt;&amp;mut T&gt;</code> 即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1 = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2 = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let ptr_to_a = &amp;self.a as *const _;
        unsafe {
            self.get_unchecked_mut().b = ptr_to_a;
        }
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>此时代码将不会通过编译：</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:25
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:41
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>这说明当我们把 <code>&amp;mut SelfReference</code> <code>Pin</code> 到栈上之后，无法通过 <code>get_mut</code> 方法拿到 <code>&amp;mut SelfReference</code>，那么自然就无法使用 <code>swap</code> 函数，在编译阶段就保证了不会出现内存安全问题。</p>
<p><code>Pin::new_unchecked</code> 是一个 <code>unsafe</code> 函数，这是因为<strong>需要使用者自己遵守约定</strong>只使用 <code>Pin</code> 提供的 <code>api</code> 来获取并使用可变引用。</p>
<p>假如使用者提前 <code>drop</code> 掉 <code>Pin</code>，这样就可以直接获取 <code>T</code> 的可变引用，仍然会导致内存安全问题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1_pin.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2_pin.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
    
    drop(sr_1_pin);
    drop(sr_2_pin);
    

    println!(&quot;\nAfter swap:&quot;);
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    
    let sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    let sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
}
<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	a: String,
</span><span class="boring">	b: *const String
</span><span class="boring">}
</span><span class="boring">impl !Unpin for SelfReference {}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   }    
</span><span class="boring">   fn init(self: Pin&lt;&amp;mut Self&gt;) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       unsafe {
</span><span class="boring">           self.get_unchecked_mut().b = ptr_to_a;
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       &amp;self.get_ref().a
</span><span class="boring">   }   
</span><span class="boring">   fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}    </span></code></pre></pre>
<p>编译运行，将会出现和之前的例子中一样的问题：</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<h3 id="pin-to-heap"><a class="header" href="#pin-to-heap">Pin to heap</a></h3>
<p><code>Pin</code> 到堆上是指把我们想要 <code>Pin</code> 住的值装箱到堆上面，使用<code>Box::pin</code> 函数即可把 <code>T</code> 包装成 <code>Pin&lt;Box&lt;T&gt;&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let sr = Self {
            a: msg.to_string(),
            b: std::ptr::null()
        };
        let mut boxed = Box::pin(sr);
        let ptr_to_a = &amp;boxed.a as *const _;
        unsafe {
            boxed.as_mut().get_unchecked_mut().b = ptr_to_a;
        }
        
        boxed
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>此时代码将不会通过编译：</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:34
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                  ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:59
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                                           ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p><code>Pin</code> 到堆上的优点是不需要使用者编写 <code>unsafe</code> 函数来构造 <code>Pin</code>，也不需要使用者自己遵守约定只使用 <code>Pin</code> 提供的 <code>api</code> 来获取可变引用，因为 <code>Pin</code> 到堆上后，用户只能使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code>；缺点是 <code>Pin</code> 到堆上会有额外的性能开销。</p>
<h2 id="pin-and-async"><a class="header" href="#pin-and-async">Pin and async</a></h2>
<p>在前文中我们给出了 <code>Future</code> 和 <code>Generator</code> 的定义：</p>
<pre><code class="language-rust noplayground">pub trait Future {
    type Output;	
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}</code></pre>
<p>还有将 <code>Generator</code> 转化为 <code>Future</code> 的函数：</p>
<pre><code class="language-rust noplayground">pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
    where T: Generator&lt;ResumeTy, Yield = ()&gt;
{
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
   
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}</code></pre>
<p>可以看到要调用 <code>Future</code> 的 <code>Poll</code> 方法和 <code>Generator</code> 的 <code>resume</code> 方法必须使用 <code>Pin&lt;&amp;mut Self&gt;</code> 才行。并且在 <code>from_generator</code> 函数中为 <code>GenFuture</code> 实现了 <code>!Unpin</code>。</p>
<p>经过前面的学习，我们知道为 <code>T</code> 实现了 <code>!Unpin</code> 后，就无法在 Safe Rust 中获取 <code>T</code> 的可变引用，而 Rust 会主动为 <code>Future</code> 实现 <code>!Unpin</code>，那么为什么 Rust 需要 <code>Pin</code> 住 <code>Future</code> 呢？</p>
<p>假设我们编写了一个生成器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

fn main(){
    let _gen = || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
}</code></pre></pre>
<p>编译后将会发生报错：</p>
<pre><code class="language-rust noplayground">error[E0626]: borrow may still be in use when generator yields
 --&gt; src/main.rs:6:26
  |
6 |         let borrowed_s = &amp;s;
  |                          ^^
7 |         
8 |         yield borrowed_s.len();
  |         ---------------------- possible yield occurs here
</code></pre>
<p>编译器提示我们生成器中存在跨 <code>yield</code> 借用，那么为什么编译器不允许跨 <code>yield</code> 借用呢？</p>
<p>想要知道原因，我们还要继续深入底层，上述的生成器会被编译成一个状态机：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = Gen::new();
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}


impl&lt;R&gt; Generator&lt;R&gt; for Gen {
    type Yield = usize;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        let mut_gen = self.get_mut();
        match mut_gen {
            Gen::Enter =&gt; {
                let s = &quot;Hello World&quot;.to_string();
                let borrowed_s = &amp;s;
                let len = borrowed_s.len();
                
                *mut_gen = Gen::Yielded {
                    s,
                    borrowed_s: std::ptr::null()
                };
                if let Gen::Yielded { s, borrowed_s } = mut_gen {
                    *borrowed_s = s as *const _;
                }
                
                GeneratorState::Yielded(len)
            }
            Gen::Yielded{ borrowed_s, .. } =&gt; {
                let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
                println!(&quot;{}&quot;, borrowed_s);
                *mut_gen = Gen::Exit;
                
                GeneratorState::Complete(())
            }
            Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
        }
    }
}

impl Gen {
    fn new() -&gt; Self {
        Self::Enter
    }
}</code></pre></pre>
<p>编译上述代码，结果似乎就是我们所期待的：</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<p>从上述的代码中可以看出，<strong>生成的状态机中存在自引用结构</strong>。因此如果生成器中存在跨 <code>yield</code> 点借用，那么就可能产生内存安全问题，编译器干脆就禁止存在跨 <code>yield</code> 点借用的生成器通过编译。</p>
<p>例如，如果我们使用 <code>swap</code> 函数 <code>move</code> 生成器就可能发生异常：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(&amp;mut gen_1, &amp;mut gen_2);
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
}
<span class="boring">enum Gen {
</span><span class="boring">   Enter,
</span><span class="boring">   Yielded{
</span><span class="boring">       s: String,
</span><span class="boring">       borrowed_s: *const String
</span><span class="boring">   },
</span><span class="boring">   Exit
</span><span class="boring">}
</span><span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = self.get_mut();
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译运行将会发生段错误：</p>
<pre><code class="language-rust noplayground">/playground/tools/entrypoint.sh: line 11:    12 Segmentation fault
Yielded: 11
Yielded: 11
Hello World
Complete: ()</code></pre>
<p>为了防止 <code>move</code> 掉生成器，我们需要为 <code>Gen</code> 实现 <code>!Unpin</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    let mut boxed_pin_1 = Box::pin(gen_1);
    let mut boxed_pin_2 = Box::pin(gen_2);
    
    match boxed_pin_1.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match boxed_pin_2.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}

impl !Unpin for Gen {}

<span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = unsafe { self.get_unchecked_mut() };
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译修改后的代码将会直接报错：</p>
<pre><code class="language-rust noplayground">error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:41
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:73
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>通过为生成器实现 <code>!Unpin</code>，我们有效的防止了可能会出现的内存安全问题。</p>
<p>但是，我们无法为使用闭包编写的生成器实现 <code>!Unpin</code>，那么怎么让我们的初版代码编译通过呢？答案是使用 <code>static</code> 关键字标记生成器，这就相当于为我们的生成器实现了 <code>!Unpin</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};


fn main(){
    let gen = static || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
    
    let mut boxed_pin_gen = Box::pin(gen);
    
    loop {
        match boxed_pin_gen.as_mut().resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}</code></pre></pre>
<p>编译运行，一切正常：</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<h3 id="小总结"><a class="header" href="#小总结">小总结</a></h3>
<p><code>async</code> 创建的 <code>Future</code> 在编译后会生成一个状态机，如果 <code>async</code> 代码中存在跨 <code>await</code> 借用，那么对应的底层生成器中也会存在跨 <code>yield</code> 点借用，最终生成的状态机中就会存在自引用结构，为了避免可能发生的内存安全问题，Rust 自动为 <code>Future</code> 实现了 <code>!Unpin</code>，并且只能使用 <code>Pin&lt;&amp;mut Self&gt;</code> 来调用 <code>Future</code> 的 <code>poll</code> 方法和 <code>Generator</code> 的 <code>resume</code> 方法，从而避免了使用者在 Safe Rust 中获取 <code>Future</code> 或 <code>Generator</code> 的可变引用，最终避免了使用者使用 <code>swap</code> 之类的函数 <code>move</code> 掉 <code>Future</code> 或 <code>Generator</code> 而造成的内存安全问题。 </p>
<h2 id="pin-总结"><a class="header" href="#pin-总结">Pin 总结</a></h2>
<p>官方的 <code>Async Book</code> 上给出了关于 <code>Pin</code> 的黄金八条：</p>
<ol>
<li>
<p>如果 <code>T: Unpin</code>（默认会实现），那么 <code>Pin&lt;'a, T&gt;</code> 完全等价于 <code>&amp;'a mut T</code>。换言之： <code>Unpin</code> 意味着这个类型被移走也没关系，就算已经被固定了，所以 <code>Pin</code> 对这样的类型毫无影响。</p>
</li>
<li>
<p>如果 <code>T: !Unpin</code>， 获取已经被固定的 <code>T</code> 类型示例的 <code>&amp;mut T</code>需要 <code>unsafe</code>。</p>
</li>
<li>
<p>标准库中的大部分类型实现 <code>Unpin</code>，在 Rust 中遇到的多数普通类型也是一样。但是， <code>async/await</code> 生成的 <code>Future</code> 是个例外。</p>
</li>
<li>
<p>你可以在 <code>nightly</code> 通过特性标记来给类型添加 <code>!Unpin</code> 约束，或者在 <code>stable</code> 给你的类型加 <code>std::marker::PhatomPinned</code> 字段。</p>
</li>
<li>
<p>你可以将数据固定到栈上或堆上。</p>
</li>
<li>
<p>固定 <code>!Unpin</code> 对象到栈上需要 <code>unsafe</code></p>
</li>
<li>
<p>固定 <code>!Unpin</code> 对象到堆上不需要<code> unsafe</code>，<code>Box::pin</code>可以快速完成这种固定。</p>
</li>
<li>
<p>对于 <code>T: !Unpin</code> 的被固定数据，你必须维护好数据内存不会无效的约定，或者叫固定时起直到释放。这是 <code>Pin</code> 约定中的重要部分。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-模型"><a class="header" href="#io-模型">IO 模型</a></h1>
<h2 id="io-访问"><a class="header" href="#io-访问">IO 访问</a></h2>
<p>对于一次 IO 访问（例如 <code>read</code> 操作），通常有两个不同的阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>例如在一个 <code>socket</code> 上读取数据，首先需要等待数据到达网络，当数据到达时将数据拷贝到内核缓冲区中，再将数据从内核缓冲区中拷贝到用户进程的缓冲区中。</p>
<p>正是由于 IO 访问经历的两个阶段，Linux 系统产生了下面五种 IO 模型：</p>
<ul>
<li>阻塞 IO（blocking IO）</li>
<li>非阻塞 IO（nonblocking IO）</li>
<li>IO 多路复用（IO multiplexing）</li>
<li>信号驱动 IO（signal driven IO）</li>
<li>异步 IO（asynchronous IO）</li>
</ul>
<h2 id="io-模型与-future"><a class="header" href="#io-模型与-future">IO 模型与 Future</a></h2>
<p>在介绍 <code>Future trait</code> 的那一章中我们提到：如果一个 <code>Future</code> 没有计算完成，例如想要等待一个 IO 事件发生，那么通常会注册 <code>waker</code> 到一个“事件通知系统”中，当这个 IO 事件就绪时，“事件通知系统”就会通过 <code>waker</code> 唤醒之前的 <code>Future</code> 继续执行。</p>
<p>那么“事件通知系统”要怎么知道 <code>Future</code> 想要等待的 IO 事件什么时候就绪呢？这与 IO 模型有关，因此在本章中我们将会介绍几种不同的 IO 模型以及它们的特点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阻塞-io"><a class="header" href="#阻塞-io">阻塞 IO</a></h1>
<p>在 Linux 中，阻塞 IO 是最流行的 IO 模型，默认情况下所有的 <code>socket</code> 都是阻塞的（blocking）。对于阻塞 IO 来说，读操作的流程如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Blocking-IO.png" alt="Blocking IO Model" /></p>
<p>当用户进程发起 <code>recvfrom</code> 系统调用后，内核开始 IO 的第一个阶段：等待数据准备好，把数据从硬件拷贝到内核缓冲区（对于网络 IO，要先等待数据报文到达）。当数据准备好后，开始 IO 的第二个阶段：把数据从内核缓冲区拷贝到用户进程的缓冲区。当两个 IO 阶段都完成后，<code>recvfrom</code> 系统调用返回，也就是说用户进程从发起 <code>recvfrom</code> 系统调用直到返回都是处于阻塞状态。</p>
<p>因此，<strong>对于阻塞 IO 来说，用户进程在 IO 的两个阶段都被 <code>recvfrom</code> 系统调用阻塞了</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非阻塞-io"><a class="header" href="#非阻塞-io">非阻塞 IO</a></h1>
<p>在 Linux 中，我们可以把一个 <code>socket</code> 设置为非阻塞（nonblocking）。对于非阻塞 IO 来说，读操作的流程如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Nonblocking-IO.png" alt="Nonblocking IO Model" /></p>
<p>当用户进程发起 <code>recvfrom</code> 系统调用后，如果数据没有准备好，<code>recvfrom</code> 系统调用会立即返回 <code>EWOULDBLOCK</code> 错误。用户进程可以通过一个死循环不断发起 <code>recvfrom</code> 系统调用，一旦数据准备好了，就进入 IO 的第二个阶段：把数据从内核缓冲区拷贝到用户用进程的缓冲区，当拷贝完成后，<code>recvfrom</code> 系统调用正常返回。</p>
<p>因此，<strong>对于 Nonblocking IO 来说，用户进程需要不断轮询内核数据准备好了没有，并且用户进程在 IO 的第二个阶段仍然会被 <code>recvfrom</code> 系统调用阻塞</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号驱动-io"><a class="header" href="#信号驱动-io">信号驱动 IO</a></h1>
<p>对于信号驱动 IO 来说，读操作的流程如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Signal-Driven-IO.png" alt="Signal Driven IO" /></p>
<p>当用户进程发起 <code>sigaction</code> 系统调用后，这个系统调用会马上返回。内核在准备好数据后会向用户进程发送 <code>SIGIO</code> 信号，用户进程收到信号之后会在信号处理程序中发起 <code>recvfrom</code> 系统调用将数据从内核缓冲区复制到用户进程缓冲区中，至此 IO 的两个阶段全部完成。</p>
<p>因此，<strong>对于信号驱动 IO 来说，用户进程在 IO 的第二个阶段被 <code>recvfrom</code> 系统调用阻塞了</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-多路复用"><a class="header" href="#io-多路复用">IO 多路复用</a></h1>
<p>IO 多路复用是指通过一种机制实现在单个线程中可以监视多个文件描述符（例如 <code>socket</code> 描述符），当文件描述读/写就绪时，用户进程就可以获取就绪的文件句柄。<code>select</code>、<code>poll</code>、<code>epoll</code> 都是 IO 多路复用的一种实现。</p>
<p>以 <code>select</code> 为例，读操作的流程如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/IO-Multiplexing-Model.png" alt="IO Multiplexing Model" /></p>
<p>当用户进程发起 <code>select</code> 系统调用后，用户进程被阻塞，而内核会监控 <code>select</code> 负责的所有文件描述符，当任意一个文件描述符的数据准备好时，<code>select</code> 会返回就绪的文件描述符。此时，用户进程就可以对就绪的文件描述符发起 <code>recvfrom</code> 系统调用，开始 IO 的第二个阶段：将数据从内核缓冲区拷贝到用户进程的缓冲区，当拷贝结束后 <code>recvfrom</code> 调用正常返回。 </p>
<p>因此，<strong>对于 IO 多路复用来说，用户进程在 IO 的两个阶段都被阻塞了：在 IO 的第一个阶段被 <code>select</code> 系统调用阻塞，在 IO 的第二个阶段被 <code>recvfrom</code> 系统调用阻塞</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步-io"><a class="header" href="#异步-io">异步 IO</a></h1>
<p>对于异步 IO 来说，读操作的流程如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Asynchronous-IO.png" alt="Asynchronous IO Model" /></p>
<p>当用户进程发起异步框架 <code>AIO</code> 提供的 <code>aio_read</code> 系统调用后，这个系统调用会马上返回。内核会准备好数据然后把数据从内核缓冲区拷贝到用户进程缓冲区，当 IO 的两个阶段都完成后，内核会发送一个信号通知用户进程 <code>read</code> 操作完成了。</p>
<p>因此，<strong>对于异步 IO 来说，用户进程在 IO 的两个阶段都不会被阻塞</strong>。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><code>POSIX</code> 对同步 IO 和异步 IO 的定义如下：</p>
<ul>
<li>同步 IO 操作会导致发起请求的进程被阻塞，直到 IO 操作完成。</li>
<li>异步 IO 操作导致发起请求的进程被阻塞。</li>
</ul>
<p>根据 <code>PISIX</code> 的定义，可以把 IO 模型分为以下两类：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/IO-Summary.png" alt="" /></p>
<p>最后，各个 IO 模型的比较如下所示：</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Comparison-IO-Model.png" alt="Comparison IO Model" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll"><a class="header" href="#epoll">Epoll</a></h1>
<p><code>Epoll</code> 本质上是一种 IO 事件通知机制，是前文所述的在 Linux 中 IO 多路复用的一种实现。在本章中，我们将会简略介绍 <code>Epoll</code> 的原理，并使用 <code>Epoll</code> 实现一个简单的 <code>echo server</code>。</p>
<p>在最后一章《异步运行时》中，我们也会使用 <code>Epoll</code> 作为基础来实现一个 <code>Reactor</code>（<code>Reactor</code> 的概念会在后面介绍）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-介绍"><a class="header" href="#epoll-介绍">Epoll 介绍</a></h1>
<h2 id="epoll-工作流程"><a class="header" href="#epoll-工作流程">Epoll 工作流程</a></h2>
<p><code>Epoll</code> 的大致工作流程如下所示：</p>
<p><img src="Epoll/../imgs/epoll.png" alt="" /></p>
<blockquote>
<ol>
<li><code>int epoll_create(int size)</code></li>
</ol>
</blockquote>
<p>内核会产生一个 <code>Epoll</code> 实例数据结构并返回一个文件描述符，这个特殊的描述符是 <code>epoll</code> 实例的句柄。</p>
<p><code>size</code> 参数只是告诉内核 <code>Epoll</code> 处理的事件的大致数目，而不是能够处理的事件的最大个数。在 Linux 最新的一些内核版本中，<code>size</code> 参数没有任何意义。</p>
<br/>
<blockquote>
<ol start="2">
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></li>
</ol>
</blockquote>
<p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</p>
<p><code>op</code> 参数用于说明操作类型：</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加一个需要监视的描述符</li>
<li><code>EPOLL_CTL_DEL</code>：删除一个描述符</li>
<li><code>EPOLL_CTL_MOD</code>：修改一个描述符</li>
</ul>
<p><code>struct epoll_event</code> 结构描述一个文件描述符 <code>fd</code> 的 <code>epoll</code> 行为：</p>
<pre><code class="language-c">typedef union epoll_data {
    void *ptr; 				/* 指向用户自定义数据 */
    int fd; 				/* 注册的文件描述符 */
    uint32_t u32; 			/* 32-bit integer */
    uint64_t u64; 			/* 64-bit integer */
} epoll_data_t;

struct epoll_event {
    uint32_t events; 		/* 描述epoll事件 */
    epoll_data_t data; 		/* 见上面的结构体 */
};
</code></pre>
<p>常用的 <code>epoll</code> 事件如下所示：</p>
<ul>
<li><code>EPOLLIN</code>：描述符处于可读状态</li>
<li><code>EPOLLOUT</code>：描述符处于可写状态</li>
<li><code>EPOLLET</code>：将 <code>epoll event</code> 通知模式设置成 <code>edge trigger</code></li>
<li><code>EPOLLONESHOT</code>：第一次进行通知，之后不再监测</li>
<li><code>EPOLLHUP</code>：本端描述符产生一个挂断事件，默认监测事件</li>
<li><code>EPOLLRDHUP</code>：对端描述符产生一个挂断事件</li>
<li><code>EPOLLPRI</code>：由带外数据触发</li>
<li><code>EPOLLERR</code>：描述符产生错误时触发，默认检测事件</li>
</ul>
<br/>
<blockquote>
<ol start="3">
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></li>
</ol>
</blockquote>
<p>阻塞等待注册的事件发生，返回触发的事件的数目，并将触发的事件写入 <code>events</code> 数组中。</p>
<p><code>maxevents</code> 是返回的 <code>event</code> 的最大数量。<code>events</code> 数组的长度应该与 <code>maxevents</code> 一致。<code>timeout</code> 是 <code>epoll_wait</code> 调用阻塞的时间上限。</p>
<h2 id="epoll-触发机制"><a class="header" href="#epoll-触发机制">Epoll 触发机制</a></h2>
<p><code>Epoll</code> 监控多个文件描述符的 IO 事件，支持边缘触发（edge trigger，ET）和水平触发（level trigger，LT）。</p>
<h3 id="水平触发"><a class="header" href="#水平触发">水平触发</a></h3>
<p>对于读操作，只要文件描述符的读缓冲区不为空，触发可读事件。</p>
<p>对于写操作，只要文件描述的写缓冲区不满，触发可写事件。</p>
<h3 id="边缘触发"><a class="header" href="#边缘触发">边缘触发</a></h3>
<p>当文件描述符的缓冲区状态发生变化时触发。</p>
<p>对于读操作：</p>
<ul>
<li>当读缓冲区数据为空变为非空时，触发可读事件。</li>
<li>当读缓冲区接收到新数据时，即读缓冲区待读数据变多时，触发可读事件。</li>
<li>当读缓冲区有数据可读，且进程对相应的文件描述符进行 <code>EPOLL_CTL_MOD</code> 修改 <code>EPOLLIN</code> 事件时，触发可读事件。</li>
</ul>
<p>对于写操作：</p>
<ul>
<li>当写缓冲区由不可写变为可写时，触发可写事件。</li>
<li>当有旧数据被发送走，即读缓冲区中的内容变少的时候，触发可写事件。</li>
<li>当写缓冲区有空间可写，且进程对相应的文件描述符进行 <code>EPOLL_CTL_MOD</code> 修改 <code>EPOLLOUT</code> 事件时，触发可写事件。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-server-example"><a class="header" href="#epoll-server-example">Epoll server example</a></h1>
<p>在本节中，我们将会编写一个简单的 <code>epoll server</code>，来看一下 <code>epoll</code> 是如何工作的。<a href="https://crates.io/crates/libc">libc crate</a> 中提供了与 <code>epoll</code> 相关的系统调用，因此这个小项目需要添加 <code>libc crate</code> 依赖。 </p>
<h2 id="epoll-调用宏"><a class="header" href="#epoll-调用宏">epoll 调用宏</a></h2>
<p>为了方便地调用 <code>epoll</code> 相关的 <code>api</code>，我们可以编写如下所示的宏：</p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! syscall {
    ($fn: ident ( $($arg: expr),* $(,)* ) ) =&gt; {{
        let res = unsafe { libc::$fn($($arg, )*) };
        if res == -1 {
            Err(std::io::Error::last_os_error())
        } else {
            Ok(res)
        }
    }};
}</code></pre>
<p>例如，现在我们可以这样调用 <code>epoll_wait</code>：</p>
<pre><code class="language-rust noplayground">syscall!(epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000
))</code></pre>
<p>宏展开后的代码如下所示：</p>
<pre><code class="language-rust noplayground">{
    let res = unsafe {
        libc::epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000
        )
    };
    if res == -1 {
        Err(std::io::Error::last_os_error())
    } else {
        Ok(res)
}</code></pre>
<h2 id="epoll-模块"><a class="header" href="#epoll-模块">epoll 模块</a></h2>
<p>接下来，我们将会利用 <code>epoll</code> 提供的 <code>api</code> 来编写 IO 事件的注册、修改等功能。本模块需要导入的项：</p>
<pre><code class="language-rust noplayground">use std::io;
use std::os::unix::io::RawFd;

use crate::syscall;</code></pre>
<h3 id="创建-epoll-实例"><a class="header" href="#创建-epoll-实例">创建 epoll 实例</a></h3>
<pre><code class="language-rust noplayground">/// 包装epoll_create，创建一个epoll实例
pub fn epoll_create() -&gt; io::Result&lt;RawFd&gt; {
    // 创建一个epoll实例，返回epoll对象的文件描述符fd
    let fd = syscall!(epoll_create1(0))?;

    // fcntl(fd, libc::F_GETFD) 函数返回与 fd 关联的 close_on_exec 标志
    // close_on_exec 用于确定在系统调用 execve() 后是否需要关闭文件描述符
    if let Ok(flags) = syscall!(fcntl(fd, libc::F_GETFD)) {

        // 设置在系统调用 execve() 后关闭文件描述符 fd
        let _ = syscall!(fcntl(fd, libc::F_SETFD, flags | libc::FD_CLOEXEC));
    }

    Ok(fd)
}</code></pre>
<h3 id="注册文件描述并监听事件"><a class="header" href="#注册文件描述并监听事件">注册文件描述并监听事件</a></h3>
<pre><code class="language-rust noplayground">/// 包装 epoll_ctl，注册文件描述符和事件
pub fn add_interest(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    // epoll_fd 是 epoll 实例的的文件描述符
    // fd 是要注册的目标文件描述符
    // event 是要在 fd 上监听的事件
    // libc::EPOLL_CTL_ADD 表示添加一个需要监视的文件描述符
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_ADD, fd, &amp;mut event))?;

    Ok(())
}</code></pre>
<h3 id="修改注册的文件描述符"><a class="header" href="#修改注册的文件描述符">修改注册的文件描述符</a></h3>
<pre><code class="language-rust noplayground">/// 包装 epoll_ctl，修改文件描述符
pub fn modify_interest(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    // epoll_fd 是 epoll 实例的的文件描述符
    // fd 是要修改目标文件描述符
    // event 是要在 fd 上监听的事件
    // libc::EPOLL_CTL_MOD 表示修改文件描述符 fd
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_MOD, fd, &amp;mut event))?;

    Ok(())
}</code></pre>
<h3 id="删除注册的文件描述符"><a class="header" href="#删除注册的文件描述符">删除注册的文件描述符</a></h3>
<pre><code class="language-rust noplayground">/// 包装 epoll_ctl，删除文件描述符
pub fn remove_interest(epoll_fd: RawFd, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // epoll_fd 是 epoll 实例的的文件描述符
    // fd 是要删除的目标文件描述符
    // libc::EPOLL_CTL_DEL 表示要删除文件描述符 fd
    syscall!(epoll_ctl(
        epoll_fd,
        libc::EPOLL_CTL_DEL,
        fd,
        std::ptr::null_mut() // 将监听的 event 设置为空
    ))?;

    Ok(())
}</code></pre>
<h3 id="关闭文件描述符"><a class="header" href="#关闭文件描述符">关闭文件描述符</a></h3>
<pre><code class="language-rust noplayground">/// 关闭文件描述符 fd
pub fn close(fd: RawFd) {
    let _ = syscall!(close(fd));
}</code></pre>
<h3 id="创建一个读事件"><a class="header" href="#创建一个读事件">创建一个读事件</a></h3>
<pre><code class="language-rust noplayground">const READ_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLIN;

/// 创建一个读事件
pub fn listener_read_event(key: u64) -&gt; libc::epoll_event {
    // key 用于区分不同的文件描述符
    libc::epoll_event {
        events: READ_FLAGS as u32,
        u64: key,
    }
}</code></pre>
<h3 id="创建一个写事件"><a class="header" href="#创建一个写事件">创建一个写事件</a></h3>
<pre><code class="language-rust noplayground">const WRITE_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLOUT;

/// 创建一个写事件
pub fn listener_write_event(key: u64) -&gt; libc::epoll_event {
    // key 用于区分不同的文件描述符
    libc::epoll_event {
        events: WRITE_FLAGS as u32,
        u64: key,
    }
}</code></pre>
<h2 id="http-模块"><a class="header" href="#http-模块">http 模块</a></h2>
<p>在 <code>http</code> 模块中，我们将会编写处理 <code>HTTP</code> 请求相关的函数，需要导入的项：</p>
<pre><code class="language-rust noplayground">use std::io;
use std::net::TcpStream;
use std::io::{Read, Write};
use std::os::unix::io::{AsRawFd, RawFd};

use crate::epoll::{
    close, listener_read_event, listener_write_event, modify_interest, remove_interest,
};</code></pre>
<h3 id="请求上下文"><a class="header" href="#请求上下文">请求上下文</a></h3>
<p>将与客户端建立的连接抽象成请求上下文：</p>
<pre><code class="language-rust noplayground">/// 请求上下文，用于处理 HTTP 请求
#[derive(Debug)]
pub struct RequestContext {
    /// 与客户端建立的连接的 stream 流
    pub stream: TcpStream,
    /// 收到的 HTTP 请求的 content-length 的值
    pub content_length: usize,
    /// 收到的 HTTP 请求的数据写入的缓冲区
    pub buf: Vec&lt;u8&gt;,
}</code></pre>
<p>接下来编写的函数，都是为 <code>RequestContext</code> 实现的方法。</p>
<h3 id="创建请求上下文"><a class="header" href="#创建请求上下文">创建请求上下文</a></h3>
<pre><code class="language-rust noplayground">pub fn new(stream: TcpStream) -&gt; Self {
    Self {
        stream,
        buf: Vec::new(),
        content_length: 0,
    }
}</code></pre>
<h3 id="从-stream-流中读取数据"><a class="header" href="#从-stream-流中读取数据">从 stream 流中读取数据</a></h3>
<pre><code class="language-rust noplayground">pub fn read_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
    let mut buf = [0u8; 4096];

    // 从 stream 流中读取数据写入到 buf 中
    match self.stream.read(&amp;mut buf) {
        Ok(_) =&gt; {
            if let Ok(data) = std::str::from_utf8(&amp;buf) {

                // 解析并且设置读取到的 HTTP 请求的 content-length 字段的值
                self.parse_and_set_content_length(data);
            }
        }
        Err(e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {}
        Err(e) =&gt; {
            return Err(e);
        }
    };

    // 将读取的数据扩展到 RequestContext 的 buf 中
    self.buf.extend_from_slice(&amp;buf);

    // 如果 buf 中的数据长度大于等于 content-length，说明从客户端发送的 HTTP 请求已经读取完毕
    if self.buf.len() &gt;= self.content_length {
        println!(&quot;got all data: {} bytes&quot;, self.buf.len());

        // 将在 stream 上监听的事件修改为写事件
        modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_write_event(key))?;
    } else {

        // 将在 stream 上监听的事件修改为读事件，继续读取剩下的 HTTP 请求
        modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_read_event(key))?;
    }

    Ok(())
}</code></pre>
<h3 id="解析-http-请求"><a class="header" href="#解析-http-请求">解析 HTTP 请求</a></h3>
<pre><code class="language-rust noplayground">/// 解析并且设置读取到的 HTTP 请求的 content-length 字段的值
pub fn parse_and_set_content_length(&amp;mut self, data: &amp;str) {
    if data.contains(&quot;HTTP&quot;) {
        if let Some(content_length) = data
            .lines()
            .find(|l| l.to_lowercase().starts_with(&quot;content-length: &quot;))
        {
            if let Some(len) = content_length
                .to_lowercase()
                .strip_prefix(&quot;content-length: &quot;)
            {
                self.content_length = len.parse::&lt;usize&gt;().expect(&quot;content-length is valid&quot;);
                println!(&quot;set content length: {} bytes&quot;, self.content_length);
            }
        }
    }
}</code></pre>
<h3 id="写入返回数据到-stream-流中"><a class="header" href="#写入返回数据到-stream-流中">写入返回数据到 stream 流中</a></h3>
<p>为了简单起见，我们直接返回一段固定的 <code>HTTP</code> 文本。</p>
<pre><code class="language-rust noplayground">// 返回的响应为固定的 HTTP 文本
const HTTP_RESP: &amp;[u8] = br#&quot;HTTP/1.1 200 OK
content-type: text/html
content-length: 28

Hello! I am an epoll server.&quot;#;

/// 将要返回的 HTTP 数据写入到 stream 流中
pub fn write_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // 写入数据到 stream 流中
    match self.stream.write(HTTP_RESP) {
        Ok(_) =&gt; println!(&quot;answered from request {}&quot;, key),
        Err(e) =&gt; eprintln!(&quot;could not answer to request {}, {}&quot;, key, e),
    };

    // 关闭 stream 流
    self.stream.shutdown(std::net::Shutdown::Both)?;

    let fd = self.stream.as_raw_fd();
    // 移除在 epoll 中注册的文件描述符 fd
    remove_interest(epoll_fd, fd)?;

    // 关闭文件描述符 fd
    close(fd);

    Ok(())
}</code></pre>
<h2 id="main-模块"><a class="header" href="#main-模块">main 模块</a></h2>
<p>接下来，我们将会编写 <code>server</code> 的入口函数，主要的逻辑为：注册文件描述符  =&gt;  调用 <code>epoll_wait</code> 获取就绪的事件  =&gt;  根据不同的事件进行处理。</p>
<pre><code class="language-rust noplayground">use std::collections::HashMap;
use std::io;
use std::net::TcpListener;
use std::os::unix::io::AsRawFd;

use rust_epoll_example::epoll::{add_interest, epoll_create, listener_read_event, modify_interest};
use rust_epoll_example::http::RequestContext;
use rust_epoll_example::syscall;

fn main() -&gt; io::Result&lt;()&gt; {
    // 存储 RequestContext 实例，key 用来区分不同的 RequestContext
    let mut request_contexts: HashMap&lt;u64, RequestContext&gt; = HashMap::new();

    // 存储就绪的 event
    let mut events: Vec&lt;libc::epoll_event&gt; = Vec::with_capacity(1024);

    // key 对应 epoll_event 中的 u64 字段，用于区分文件描述、RequestContext
    let mut key = 100;

    // 创建一个 listener，并监听 8000 端口
    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;)?;

    // 将 socket 设置为非阻塞
    listener.set_nonblocking(true)?;

    // 获取 listener 对应文件描述符
    let listener_fd = listener.as_raw_fd();

    // 创建 epoll 实例，返回 epoll 文件描述符
    let epoll_fd = epoll_create().expect(&quot;can create epoll queue&quot;);

    // 在 epoll 实例中注册 listener 文件描述符，并监听读事件
    // key 等于 100，对应 listener 文件描述符
    add_interest(epoll_fd, listener_fd, listener_read_event(key))?;

    loop {
        println!(&quot;requests in flight: {}&quot;, request_contexts.len());
        events.clear();

        // 将就绪的事件添加到 events vec 中，返回就绪的事件数量
        let res = match syscall!(epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000,
        )) {
            Ok(v) =&gt; v,
            Err(e) =&gt; panic!(&quot;error during epoll wait: {}&quot;, e),
        };

        // safe  as long as the kernel does nothing wrong - copied from mio
        // 根据就绪的事件数量设置 events vec 的长度
        unsafe { events.set_len(res as usize) };

        // 遍历处理就绪的事件
        for ev in &amp;events {
            match ev.u64 {
                // key = 100 说明是在 listener fd 上监听的读事件就绪了
                100 =&gt; {
                    match listener.accept() {

                        // stream 是与客户端建立的连接的 stream 流
                        Ok((stream, addr)) =&gt; {
                            // 设置为非阻塞
                            stream.set_nonblocking(true)?;

                            // 有一个新的连接来了
                            println!(&quot;new client: {}&quot;, addr);
                            key += 1;

                            // 在 epoll 中注册 stream 文件描述符，并监听读事件
                            add_interest(epoll_fd, stream.as_raw_fd(), listener_read_event(key))?;

                            // 创建一个 RequestContext，并保存到 request_contexts 中
                            request_contexts.insert(key, RequestContext::new(stream));
                            // 上面使用的 key，用来区分不同的文件描述符和 RequestContext
                        }
                        Err(e) =&gt; eprintln!(&quot;couldn't accept: {}&quot;, e),
                    };

                    // 修改在 listener fd 上监听的的事件为读事件（继续等待新的连接到来）
                    modify_interest(epoll_fd, listener_fd, listener_read_event(100))?;
                }
                // key != 100，说明是其他的 fd 上监听的事件就绪了
                key =&gt; {
                    let mut to_delete = None;

                    // 获取这个 key 对应的 RequestContext
                    if let Some(context) = request_contexts.get_mut(&amp;key) {

                        let events: u32 = ev.events;

                        // 匹配就绪的事件是读事件还是写事件
                        match events {

                            // 读事件就绪
                            v if v as i32 &amp; libc::EPOLLIN == libc::EPOLLIN =&gt; {

                                // 读取请求数据
                                context.read_cb(key, epoll_fd)?;
                            }
                            // 写事件就绪
                            v if v as i32 &amp; libc::EPOLLOUT == libc::EPOLLOUT =&gt; {

                                // 写入返回数据
                                context.write_cb(key, epoll_fd)?;

                                // 返回数据后，就删除对应的 RequestContext，
                                // 当客户端再次发起请求时会建立新的连接，创建新的 RequestContext
                                to_delete = Some(key);
                            }
                            v =&gt; println!(&quot;unexpected events: {}&quot;, v),
                        };
                    }

                    // 写事件处理完毕，删除对应的 RequestContext
                    if let Some(key) = to_delete {
                        request_contexts.remove(&amp;key);
                    }
                }
            }
        }
    }
}</code></pre>
<p><code>HTTP</code> 协议是无状态的，我们在完整处理一次请求后就删除对应的请求上下文，当客户端再次发起请求时会建立新的连接，创建新的请求上下文。</p>
<p>至此，<code>epoll server</code> 编写完毕，源代码的仓库地址：<a href="https://github.com/night-cruise/rust-epoll-example">rust epoll example</a>。</p>
<h2 id="运行-server"><a class="header" href="#运行-server">运行 server</a></h2>
<p>使用 <code>cargo run</code> 启动 <code>server</code>，然后这个 <code>server</code> 会监听地址：<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a> 。</p>
<p>为了测试 <code>server</code>，编写一个 <code>Python</code> 小脚本，使用多线程循环发送 <code>HTTP</code> 请求：</p>
<pre><code class="language-python">import requests

from threading import Thread

with open('image.jpeg', 'rb') as f:
    FILE = f.read()


# send request to http://127.0.0.1:8000
def send_request(host, port):
    for _ in range(100):
        r = requests.post(f&quot;http://{host}:{port}&quot;, data={'file': FILE})
        print(f&quot;Receive response: '{r.text}' from {r.url}&quot;)


if __name__ == '__main__':
    t_lst = []
    for _ in range(4):
        t = Thread(target=send_request, args=('127.0.0.1', 8000))
        t_lst.append(t)
        t.start()

    for t in t_lst:
        t.join()
</code></pre>
<p><code>client</code> 端的输出：</p>
<pre><code>.....
.....
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
</code></pre>
<p><code>server</code> 端的输出：</p>
<pre><code>.....
.....
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
got all data: 9379840 bytes
requests in flight: 3
answered from request 195
</code></pre>
<p>正如我们所看到的那样，<code>server</code> 在同时处理多个请求！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步运行时"><a class="header" href="#异步运行时">异步运行时</a></h1>
<p>在前面的章节中，我们讲到过异步运行时负责调度执行使用者创建的 <code>Future</code>，那么异步运行时到底是如何工作的呢？在本章中，我们将会实现一个简单的单线程异步运行时，提供异步的网络IO读写操作，以探讨运行时的具体工作机制。</p>
<p>在正式开始之前，我们首先明确一下即将实现的运行时的工作原理：</p>
<p><img src="imgs/async-runtime.png" alt="" /></p>
<ol>
<li>
<p>用户使用 <code>async fn</code> 或者 <code>async {}</code> 的方式创建 <code>Non-Leaf Future</code>，然后使用 <code>spawn</code> 方法创建一个异步 <code>task</code>，并将这个 <code>task</code> 发送到 <code>executor</code> 的任务队列中。</p>
</li>
<li>
<p><code>executor</code> 从 <code>task_queue</code> 中取出 <code>task</code>，调用<code>task</code> 的 <code>poll</code> 方法，驱动 <code>Non-Leaf Future</code> 开始执行（如果已经开始执行了，则从上次的 <code>await</code> 断点处继续执行），就这样一直执行 <code>Future</code> 中的代码，直到遇到 <code>Leaf Future.await</code>。</p>
</li>
<li>
<p>调用 <code>Leaf Future</code> 的 <code>poll</code> 方法，如果 <code>Leaf Future</code> 对应的IO事件已经就绪，则直接返回 <code>Poll::Ready(data)</code>；如果对应的IO事件没有就绪，则调用 <code>Reactor</code> 的 <code>register</code> 方法注册等待的IO事件和 <code>waker</code>，然后 <code>Poll::Pending</code>（<code>Non-Leaf Future</code> 将会被挂起），<code>executor</code> 可以继续执行其他的 <code>task</code>。</p>
</li>
<li>
<p><code>Reactor</code> 会把注册的文件描述符 <code>fd</code>、<code>waker</code> 保存在<code>BTreeMap&lt;fd, waker&gt;</code> 中，然后调用 <code>Epoll</code> 提供的方法注册在 <code>fd</code> 上想要等待的 <code>event</code> 到 <code>Epoll</code> 系统中。</p>
</li>
<li>
<p><code>Reactor</code> 调用 <code>Epoll</code> 提供的 <code>wait</code> 方法获取所有就绪的文件描述符 <code>fds</code>，然后遍历 <code>fds</code>，通过 <code>fd</code> 匹配之前在 <code>BTreeMap</code> 中存储的 <code>waker</code>，然后调用 <code>waker</code> 的 <code>wake</code> 方法把 <code>task</code> 发送到 <code>executor</code> 的执行队列中，这样之前挂起的 <code>Non-Leaf Future</code> 就能够继续执行了。</p>
</li>
</ol>
<p>通过上面的原理讲解我们可以知道，异步代码之所以高效的原因就是避免了IO对线程的阻塞：</p>
<ul>
<li>
<p>当执行一个 <code>task</code> 时，如果遇到了没有就绪的 IO 操作，就注册 <code>waker</code> 到 <code>Reactor</code> 中，然后挂起这个 <code>task</code>，<code>executor</code> 就可以继续执行其他的 <code>task</code>。</p>
</li>
<li>
<p>当 <code>task</code> 等待的 IO 事件就绪时，<code>Reactor</code> 就会通过 <code>waker</code> 唤醒关联的 <code>task</code>，然后就可以执行之前挂起的 <code>task</code> 了。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-1"><a class="header" href="#epoll-1">epoll</a></h1>
<p>就像 <code>Epoll servere example</code> 一节中那样，为了方便地调用 <code>libc</code> 提供的 <code>api</code>，我们先创建一个 <code>syscall</code> 宏：</p>
<pre><code class="language-rust noplayground">macro_rules! syscall {
    ($fn: ident ( $($arg: expr),* $(,)* ) ) =&gt; {{
        let res = unsafe { libc::$fn($($arg, )*) };
        if res == -1 {
            Err(io::Error::last_os_error())
        } else {
            Ok(res)
        }
    }};
}</code></pre>
<h2 id="epoll-2"><a class="header" href="#epoll-2">Epoll</a></h2>
<p>抽象出 <code>Epoll</code> 和 <code>EpollEventType</code> 类型：</p>
<pre><code class="language-rust noplayground">pub(crate) struct Epoll {
    fd: RawFd,
}

pub(crate) enum EpollEventType {
    // Only event types used in this example
    In,
    Out,
}</code></pre>
<p><code>RawFd</code> 表示原始文件描述符。</p>
<h2 id="方法实现"><a class="header" href="#方法实现">方法实现</a></h2>
<h3 id="new"><a class="header" href="#new">new</a></h3>
<p>创建一个 <code>Epoll</code> 实例：</p>
<pre><code class="language-rust noplayground">pub(crate) fn new() -&gt; io::Result&lt;Self&gt; {
    let fd = syscall!(epoll_create1(libc::EPOLL_CLOEXEC))?;
    Ok(Epoll { fd })
}</code></pre>
<h3 id="添加事件修改事件"><a class="header" href="#添加事件修改事件">添加事件/修改事件</a></h3>
<pre><code class="language-rust noplayground">fn run_ctl(&amp;self, epoll_ctl: libc::c_int, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    let mut event: libc::epoll_event = unsafe { mem::zeroed() };
    event.u64 = fd as u64;
    event.events = match op {
        EpollEventType::In =&gt; libc::EPOLLIN as u32,
        EpollEventType::Out =&gt; libc::EPOLLOUT as u32,
    };

    let event_p: *mut _ = &amp;mut event as *mut _;
    syscall!(epoll_ctl(self.fd, epoll_ctl, fd, event_p))?;

    Ok(())
}

pub(crate) fn add_event(&amp;self, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    self.run_ctl(libc::EPOLL_CTL_ADD, fd, op)
}

#[allow(dead_code)]
pub(crate) fn mod_event(&amp;self, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    self.run_ctl(libc::EPOLL_CTL_MOD, fd, op)
}</code></pre>
<p><code>add_event</code> 和 <code>mod_event</code> 都是通过调用<code>run_ctl</code> 方法实现的。在 <code>run_ctl</code> 方法中根据 <code>op</code> 类型设置要注册/修改的事件类型，然后调用 <code>epoll_ctl</code> 方法来注册/修改事件。</p>
<h3 id="删除事件"><a class="header" href="#删除事件">删除事件</a></h3>
<pre><code class="language-rust noplayground">pub(crate) fn del_event(&amp;self, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    syscall!(epoll_ctl(
        self.fd,
        libc::EPOLL_CTL_DEL,
        fd,
        std::ptr::null_mut() as *mut libc::epoll_event
    ))?;

    Ok(())
}</code></pre>
<p>删除在 <code>Epoll</code> 实例中注册描述符 <code>fd</code>。</p>
<h3 id="等待就绪事件"><a class="header" href="#等待就绪事件">等待就绪事件</a></h3>
<pre><code class="language-rust noplayground">pub(crate) fn wait(&amp;self, events: &amp;mut [libc::epoll_event]) -&gt; io::Result&lt;usize&gt; {
    let nfd = syscall!(epoll_wait(
        self.fd,
        events.as_mut_ptr(),
        events.len() as i32,
        -1
    ))?;

    Ok(nfd as usize)
}</code></pre>
<p>调用 <code>epoll_wait</code> 函数获取所有就绪的文件描述符，并将就绪的描述符存放到 <code>events</code> 中，最后返回就绪的描述符数量。</p>
<h2 id="关闭epoll"><a class="header" href="#关闭epoll">关闭Epoll</a></h2>
<p>为 <code>Epoll</code> 实现 <code>Drop trait</code>，在清理 <code>Epoll</code> 时关闭 <code>Epoll</code> 的文件描述符：</p>
<pre><code class="language-rust noplayground">impl Drop for Epoll {
    fn drop(&amp;mut self) {
        syscall!(close(self.fd)).ok();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactor"><a class="header" href="#reactor">reactor</a></h1>
<h2 id="reactor-1"><a class="header" href="#reactor-1">Reactor</a></h2>
<pre><code class="language-rust noplayground">pub(crate) struct Reactor {
    pub epoll: Epoll,
    pub wakers: Mutex&lt;BTreeMap&lt;RawFd, Waker&gt;&gt;,
}</code></pre>
<p>字段 <code>epoll</code> 存储创建的 <code>Epoll</code> 实例，<code>wakers</code> 存储等待的IO事件的文件描述符和对应的 <code>waker</code>。</p>
<p>我们稍后将会创建 <code>Epoll</code> 的静态变量，为了内部可变性，就把 <code>BTreeMap&lt;RawFd, Waker&gt;</code> 包在 <code>Mutex</code> 中。</p>
<h2 id="添加事件"><a class="header" href="#添加事件">添加事件</a></h2>
<pre><code class="language-rust noplayground">impl Reactor {
    pub(crate) fn add_event(&amp;self, fd: RawFd, op: EpollEventType, waker: Waker) -&gt; io::Result&lt;()&gt; {
        info!(&quot;(Reactor) add event: {}&quot;, fd);
        self.epoll.add_event(fd, op)?;
        self.wakers.lock().unwrap().insert(fd, waker);
        Ok(())
    }
}</code></pre>
<p>在 <code>Reactor</code> 的添加事件的方法中，首先调用 <code>epoll</code> 的 <code>add_event</code> 方法注册文件描述符和监听的事件，然后把描述符和对应的 <code>waker</code> 存储在 <code>BTreeMap&lt;RawFd, Waker&gt;</code> 中。</p>
<h2 id="reactor-循环"><a class="header" href="#reactor-循环">reactor 循环</a></h2>
<pre><code class="language-rust noplayground">fn reactor_main_loop() -&gt; io::Result&lt;()&gt; {
    info!(&quot;Start reactor main loop&quot;);
    let max_event = 32;
    let event: libc::epoll_event = unsafe { mem::zeroed() };
    let mut events = vec![event; max_event];
    let reactor = &amp;REACTOR;

    loop {
        let nfd = reactor.epoll.wait(&amp;mut events)?;
        info!(&quot;(Reactor) wake up. nfd = {}&quot;, nfd);

        #[allow(clippy::needless_range_loop)]
        for i in 0..nfd {
            let fd = events[i].u64 as RawFd;
            if let Some(waker) = reactor.wakers.lock().unwrap().remove(&amp;fd) {
                info!(&quot;(Reactor) delete event: {}&quot;, fd);
                reactor.epoll.del_event(fd)?;
                waker.wake();
            }
        }
    }
}</code></pre>
<p>在 <code>reactor_main_loop</code> 函数中，我们使用一个 <code>loop</code> 循环，在循环中调用 <code>epoll</code> 的 <code>wait</code> 方法获取所有就绪的 IO 事件的文件描述符，如果没有事件就绪，<code>wait</code> 方法就会阻塞 <code>reactor</code> 线程，避免 CPU 空转。</p>
<p>然后遍历就绪的描述符，从 <code>wakers</code> 中获取描述符对应的 <code>waker</code>，之后调用 <code>epoll</code> 的 <code>delete_event</code> 方法删除描述符，表示这个事件已经处理完毕。</p>
<p>最后，调用 <code>waker</code> 的 <code>wake</code> 方法，把因为等待IO事件而挂起的 <code>task</code> 发送到 <code>executor</code> 的执行队列中。</p>
<h2 id="reactor-静态变量"><a class="header" href="#reactor-静态变量">REACTOR 静态变量</a></h2>
<pre><code class="language-rust noplayground">lazy_static! {
    pub(crate) static ref REACTOR: Reactor = {
        // Start reactor main loop
        std::thread::spawn(move || {
            reactor_main_loop()
        });

        Reactor {
            epoll: Epoll::new().expect(&quot;failed to create epoll&quot;),
            wakers: Mutex::new(BTreeMap::new())
        }
    };
}</code></pre>
<p><code>Executor</code> 在主线程运行，负责调度执行 <code>task</code>，而 <code>reactor_main_loop</code> 内部使用一个无线循环不断地获取就绪的 <code>fd</code>，并唤醒挂起的 <code>task</code>。为了避免 <code>reactor_main_loop</code> 阻塞 <code>Executor</code>，我们就开一个线程去执行 <code>reactor_main_loop</code>。</p>
<p>之所以把 <code>REACTOR</code> 创建成全局静态变量，是为了在其他的模块中方便地调用 <code>REACTOR</code> 的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async_io"><a class="header" href="#async_io">async_io</a></h1>
<p>在 <code>async_io</code> 模块中，我们将会创建 <code>Leaf Future</code>，异步化网络IO的监听和读写操作。</p>
<h2 id="ipv4addr"><a class="header" href="#ipv4addr">Ipv4Addr</a></h2>
<pre><code class="language-rust noplayground">pub struct Ipv4Addr(libc::in_addr);

impl Ipv4Addr {
    pub fn new(a: u8, b: u8, c: u8, d: u8) -&gt; Self {
        Ipv4Addr(libc::in_addr {
            s_addr: ((u32::from(a) &lt;&lt; 24)
                | (u32::from(b) &lt;&lt; 16)
                | (u32::from(c) &lt;&lt; 8)
                | u32::from(d))
            .to_be(),
        })
    }
}</code></pre>
<p><code>Ipv4Addr</code> 就是 <code>IPv4</code> 地址，<code>new</code> 方法负责创建一个 <code>Ipv4Addr</code> 类型。</p>
<h2 id="tcplistener"><a class="header" href="#tcplistener">TcpListener</a></h2>
<pre><code class="language-rust noplayground">pub struct TcpListener(RawFd);

impl TcpListener {
    // NOTE: bind() may be block. So this should be an async function in reality.
    pub fn bind(addr: Ipv4Addr, port: u16) -&gt; io::Result&lt;TcpListener&gt; {
        let backlog = 128;
        let sock = syscall!(socket(
            libc::PF_INET,
            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,
            0
        ))?;
        let opt: i32 = 1;
        syscall!(setsockopt(
            sock,
            libc::SOL_SOCKET,
            libc::SO_REUSEADDR,
            &amp;opt as *const _ as *const libc::c_void,
            std::mem::size_of_val(&amp;opt) as u32
        ))?;

        let sin: libc::sockaddr_in = libc::sockaddr_in {
            sin_family: libc::AF_INET as libc::sa_family_t,
            sin_port: port.to_be(),
            sin_addr: addr.0,
            ..unsafe { mem::zeroed() }
        };
        let addr_p: *const libc::sockaddr = &amp;sin as *const _ as *const _;
        let len = mem::size_of_val(&amp;sin) as libc::socklen_t;

        syscall!(bind(sock, addr_p, len))?;
        syscall!(listen(sock, backlog))?;

        info!(&quot;(TcpListener) listen: {}&quot;, sock);
        let listener = TcpListener(sock);
        listener.nonblocking()?;
        Ok(listener)
    }

    pub(crate) fn accept(&amp;self) -&gt; io::Result&lt;TcpStream&gt; {
        let mut sin_client: libc::sockaddr_in = unsafe { mem::zeroed() };
        let addr_p: *mut libc::sockaddr = &amp;mut sin_client as *mut _ as *mut _;
        let mut len: libc::socklen_t = unsafe { mem::zeroed() };
        let len_p: *mut _ = &amp;mut len as *mut _;
        let sock_client = syscall!(accept(self.0, addr_p, len_p))?;
        info!(&quot;(TcpStream)  accept: {}&quot;, sock_client);
        Ok(TcpStream(sock_client))
    }

    pub fn incoming(&amp;self) -&gt; Incoming&lt;'_&gt; {
        Incoming(self)
    }

    fn nonblocking(&amp;self) -&gt; io::Result&lt;()&gt; {
        let flag = syscall!(fcntl(self.0, libc::F_GETFL, 0))?;
        syscall!(fcntl(self.0, libc::F_SETFL, flag | libc::O_NONBLOCK))?;
        Ok(())
    }
}

impl Drop for TcpListener {
    fn drop(&amp;mut self) {
        info!(&quot;(TcpListener) close : {}&quot;, self.0);
        syscall!(close(self.0)).ok();
    }
}


pub struct Incoming&lt;'a&gt;(&amp;'a TcpListener);

impl&lt;'a&gt; Incoming&lt;'a&gt; {
    pub fn next(&amp;self) -&gt; AcceptFuture&lt;'a&gt; {
        AcceptFuture(self.0)
    }
}</code></pre>
<p><code>bind</code> 方法负责绑定传入的的 <code>IpV4</code> 地址和端口号，创建一个 <code>TcpListener</code> 实例，需要注意的是要把 <code>TcpListener</code> 设置为非阻塞：<code>listener.nonblocking()</code>，这样在调用 <code>accept</code> 方法接收客户端连接时才不会阻塞。</p>
<p><code>accept</code> 方法负责接收到来的客户端连接，然后创建 <code>TcpStream</code>，如果没有连接到来就返回一个 <code>io error</code>。</p>
<p><code>nonblocking</code> 方法调用 <code>libc::fcntl</code> 函数把 <code>TcpListener</code> 设置为非阻塞。</p>
<p><code>incoming</code> 方法把 <code>TcpListener</code> 的引用包在 <code>Incoming</code> 中，然后返回一个 <code>Incoming</code> 的实例。</p>
<p><code>Incoming</code> 表示 <code>TcpListener</code> 接收连接的流式处理，每当我们想要接收一个新的连接时，就调用 <code>next</code> 方法返回一个 <code>AcceptFuture</code>（后面会讲这个）。</p>
<h2 id="tcpstream"><a class="header" href="#tcpstream">TcpStream</a></h2>
<pre><code class="language-rust noplayground">pub struct TcpStream(RawFd);

impl TcpStream {
    fn nonblocking(&amp;self) -&gt; io::Result&lt;()&gt; {
        let flag = syscall!(fcntl(self.0, libc::F_GETFL, 0))?;
        syscall!(fcntl(self.0, libc::F_SETFL, flag | libc::O_NONBLOCK))?;
        Ok(())
    }

    pub fn read&lt;'a&gt;(&amp;'a self, buf: &amp;'a mut [u8]) -&gt; ReadFuture&lt;'a&gt; {
        ReadFuture(self, buf)
    }

    pub fn write&lt;'a&gt;(&amp;'a self, buf: &amp;'a [u8]) -&gt; WriteFuture&lt;'a&gt; {
        WriteFuture(self, buf)
    }

    pub fn raw_fd(&amp;self) -&gt; RawFd {
        self.0
    }
}

impl Drop for TcpStream {
    fn drop(&amp;mut self) {
        info!(&quot;(TcpStream)  close : {}&quot;, self.0);
        syscall!(close(self.0)).ok();
    }
}</code></pre>
<p><code>nonblocking</code> 方法调用 <code>libc::fcntl</code> 函数把 <code>TcpStream</code> 设置为非阻塞。</p>
<p><code>read/write</code> 方法分别返回 <code>RreadFture/WriteFuture</code>，和上面的 <code>AcceptFuture</code> 一样，我们将会在下面讲解这些 <code>Future</code> 的定义和作用。</p>
<h2 id="leaf-future-1"><a class="header" href="#leaf-future-1">Leaf Future</a></h2>
<pre><code class="language-rust noplayground">pub struct AcceptFuture&lt;'a&gt;(&amp;'a TcpListener);
pub struct ReadFuture&lt;'a&gt;(&amp;'a TcpStream, &amp;'a mut [u8]);
pub struct WriteFuture&lt;'a&gt;(&amp;'a TcpStream, &amp;'a [u8]);

impl&lt;'a&gt; Future for AcceptFuture&lt;'a&gt; {
    type Output = Option&lt;io::Result&lt;TcpStream&gt;&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        match self.0.accept() {
            Ok(stream) =&gt; {
                stream.nonblocking()?;
                Poll::Ready(Some(Ok(stream)))
            }
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::In, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Some(Err(e))),
        }
    }
}

impl&lt;'a&gt; Future for ReadFuture&lt;'a&gt; {
    type Output = io::Result&lt;usize&gt;;

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let res = syscall!(read(
            (self.0).0,
            self.1.as_mut_ptr() as *mut libc::c_void,
            self.1.len()
        ));
        match res {
            Ok(n) =&gt; Poll::Ready(Ok(n as usize)),
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::In, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Err(e)),
        }
    }
}

impl&lt;'a&gt; Future for WriteFuture&lt;'a&gt; {
    type Output = io::Result&lt;usize&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let res = syscall!(write(
            (self.0).0,
            self.1.as_ptr() as *mut libc::c_void,
            self.1.len()
        ));
        match res {
            Ok(n) =&gt; Poll::Ready(Ok(n as usize)),
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::Out, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Err(e)),
        }
    }
}</code></pre>
<p>在同步的处理方式中，监听 <code>TcpListener</code> 和读写 <code>TcpStream</code> 是阻塞式的，即会阻塞线程直到相应的 IO 事件发生；</p>
<p>而在异步的处理方式中，监听 <code>TcpListener</code> 和读写 <code>TcpStream</code>  不会阻塞掉线程，而是会返回一个对应的 <code>Leaf Future</code>：</p>
<ul>
<li><code>Incoming</code> 的 <code>next</code> 方法会返回一个 <code>AcceptFuture</code>。</li>
<li><code>TcpStream</code> 的 <code>read/write</code> 方法分别返回 <code>ReadFuture/WriteFuture</code>。</li>
</ul>
<p>为 <code>AcceptFuture/ReadFuture/WriteFuture</code> 实现 <code>Future trait</code>，这样它们就有了 <code>poll</code> 方法。上述三个 <code>Future</code> 的 <code>poll</code> 方法的执行流程时类似的，因此下面我们只讲解 <code>ReadFutrue</code> 的执行流程。</p>
<p>当调用 <code>ReadFutrue.await</code> 时，会调用 <code>ReadFutrue</code> 的 <code>poll</code> 方法，在 <code>poll</code> 方法内部：</p>
<ul>
<li>
<p>调用 <code>libc::read</code> 函数从 <code>TcpStream</code> 中读取数据，返回 <code>res</code>。</p>
</li>
<li>
<p>匹配 <code>res</code> 的值：</p>
<ul>
<li>
<p>如果是 <code>Ok(n)</code>，则读取到了数据，此时直接返回 <code>Poll::Ready(OK(n))</code>，调用方继续执行 <code>ReadFutrue.await</code> 下面的代码。</p>
</li>
<li>
<p>如果是 <code>Err(e)</code>，并且 <code>e.kind() == io::ErrorKind::WouldBlock</code>，则说明 <code>TcpStream</code> 中没有数据可读，这时就调用 <code>REACTOR</code> 的 <code>add_event</code> 方法注册文件描述符（关联读事件）和 <code>waker</code>。最后返回 <code>Poll::Pending</code>，调用方接收到 <code>Poll::Pending</code> 后就会调用 <code>yield</code> 表达式挂起当前的执行流（<code>Task</code>）。</p>
</li>
<li>
<p>如果是其他的 <code>Err(e)</code>，则说明读取数据发生了其他错误，此时返回 <code>Poll::Ready(Err(e))</code> 表示读取失败，调用方继续执行 <code>ReadFutrue.await</code> 下面的代码。</p>
</li>
</ul>
</li>
</ul>
<p>当注册到 <code>REACTOR</code> 中的事件就绪时，<code>REACTOR</code> 就会使用注册的 <code>waker</code> 唤醒挂起的 <code>Task</code>，继续调用 <code>ReadFutrue</code> 的 <code>poll</code> 方法，重复上述的执行流程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task"><a class="header" href="#task">task</a></h1>
<p><code>Task</code> 是对 <code>async fn</code> 或者 <code>async {}</code> 创建的 <code>Non-Leaf Future</code> 的抽象，一个 <code>task</code> 就代表一个异步执行的任务：</p>
<pre><code class="language-rust noplayground">#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub(crate) struct TaskId(u64);

impl TaskId {
    pub(crate) fn new() -&gt; Self {
        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
        TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed))
    }
}

pub(crate) struct Task {
    id: TaskId,
    future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt;&gt;,
    task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
<p><code>Task</code> 中有三个字段：</p>
<ul>
<li>
<p><code>id</code>：每个 <code>task</code> 都有一个唯一的 <code>TaskId</code>，<code>TaskId</code> 是有可能在不同的线程中创建的，因此使用原子类型 <code>AtomicU64</code> 来创建 <code>TaskId</code> 的实例，保证唯一性。</p>
</li>
<li>
<p><code>future</code>：对用户创建的 <code>Non-Leaf Future</code> 的包装，使用 <code>Pin</code> 的目的是为了安全地使用自引用结构（<code>Future</code> 生成的状态机中可能存在自引用结构），使用 <code>Mutex</code> 的目的稍后讲解。</p>
</li>
<li>
<p><code>task_sender</code>：一个 <code>channel</code> 的发送端，发送的 item 是 <code>Arc&lt;Task&gt;</code>，之所以使用 <code>Arc&lt;Task&gt;</code> 一方面是想要减小克隆 <code>Task</code> 的开销，另一方面与 <code>Waker</code> 的实现机制有关（稍后讲解）。</p>
</li>
</ul>
<h2 id="方法实现-1"><a class="header" href="#方法实现-1">方法实现</a></h2>
<pre><code class="language-rust noplayground">impl Task {
    pub(crate) fn new(
        future: impl Future&lt;Output = ()&gt; + 'static + Send,
        task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
    ) -&gt; Self {
        Task {
            id: TaskId::new(),
            future: Mutex::new(Box::pin(future)),
            task_sender,
        }
    }

    pub(crate) fn task_id(&amp;self) -&gt; TaskId {
        self.id
    }

    pub(crate) fn poll(&amp;self, context: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        self.future
            .lock()
            .expect(&quot;get lock failed&quot;)
            .as_mut()
            .poll(context)
    }
}</code></pre>
<p><code>new</code> 方法中传入参数 <code>future</code> 和 <code>task_sender</code> 后创建一个 <code>Task</code> 实例：</p>
<ul>
<li>参数 <code>Future</code> 要求满足 <code>'static</code> 生命周期是因为 <code>task</code> 的存在时间可能是任意长的，因此需要 <code>Future</code> 具有静态生命周期。</li>
<li>要求 <code>Future</code> 满足 <code>Send</code> 是因为 <code>Task</code> 需要跨线程发送。</li>
<li>由于 <code>Future</code> 最终使用 <code>Mutex</code> 包了起来，因此 <code>future</code> 字段最终同时满足 <code>Send + Sync + 'static</code>。</li>
<li><code>Task</code> 的其他两个字段也满足 <code>Send + Sync + 'static</code> ，因此 <code>Task</code> 满足 <code>Send + Sync + 'static</code>。</li>
</ul>
<p>由于 <code>task_sender</code> 发送的 item 是 <code>Arc&lt;Task&gt;</code>，<code>executor</code> 的执行队列中收到的也是 <code>Arc&lt;Task&gt;</code>，因此 <code>poll</code> 方法的定义中只能使用 <code>&amp;self</code> 不变引用。</p>
<p>又因为 <code>Future</code> 的 <code>poll</code> 方法调用需要可变引用，为了实现内部可变性，我们就用 <code>Mutex</code> 把 <code>Pin&lt;Box&lt;Future&gt;&gt;</code> 包了起来，这就是使用 <code>Mutex</code> 的原因。</p>
<p>在 <code>poll</code> 方法中，首先调用 <code>self.future.lock()</code> 获取锁，然后将调用 <code>.as_mut()</code> 方法获取 <code>Pin&lt;&amp;mut dyn Future&gt;</code>，最后再调用 <code>Future</code> 中的 <code>poll</code> 方法执行 <code>Future</code>。</p>
<h2 id="实现-wake-trait"><a class="header" href="#实现-wake-trait">实现 Wake trait</a></h2>
<p>为 <code>Task</code> 实现 <code>Wake trait</code>，这样就可以通过 <code>Task</code> 来构建一个 <code>Waker</code>：</p>
<pre><code class="language-rust noplayground">impl Wake for Task {
    fn wake(self: Arc&lt;Self&gt;) {
        self.task_sender
            .send(self.clone())
            .expect(&quot;send task failed&quot;);
    }

    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) {
        self.task_sender
            .send(self.clone())
            .expect(&quot;send task failed&quot;);
    }
}</code></pre>
<p><code>Wake</code> 中的 <code>wake/wake_by_ref</code> 方法实现就是具体的唤醒 <code>task</code> 的机制，在这个实现中，我们把想要唤醒的 <code>task</code> 通过 <code>task_sender</code> 发送到 <code>executor</code> 的执行队列中，这样 <code>executor</code> 就可以执行这个 <code>task</code> 了，这也是在 <code>Task</code> 定义中，需要 <code>task_sender</code> 字段的原因。</p>
<p>此外，<code>wake/wake_by_ref</code> 方法中都需要 <code>Arc&lt;Task&gt;</code>，这是 <code>task_sender</code> 的 item 类型为 <code>Arc&lt;Task&gt;</code> 的原因之一。</p>
<h2 id="构造-waker"><a class="header" href="#构造-waker">构造 Waker</a></h2>
<p>对于实现了 <code>Wake trait</code> 的 <code>Task</code>，可以使用  <code>std::task::Waker</code> 的 <code>from</code> 方法构造一个 <code>Waker</code>：</p>
<pre><code class="language-rust noplayground">impl&lt;W: Wake + Send + Sync + 'static&gt; From&lt;Arc&lt;W&gt;&gt; for Waker {
    fn from(waker: Arc&lt;W&gt;) -&gt; Waker {}
}</code></pre>
<p>通过前面的分析，我们知道 <code>Task</code> 已经同时满足 <code>Wake + Send + Sync + 'static</code>，因此可以安全地使用 <code>from</code> 方法构造一个 <code>Waker</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">executor</a></h1>
<h2 id="executor-1"><a class="header" href="#executor-1">Executor</a></h2>
<pre><code class="language-rust noplayground">pub struct Executor {
    task_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
    waker_cache: BTreeMap&lt;TaskId, Waker&gt;,
}</code></pre>
<p><code>task_queue</code> 是一个 <code>channel</code> 的接收端，当 <code>spawn</code> 或者 <code>wake</code> 一个 <code>task</code> 时，就会发送 <code>Arc&lt;Task&gt;</code> 到 <code>task_queue</code> 中。</p>
<p><code>waker_cache</code> 使用 <code>BTreeMap</code> 缓存可能会重复使用的 <code>Waker</code>，这是为了减小构造 <code>Waker</code> 的开销。</p>
<blockquote>
<p>实际上，<code>Executor</code> 中的 <code>task_queue</code> 只是一个管道的接收端，并不是队列，只是我个人更习惯称之为队列。</p>
</blockquote>
<h3 id="方法实现-2"><a class="header" href="#方法实现-2">方法实现</a></h3>
<pre><code class="language-rust noplayground">impl Executor {
    fn new(task_queue: Receiver&lt;Arc&lt;Task&gt;&gt;) -&gt; Self {
        Self {
            task_queue,
            waker_cache: BTreeMap::new(),
        }
    }

    fn run_ready_task(&amp;mut self) {
        while let Ok(task) = self.task_queue.recv() {
            let waker = self
                .waker_cache
                .entry(task.task_id())
                .or_insert_with(|| Waker::from(task.clone()));

            let mut context = Context::from_waker(waker);
            match task.poll(&amp;mut context) {
                Poll::Ready(_) =&gt; {
                    self.waker_cache.remove(&amp;task.task_id());
                }
                Poll::Pending =&gt; {}
            }
        }
    }

    pub fn run(&amp;mut self) {
        self.run_ready_task();
    }
}</code></pre>
<p><code>new</code> 方法接收 <code>Receiver&lt;Arc&lt;Task&gt;&gt;</code> 参数，然后创建一个执行器实例。</p>
<p><code>run_ready_task</code> 方法中：</p>
<ul>
<li>
<p>从 <code>task_queue</code> 中接收 <code>task: Arc&lt;Task&gt;</code>，然后从 <code>waker_cache</code> 中查找是否存在对应的 <code>waker</code>，如果没有则构造一个 <code>Waker</code>。</p>
</li>
<li>
<p>使用 <code>Context</code> 的 <code>from_waker</code> 方法通过 <code>waker</code> 的引用创建 <code>context</code>。</p>
</li>
<li>
<p>调用 <code>task</code> 的 <code>poll</code> 方法，传入 <code>&amp;mut context</code> 参数，开始执行<code>task</code>。</p>
<ul>
<li>如果返回的是 <code>Poll::Ready</code>，说明 <code>task</code> 执行完毕，从 <code>waker_cache</code> 中删除缓存的 <code>waker</code>。</li>
<li>如果返回的是 <code>Poll::Pending</code>，则什么都不做（最终执行的 <code>Leaf-Future</code> 中会注册等待的事件和 <code>waker</code>）。</li>
</ul>
</li>
</ul>
<h2 id="spawner"><a class="header" href="#spawner">Spawner</a></h2>
<p>在初始状态下，<code>executor</code> 的执行队列中是空的，我们需要一种机制能够让用户手动地创建 <code>task</code> 并将 <code>task</code> 发送到 <code>executor</code> 的执行队列中，最后开启 <code>executor</code> 的执行。<code>Spawner</code> 抽象便提供了这种机制：</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
pub struct Spawner {
    task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
<p><code>Spawner</code> 中的 <code>task_sender</code> 和 <code>Task</code> 的 <code>task_sender</code> 一样，都是为了把 <code>task</code> 发送到 <code>executor</code> 的执行队列中。</p>
<h3 id="方法实现-3"><a class="header" href="#方法实现-3">方法实现</a></h3>
<pre><code class="language-rust noplayground">impl Spawner {
    fn new(task_sender: Sender&lt;Arc&lt;Task&gt;&gt;) -&gt; Self {
        Self { task_sender }
    }

    pub fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let task = Task::new(future, self.task_sender.clone());
        self.task_sender
            .send(Arc::new(task))
            .expect(&quot;send task failed&quot;);
    }
}</code></pre>
<p><code>new</code> 方法接收<code>Sender&lt;Arc&lt;Task&gt;&gt;</code> 参数，然后创建一个 <code>Spawner</code> 实例。</p>
<p><code>spawn</code> 方法中，使用传入的  <code>future</code>  参数创建一个 <code>Task</code> 实例，然后把这个 <code>task</code> 发送到 <code>executor</code> 的执行队列中。当 <code>executor</code> 开始执行的时候就可以从队列中接收 <code>task</code>，驱动 <code>task</code> 的执行了。</p>
<h2 id="创建-spawner--executor"><a class="header" href="#创建-spawner--executor">创建 Spawner &amp; Executor</a></h2>
<p>定义一个公开的函数，创建 <code>Spawner</code> 和 <code>Executor</code> 实例：</p>
<pre><code class="language-rust noplayground">pub fn spawner_and_executor() -&gt; (Spawner, Executor) {
    let (task_sender, task_queue) = bounded(10000);
    let spawner = Spawner::new(task_sender);
    let executor = Executor::new(task_queue);
    (spawner, executor)
}</code></pre>
<p>在 <code>spawner_and_executor</code> 函数中，我们使用 <code>crossbeam-channel</code> 提供的 <code>unbounded</code> 函数创建一个容量为 10000 的管道，分别返回管道的发送端和接收端，然后创建 <code>Spawner</code> 和 <code>Executor</code> 实例并返回。</p>
<blockquote>
<p>源代码仓库地址：<a href="https://github.com/night-cruise/async-runtime">https://github.com/night-cruise/async-runtime</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">example</a></h1>
<p>在这一节中，我们将使用之前实现的异步运行时创建一个 <code>tcp echo server</code>。需要导入的模块如下所示：</p>
<pre><code class="language-rust noplayground">use std::env;
use std::io::Write;

use log::info;

use async_runtime::async_io::{Ipv4Addr, TcpListener, TcpStream};
use async_runtime::executor::{spawner_and_executor, Spawner};</code></pre>
<h2 id="日志打印"><a class="header" href="#日志打印">日志打印</a></h2>
<pre><code class="language-rust noplayground">fn init_log() {
    // format = [file:line] msg
    env::set_var(&quot;RUST_LOG&quot;, &quot;info&quot;);
    env_logger::Builder::from_default_env()
        .format(|buf, record| {
            writeln!(
                buf,
                &quot;[{}:{:&gt;3}] {}&quot;,
                record.file().unwrap_or(&quot;unknown&quot;),
                record.line().unwrap_or(0),
                record.args(),
            )
        })
        .init();
}</code></pre>
<p><code>init_log</code> 函数是为了设置日志打印的消息格式，这跟异步运行时的使用没啥关系，这里就不再赘述了。</p>
<h2 id="handle_client"><a class="header" href="#handle_client">handle_client</a></h2>
<pre><code class="language-async">async fn handle_client(stream: TcpStream) {
    let mut buf = [0u8; 1024];
    info!(&quot;(handle client) {}&quot;, stream.raw_fd());
    loop {
        let n = stream.read(&amp;mut buf).await.unwrap();
        if n == 0 {
            break;
        }
        stream.write(&amp;buf[..n]).await.unwrap();
    }
}
</code></pre>
<p>在 <code>handle_client</code> 函数中，我们首先创建一个 <code>buf</code> 数组，然后打印一个 <code>handle client</code> 的日志消息，接着开启一个无限循环：</p>
<ul>
<li>
<p>调用 <code>stream.read(&amp;mut buf)</code> 方法后会返回一个 <code>ReadFuture</code>，在 <code>ReadFuture</code> 上调用 <code>await</code> 方法：</p>
<ul>
<li>
<p><code>ReadFuture.await</code> 会展开成一个无限循环，在循环内部会调用 <code>ReadFuture</code> 的 <code>poll</code> 方法。</p>
</li>
<li>
<p>如果返回 <code>Poll::Pending</code>，则使用 <code>Yield</code> 表达式挂起当前的 <code>task</code>；</p>
</li>
<li>
<p>如果返回 <code>poll::Ready</code> 则中断循环并返回结果。</p>
</li>
</ul>
</li>
<li>
<p>如果 <code>n== 0</code>，则说明客户端已经断开了连接，则退出循环。</p>
</li>
<li>
<p>调用 <code>stream.write(&amp;mut buf[.n])</code> 会返回一个 <code>WriteFuture</code>，在 <code>WriteFuture</code> 上调用 <code>await</code> 方法后执行流程与 <code>ReadFuture</code> 一致。</p>
</li>
</ul>
<h2 id="server_loop"><a class="header" href="#server_loop">server_loop</a></h2>
<pre><code class="language-rust noplayground">async fn server_loop(spawner: Spawner) {
    let addr = Ipv4Addr::new(127, 0, 0, 1);
    let port = 8080;
    let listener = TcpListener::bind(addr, port).unwrap();

    let incoming = listener.incoming();

    while let Some(stream) = incoming.next().await {
        let stream = stream.unwrap();
        spawner.spawn(handle_client(stream));
    }
}</code></pre>
<p>在 <code>server_loop</code> 函数中，我们调用 <code>TcpListener</code> 的 <code>bind</code> 方法创建一个 <code>TcpListener</code> 实例，然后调用 <code>incoming</code> 方法创建一个 <code>Incoming</code> 实例。</p>
<p>接着，在 <code>While let</code> 循环中，调用 <code>incoming</code> 的 <code>next</code> 方法返回一个 <code>AcceptFuture</code> 实例，在 <code>AcceptFuture</code> 上调用 <code>await</code> 方法后，如果返回的 <code>Poll::Pending</code>，则挂起当前的 <code>task</code>。</p>
<p>当有客户端连接到来时，<code>AcceptFuture</code> 等待的 IO 事件就绪，会返回 <code>io::Readult&lt;TcpStream&gt;</code> 的实例并绑定到 <code>stream</code> 变量上，接着使用 <code>spawner</code> 调用 <code>spawn</code> 方法创建一个 <code>task</code> 处理与客户端的交互。</p>
<p>最后，又进入循环的开始位置，继续等待新的连接到来。</p>
<h2 id="main-函数"><a class="header" href="#main-函数">main 函数</a></h2>
<pre><code class="language-rust noplayground">fn main() {
    init_log();

    let (spawner, mut executor) = spawner_and_executor();

    spawner.spawn(server_loop(spawner.clone()));

    executor.run();
}</code></pre>
<p>在 <code>main</code> 函数中，我们首先调用 <code>init_log</code> 函数设置日志消息格式，接着使用 <code>spawner_and_executor</code> 函数创建 <code>Spawner</code> 和 <code>Executor</code> 的实例。</p>
<p>然后调用 <code>spawner.spawn</code> 方法创建一个 <code>task</code> 用于执行 <code>server_loop</code>。</p>
<p>最后调用 <code>executor.run()</code> 方法开启 <code>executor</code> 的运行，开始调度执行各个 <code>task</code>。</p>
<h2 id="运行示例"><a class="header" href="#运行示例">运行示例</a></h2>
<p>开启运行后的 <code>echo server</code> 会监听地址：<code>127.0.0.1:8080</code>：</p>
<pre><code class="language-rust noplayground">cargo run --example echo_server
    Finished dev [unoptimized + debuginfo] target(s) in 0.69s
     Running `target/debug/examples/echo_server`
[src/async_io.rs: 56] (TcpListener) listen: 3
[src/reactor.rs: 27] (Reactor) add event: 3
[src/reactor.rs: 35] Start reactor main loop</code></pre>
<p>使用 <code>Python</code> 写一个小脚本模拟 <code>TCP</code> 客户端：</p>
<pre><code class="language-python">import socket
import threading

HOST = '127.0.0.1'
PORT = 8080


def send_request():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    for i in range(1, 1025):
        s.send(f&quot;HELLO WORLD[{i}]&quot;.encode())
        data = s.recv(1024).decode()
        print(f&quot;RECEIVE DATA: '{data}' in THREAD[{threading.currentThread().name}]&quot;)
    s.close()


def main():
    t_lst = []
    for _ in range(10):
        t = threading.Thread(target=send_request)
        t_lst.append(t)
        t.start()

    for t in t_lst:
        t.join()


if __name__ == '__main__':
    main()
</code></pre>
<p>运行脚本，服务端会输出以下内容：</p>
<pre><code>.....
.....
.....
[src/reactor.rs: 43] (Reactor) wake up. nfd = 2
[src/reactor.rs: 49] (Reactor) delete event: 6
[src/reactor.rs: 49] (Reactor) delete event: 7
[src/reactor.rs: 43] (Reactor) wake up. nfd = 3
[src/reactor.rs: 49] (Reactor) delete event: 9
[src/reactor.rs: 27] (Reactor) add event: 6
[src/reactor.rs: 49] (Reactor) delete event: 10
[src/reactor.rs: 49] (Reactor) delete event: 11
[src/reactor.rs: 43] (Reactor) wake up. nfd = 2
</code></pre>
<p>客户端的输出内容如下所示：</p>
<pre><code>.....
.....
.....
RECEIVE DATA: 'HELLO WORLD[1022]' in THREAD[Thread-3]
RECEIVE DATA: 'HELLO WORLD[1015]' in THREAD[Thread-7]
RECEIVE DATA: 'HELLO WORLD[1013]' in THREAD[Thread-6]
RECEIVE DATA: 'HELLO WORLD[1021]' in THREAD[Thread-1]
RECEIVE DATA: 'HELLO WORLD[1023]' in THREAD[Thread-3]
RECEIVE DATA: 'HELLO WORLD[1008]' in THREAD[Thread-10]
RECEIVE DATA: 'HELLO WORLD[1014]' in THREAD[Thread-6]
RECEIVE DATA: 'HELLO WORLD[1016]' in THREAD[Thread-7]
</code></pre>
<p>可以看出，我们的 <code>echo server</code> 正确地返回了响应，<code>wake up. nfd = 3</code> 表示有3个事件同时就绪，这说明 <code>server</code> 确实在并发地处理多个请求！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
