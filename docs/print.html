<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>async in rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="A book which aims to introduce the theory and mechanism of async/await syntax and async runtime in the Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥ç¼–ç¨‹.html"><strong aria-hidden="true">2.</strong> å¼‚æ­¥ç¼–ç¨‹</a></li><li class="chapter-item expanded "><a href="async-await.html"><strong aria-hidden="true">3.</strong> async/await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async-await/async-awaitçš„ä½¿ç”¨.html"><strong aria-hidden="true">3.1.</strong> async/await çš„ä½¿ç”¨</a></li><li class="chapter-item expanded "><a href="async-await/Future-trait.html"><strong aria-hidden="true">3.2.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="async-await/Generator.html"><strong aria-hidden="true">3.3.</strong> Generator</a></li><li class="chapter-item expanded "><a href="async-await/çŠ¶æ€æœº.html"><strong aria-hidden="true">3.4.</strong> çŠ¶æ€æœº</a></li><li class="chapter-item expanded "><a href="async-await/Pin.html"><strong aria-hidden="true">3.5.</strong> Pin</a></li></ol></li><li class="chapter-item expanded "><a href="IOæ¨¡å‹.html"><strong aria-hidden="true">4.</strong> IO æ¨¡å‹</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="IOæ¨¡å‹/é˜»å¡IO.html"><strong aria-hidden="true">4.1.</strong> é˜»å¡ IO</a></li><li class="chapter-item expanded "><a href="IOæ¨¡å‹/éé˜»å¡IO.html"><strong aria-hidden="true">4.2.</strong> éé˜»å¡ IO</a></li><li class="chapter-item expanded "><a href="IOæ¨¡å‹/ä¿¡å·é©±åŠ¨IO.html"><strong aria-hidden="true">4.3.</strong> ä¿¡å·é©±åŠ¨ IO</a></li><li class="chapter-item expanded "><a href="IOæ¨¡å‹/IOå¤šè·¯å¤ç”¨.html"><strong aria-hidden="true">4.4.</strong> IO å¤šè·¯å¤ç”¨</a></li><li class="chapter-item expanded "><a href="IOæ¨¡å‹/å¼‚æ­¥IO.html"><strong aria-hidden="true">4.5.</strong> å¼‚æ­¥ IO</a></li></ol></li><li class="chapter-item expanded "><a href="Epoll.html"><strong aria-hidden="true">5.</strong> Epoll</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Epoll/Epollä»‹ç».html"><strong aria-hidden="true">5.1.</strong> Epoll ä»‹ç»</a></li><li class="chapter-item expanded "><a href="Epoll/Epoll-server-example.html"><strong aria-hidden="true">5.2.</strong> Epoll server example</a></li></ol></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶.html"><strong aria-hidden="true">6.</strong> å¼‚æ­¥è¿è¡Œæ—¶</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/epoll.html"><strong aria-hidden="true">6.1.</strong> epoll</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/reactor.html"><strong aria-hidden="true">6.2.</strong> reactor</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/async_io.html"><strong aria-hidden="true">6.3.</strong> async_io</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/task.html"><strong aria-hidden="true">6.4.</strong> task</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/executor.html"><strong aria-hidden="true">6.5.</strong> executor</a></li><li class="chapter-item expanded "><a href="å¼‚æ­¥è¿è¡Œæ—¶/example.html"><strong aria-hidden="true">6.6.</strong> example</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async in rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/night-cruise/async-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>æœ¬ä¹¦ä¸»è¦ä»‹ç» Rust ä¸­ <code>async/await</code> è¯­æ³•å’Œå¼‚æ­¥è¿è¡Œæ—¶çš„åŸç†å’Œå·¥ä½œæœºåˆ¶ï¼Œå¹¶ä¸æ¶‰å®é™…çš„å¼‚æ­¥ä»£ç ç¼–å†™ã€‚å…¨ä¹¦çš„å†…å®¹ä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªç« èŠ‚ï¼š</p>
<ul>
<li>
<p><strong>å¼‚æ­¥ç¼–ç¨‹</strong>ï¼šä»‹ç» Rust å¼‚æ­¥ç¼–ç¨‹çš„åŸºç¡€æ¦‚å¿µï¼Œä»¥åŠåœ¨ Rust ä¸­åº”ç”¨çš„å¼‚æ­¥æ¨¡å‹ã€‚</p>
</li>
<li>
<p><strong>async/await</strong>ï¼šä»‹ç»Rustä¸ºæ”¯æŒå¼‚æ­¥ç¼–ç¨‹è€Œæä¾›çš„è¯­è¨€å±‚é¢çš„æ”¯æŒï¼ŒåŒ…æ‹¬ <code>async/await</code> è¯­æ³•å’Œå®ƒä»¬çš„å·¥ä½œåŸç†ã€‚</p>
</li>
<li>
<p><strong>IO æ¨¡å‹</strong>ï¼šä»‹ç»å‡ ç§ä¸»è¦çš„ IO æ¨¡å‹ï¼ŒåŒ…æ‹¬é˜»å¡ IOã€éé˜»å¡ IOã€IO å¤šè·¯å¤ç”¨å’Œå¼‚æ­¥ IOï¼Œå…¶ä¸­ IO å¤šè·¯å¤ç”¨æ˜¯åæ–‡ä»‹ç» <code>Epoll</code> çš„åŸºç¡€ã€‚</p>
</li>
<li>
<p><strong>Epoll</strong>ï¼šä»‹ç» <code>Epoll</code> çš„å·¥ä½œåŸç†å¹¶æä¾›ä¸€ä¸ªç®€å•çš„ <code>Epoll</code> server çš„å®ç°ä¾‹å­ã€‚<code>Epoll</code> æ˜¯ Linux ä¸­ IO å¤šè·¯å¤ç”¨çš„ä¸€ç§å®ç°ï¼Œæ˜¯åæ–‡ä»‹ç»å¼‚æ­¥è¿è¡Œæ—¶çš„åŸºç¡€ã€‚</p>
</li>
<li>
<p><strong>å¼‚æ­¥è¿è¡Œæ—¶</strong>ï¼šé€šè¿‡å®ç°ä¸€ä¸ªç®€å•çš„å¼‚æ­¥è¿è¡Œæ—¶æ¥ä»‹ç» <code>Reactor</code>ã€<code>Waker</code>ã€<code>Executor</code>ã€<code>Task</code> çš„åŸºæœ¬æ¦‚å¿µã€‚</p>
</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">https://rust-lang.github.io/async-book/03_async_await/01_chapter.html</a></li>
<li><a href="https://www.zhihu.com/question/389262477/answer/1566255353">https://www.zhihu.com/question/389262477/answer/1566255353</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.async.html">https://doc.rust-lang.org/std/keyword.async.html</a></li>
<li><a href="https://doc.rust-lang.org/std/keyword.await.html">https://doc.rust-lang.org/std/keyword.await.html</a></li>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html">https://doc.rust-lang.org/std/future/trait.Future.html</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html#futures-in-rust">https://cfsamson.github.io/books-futures-explained/1_futures_in_rust.html#futures-in-rust</a></li>
<li><a href="https://doc.rust-lang.org/std/task/struct.Context.html">https://doc.rust-lang.org/std/task/struct.Context.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/02_execution/02_future.html">https://rust-lang.github.io/async-book/02_execution/02_future.html</a></li>
<li><a href="https://github.com/ZhangHanDong/inviting-rust">https://github.com/ZhangHanDong/inviting-rust</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Generator.html">https://doc.rust-lang.org/std/ops/trait.Generator.html</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/enum.GeneratorState.html">https://doc.rust-lang.org/std/ops/enum.GeneratorState.html</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/master/library/core/src/future/mod.rs">https://github.com/rust-lang/rust/blob/master/library/core/src/future/mod.rs</a></li>
<li><a href="https://ipotato.me/article/70">https://ipotato.me/article/70</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/4_generators_async_await.html">https://cfsamson.github.io/books-futures-explained/4_generators_async_await.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html">https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained/5_pin.html">https://cfsamson.github.io/books-futures-explained/5_pin.html</a></li>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">https://rust-lang.github.io/async-book/04_pinning/01_chapter.html</a></li>
<li><a href="https://folyd.com/blog/rust-pin-unpin/">https://folyd.com/blog/rust-pin-unpin/</a></li>
<li><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html">https://doc.rust-lang.org/std/pin/struct.Pin.html</a></li>
<li><a href="https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html">https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html</a></li>
<li><a href="https://www.cnblogs.com/alex3714/articles/5876749.html">https://www.cnblogs.com/alex3714/articles/5876749.html</a></li>
<li><a href="https://www.jianshu.com/p/31cdfd6f5a48">https://www.jianshu.com/p/31cdfd6f5a48</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/92617116">https://zhuanlan.zhihu.com/p/92617116</a></li>
<li><a href="https://github.com/zupzup/rust-epoll-example">https://github.com/zupzup/rust-epoll-example</a></li>
<li><a href="https://github.com/mmisono/aa_echo">https://github.com/mmisono/aa_echo</a></li>
<li><a href="https://os.phil-opp.com/async-await">https://os.phil-opp.com/async-await</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¼‚æ­¥ç¼–ç¨‹"><a class="header" href="#å¼‚æ­¥ç¼–ç¨‹">å¼‚æ­¥ç¼–ç¨‹</a></h1>
<p>ä¸ºäº†é¿å…æ­§ä¹‰ï¼Œæœ¬ä¹¦ä¸­çš„å¼‚æ­¥ç¼–ç¨‹ç‰¹æŒ‡åœ¨ Rust ä¸­ä½¿ç”¨ <code>async/await</code> å…³é”®å­—è¿›è¡Œç¼–å†™å¼‚æ­¥ä»£ç ã€‚</p>
<p>é€šè¿‡ <code>async</code> å…³é”®å­—åˆ›å»ºçš„å¼‚æ­¥å‡½æ•°æˆ–è€…å¼‚æ­¥å—ä¼šè¿”å›ä¸€ä¸ªå®ç°äº† <code>Future</code> trait çš„ç±»å‹ï¼Œå…¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåç¨‹å¯¹è±¡ã€‚å°† <code>async/await</code> å…³é”®å­—å’Œå¼‚æ­¥è¿è¡Œæ—¶ç»“åˆä½¿ç”¨å°±å¯ä»¥å®ç°å¯¹å¤šä¸ªåç¨‹å¯¹è±¡çš„è°ƒåº¦æ‰§è¡Œï¼Œä»è€Œè¾¾åˆ°å¹¶å‘æ‰§è¡Œçš„æ•ˆæœã€‚</p>
<p>åœ¨ Rust ä¸­ä¸»è¦åº”ç”¨çš„æ˜¯ è¿›ç¨‹â€”çº¿ç¨‹â€”åç¨‹ å¼‚æ­¥æ¨¡å‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="imgs/async-model.png" alt="" /></p>
<p>ä¸‹å±‚æ˜¯è¿›ç¨‹ï¼Œè¿›ç¨‹æ˜¯æŒæœ‰èµ„æºçš„æœ€å°å•ä½ï¼›ä¸­å±‚æ˜¯çº¿ç¨‹ï¼Œçº¿ç¨‹ä¸æŒæœ‰èµ„æºï¼Œæ˜¯<code>CPU</code>è°ƒåº¦çš„æœ€å°å•ä½ï¼›ä¸Šå±‚æ˜¯åç¨‹ï¼Œåç¨‹æ—¢ä¸æŒæœ‰èµ„æºã€ä¹Ÿä¸åœ¨æ„<code>CPU</code>çš„è°ƒåº¦ï¼Œå®ƒä»…ä»…å…³æ³¨çš„æ˜¯â€œåä½œå¼çš„ã€è‡ªç„¶çš„æµç¨‹åˆ‡æ¢â€ã€‚</p>
<p>å¼‚æ­¥è¿è¡Œæ—¶å°±è´Ÿè´£è°ƒåº¦æ‰§è¡Œä¸Šè¿°çš„åç¨‹å¯¹è±¡ã€‚ä¾‹å¦‚åœ¨ä¸€ä¸ªåç¨‹åœ¨ç­‰å¾… IO æ—¶ï¼Œè¿™ä¸ªåç¨‹ä¼šä¸»åŠ¨å‡ºè®©è‡ªå·±çš„æ‰§è¡Œæƒç»™å¼‚æ­¥è¿è¡Œæ—¶ï¼Œè¿™æ—¶å¼‚æ­¥è¿è¡Œæ—¶å¯ä»¥è°ƒåº¦è¿è¡Œå…¶ä»–çš„åç¨‹ï¼Œä»è€Œæœ€å¤§åŒ–åœ°åˆ©ç”¨CPUæ—¶é—´ç‰‡ã€‚åœ¨ IO å¯†é›†å‹çš„åº”ç”¨ä¸­ï¼Œå¼‚æ­¥ç¼–ç¨‹å°†èƒ½å¤Ÿæå¤§åœ°æé«˜æ‰§è¡Œæ•ˆç‡ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">async/await</a></h1>
<p>åœ¨ <code>fn</code>ã€<code>closure</code>ã€<code>block</code>å‰ä½¿ç”¨ <code>async</code> å…³é”®å­—ï¼Œä¼šå°†æ ‡è®°çš„ä»£ç è½¬åŒ–ä¸ºä¸€ä¸ª <code>Future</code>ã€‚å› æ­¤ï¼Œ<code>async</code> æ ‡è®°çš„ä»£ç ä¸ä¼šç«‹å³è¿è¡Œï¼Œåªæœ‰åœ¨ <code>Future</code> ä¸Šè°ƒç”¨ <code>.await</code> æ—¶æ‰ä¼šè®¡ç®—è¿è¡Œ <code>Future</code>ã€‚è€Œåœ¨ <code>await</code> ä¸€ä¸ª <code>Future</code> æ—¶ï¼Œä¼šæš‚åœå½“å‰å‡½æ•°çš„æ‰§è¡Œï¼Œç›´åˆ° <code>executor</code> å®Œæˆå¯¹è¯¥ <code>Future</code> çš„è®¡ç®—ã€‚</p>
<p>ä»¥ä¸Šæ˜¯å¯¹ <code>async/await</code> è¯­ä¹‰çš„åŸºæœ¬ä»‹ç»ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæ›´åŠ æ·±å…¥åœ°ä»‹ç» <code>async/await</code> çš„ä½¿ç”¨å’Œå®ƒä»¬çš„åº•å±‚åŸç†ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait-çš„ä½¿ç”¨"><a class="header" href="#asyncawait-çš„ä½¿ç”¨">async/await çš„ä½¿ç”¨</a></h1>
<p><code>async/await </code>æ˜¯ Rust ä¸­ç‰¹æ®Šçš„è¯­æ³•ï¼Œå®ƒä½¿å¾—è®©å‡ºå½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒè€Œä¸é˜»å¡çº¿ç¨‹æˆä¸ºå¯èƒ½ï¼Œä»è€Œå…è®¸åœ¨ç­‰å¾…ä¸€ä¸ªæ“ä½œå®Œæˆæ—¶å¯ä»¥è¿è¡Œå…¶ä»–ä»£ç ã€‚</p>
<p>æœ‰ä¸¤ç§ä¸»è¦çš„æ–¹å¼ä½¿ç”¨ <code>async</code>ï¼š<code>async fn</code> å’Œ <code>async {}</code>ã€‚è¿™ä¸¤ä¸­ä½¿ç”¨æ–¹å¼éƒ½ä¼šè¿”å›ä¸€ä¸ªå®ç°äº† <code>Future trait</code> çš„å€¼ï¼š</p>
<pre><code class="language-rust noplayground">// `foo()` è¿”å›ä¸€ä¸ªå®ç°äº† `Future&lt;Output = u8&gt;` çš„ç±»å‹ã€‚
// `foo().await` å°†ä¼šäº§ç”Ÿä¸€ä¸ª u8 ç±»å‹çš„å€¼ã€‚
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // è¿™ä¸ª `async` å—ä¼šäº§ç”Ÿä¸€ä¸ªå®ç°äº† `Future&lt;Output = u8&gt;` çš„ç±»å‹ã€‚
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
</code></pre>
<p><code>async fn</code> å’Œ <code>async {}</code> è¿”å›çš„ <code>Future</code> æ˜¯æƒ°æ€§çš„ï¼šåœ¨çœŸæ­£å¼€å§‹è¿è¡Œä¹‹å‰å®ƒä»€ä¹ˆä¹Ÿä¸ä¼šåšã€‚è¿è¡Œä¸€ä¸ª <code>Future</code> çš„æœ€æ™®éçš„æ–¹å¼æ˜¯ <code>await</code> è¿™ä¸ª <code>Future</code>ï¼š <code>Future.await</code>ã€‚</p>
<p>å½“ <code>await</code> ä¸€ä¸ª <code>Future</code> æ—¶ï¼Œä¼šæš‚åœå½“å‰å‡½æ•°çš„è¿è¡Œï¼Œç›´åˆ°å®Œæˆå¯¹ <code>Future</code> çš„è¿è¡Œã€‚å¦‚æœè¿™ä¸ª <code>Future</code> è¢«é˜»å¡ä½äº†ï¼ˆä¾‹å¦‚ç­‰å¾…ç½‘ç»œIOï¼‰ï¼Œå®ƒä¼šè®©å‡ºå½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒã€‚å½“ <code>Future</code> ä¸­çš„é˜»å¡æ“ä½œå°±ç»ªæ—¶ï¼ˆä¾‹å¦‚ç­‰å¾…çš„ç½‘ç»œIOè¿”å›äº†å“åº”ï¼‰ï¼Œ<code>executor</code> ä¼šé€šè¿‡ <code>poll</code> ä¼šæ¢å¤ <code>Future</code> çš„è¿è¡Œã€‚</p>
<h2 id="async-lifetime"><a class="header" href="#async-lifetime">async lifetime</a></h2>
<p>ä¸æ™®é€šçš„å‡½æ•°ä¸ä¸€æ ·ï¼Œ<code>async fn</code> ä¼šè·å–å¼•ç”¨æˆ–å…¶ä»–éé™æ€ç”Ÿå‘½å‘¨æœŸçš„å‚æ•°ï¼Œç„¶åè¿”å›è¢«è¿™äº›å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„ <code>Future</code>ï¼š</p>
<pre><code class="language-rust noplayground">async fn foo(x: &amp;u8) -&gt; u8 { *x }

// è¿™ä¸ä¸Šé¢çš„å‡½æ•°å®Œå…¨ç­‰ä»·
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}</code></pre>
<p>è¿™æ„å‘³ç€ï¼Œ<code>async fn</code> è¿”å›çš„ <code>Future</code> å¿…é¡»åœ¨éé™æ€ç”Ÿå‘½å‘¨æœŸå‚æ•°ä»ç„¶æœ‰æ•ˆæ—¶ <code>.await</code>ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åœ¨è°ƒç”¨ <code>async</code> å‡½æ•°åä¼šç«‹é©¬ <code>.await</code>ï¼ˆä¾‹å¦‚ <code>foo(&amp;x).await</code>ï¼‰ï¼Œå› æ­¤ <code>async lifetime</code> ä¸ä¼šå¯¹æ‰§è¡Œäº§ç”Ÿä»€ä¹ˆå½±å“ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å­˜å‚¨è¿™ç§ <code>Future</code> æˆ–è€…å‘é€ç»™å…¶ä»–çš„ <code>task</code> æˆ–è€… <code>thread</code>ï¼Œå°±å¯èƒ½ä¼šé€ æˆé—®é¢˜ã€‚</p>
<p>æŠŠå¸¦æœ‰å¼•ç”¨å‚æ•°çš„ <code>async fn</code> è½¬åŒ–ä¸ºé™æ€ <code>Future</code> çš„è§£å†³æ–¹æ³•æ˜¯ï¼šæŠŠå‚æ•°å’Œå¯¹ <code>async fn</code> çš„è°ƒç”¨å°è£…åˆ° <code>async</code> å—ä¸­ï¼š</p>
<pre><code class="language-rust noplayground">fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR: `x` does not live long enough
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}</code></pre>
<p>é€šè¿‡æŠŠå‚æ•°ç§»åŠ¨åˆ° <code>async</code> å—ä¸­ï¼Œæˆ‘ä»¬æŠŠå®ƒçš„ç”Ÿå‘½å‘¨æœŸæ‰©å±•åˆ°äº†åŒ¹é…è°ƒç”¨ <code>good</code> è¿”å›çš„ <code>Future</code> çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<h2 id="async-move"><a class="header" href="#async-move">async move</a></h2>
<p><code>async</code> å—å’Œé—­åŒ…å…è®¸åƒæ™®é€šé—­åŒ…é‚£æ ·ä½¿ç”¨ <code>move</code> å…³é”®å­—ã€‚ä¸€ä¸ª <code>async move</code> å—ä¼šè·å–å˜é‡çš„æ‰€æœ‰æƒï¼Œä½†æ˜¯è¿™ä¼šå¯¼è‡´æ— æ³•ä¸å…¶ä»–çš„ä»£ç å…±äº«è¿™äº›å˜é‡ï¼š</p>
<pre><code class="language-rust noplayground">// ä¸åŒçš„ async å—å¯ä»¥è®¿é—®ç›¸åŒçš„å˜é‡sï¼Œåªè¦å®ƒä»¬éƒ½åœ¨sçš„ä½œç”¨åŸŸèŒƒå›´å†…æ‰§è¡Œ
async fn blocks() {
    let s = String::new(&quot;Hello World&quot;);
    let future_one = async {
        println!(&quot;{:?}&quot;, s);
    };
    let future_two = async {
        println!(&quot;{:?}&quot;, s);
    };
    
    futures::future::join(future_one, future_two); // need run in cargo with futures crate
}

// s è¢« move è¿›è¡Œ async å—ä¸­ï¼Œå› æ­¤åªèƒ½åœ¨è¯¥ async å—å†…æ‰èƒ½è®¿é—® 
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let s = String::from(&quot;Hello World&quot;);
    async move {
        println!(&quot;{:?}&quot;, s);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-trait"><a class="header" href="#future-trait">Future trait</a></h1>
<p>åœ¨å‰æ–‡ä¸­ï¼Œæˆ‘ä»¬æåˆ°ä½¿ç”¨ <code>async</code> æ ‡è®°çš„ <code>fn</code>ã€<code>block</code>ã€<code>closure</code> éƒ½ä¼šè¿”å›ä¸€ä¸ª <code>Future</code>ï¼Œæœ¬èŠ‚å°†ä¼šè¯¦ç»†åœ°ä»‹ç» <code>Future</code> çš„æ¦‚å¿µã€‚</p>
<p>åœ¨æ ‡å‡†åº“ä¸­ï¼Œ<code>Future</code> çš„å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">pub trait Future {
    type Output;	// Futureè®¡ç®—å®Œæˆæ—¶äº§ç”Ÿçš„å€¼çš„ç±»å‹
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}</code></pre>
<p><code>Future</code> è¡¨ç¤ºä¸€ä¸ªå¼‚æ­¥è®¡ç®—ï¼Œæˆ–è€…è¯´ä¼šåœ¨æœªæ¥å®Œæˆè®¡ç®—çš„æ“ä½œã€‚<code>Future</code> çš„æ ¸å¿ƒæ˜¯ <code>poll</code> æ–¹æ³•ï¼Œå½“è°ƒç”¨ <code>poll</code> æ–¹æ³•æ—¶ä¼šå°è¯•è®¡ç®— <code>Future</code> å¾—åˆ°æœ€ç»ˆçš„å€¼ã€‚å¦‚æœå€¼è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼ˆä¾‹å¦‚ç­‰å¾…æŸäº›äº‹ä»¶å‘ç”Ÿï¼‰ï¼Œåˆ™æ­¤æ–¹æ³•ä¸ä¼šé˜»å¡ï¼Œè€Œæ˜¯ä¼šç›´æ¥è¿”å›ä¸€ä¸ªç»“æœè¡¨ç¤º <code>Future</code> è¿˜æ²¡æœ‰è®¡ç®—å®Œæ¯•ã€‚</p>
<blockquote>
<p>æ³¨æ„ï¼š<code>Future trait</code> ä¸­æ¶‰åŠåˆ°çš„ <code>Pin</code> å°†ä¼šåœ¨åé¢çš„ç« èŠ‚ä¸­ä»‹ç»ã€‚</p>
</blockquote>
<h2 id="poll"><a class="header" href="#poll">poll</a></h2>
<p>åœ¨ä¸Šé¢å¯¹ <code>Future</code> çš„ä»‹ç»ä¸­ï¼Œæˆ‘ä»¬ç®€è¦æåˆ°äº† <code>poll</code> æ–¹æ³•ï¼Œä¸‹é¢æˆ‘ä»¬ä¼šå¯¹ <code>poll</code> æ–¹æ³•è¿›è¡Œæ›´è¯¦ç»†çš„ä»‹ç»ã€‚å½“è°ƒç”¨ <code>Future</code> çš„ <code>poll</code> æ–¹æ³•æ—¶ä¼šè¿”å›ä¸€ä¸ªæšä¸¾ç±»å‹çš„å€¼ï¼š</p>
<ul>
<li><code>Poll::Pending</code>ï¼Œè¡¨ç¤ºè¿™ä¸ª <code>Future</code> è¿˜æ²¡è®¡ç®—å®Œæˆ</li>
<li><code>Poll::Ready(val)</code>ï¼Œè¡¨ç¤ºè¿™ä¸ª <code>Future</code> è®¡ç®—å®Œæ¯•ï¼Œå¹¶é™„å¸¦è®¡ç®—ç»“æœï¼š<code>val</code></li>
</ul>
<p>å¦‚æœ <code>Future</code> æ²¡æœ‰è®¡ç®—å®Œæˆï¼Œä¾‹å¦‚æƒ³è¦ç­‰å¾…ä¸€ä¸ª IO äº‹ä»¶å‘ç”Ÿï¼Œé‚£ä¹ˆåœ¨ <code>poll</code> æ–¹æ³•ä½“å†…ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šè°ƒç”¨ä¼ é€’ç»™ <code>poll</code> æ–¹æ³•çš„ <code>Context</code> çš„ <code>waker</code> æ–¹æ³•æ‹¿åˆ°ä¸€ä¸ª <code>Waker</code>ï¼ˆé€šå¸¸æŠŠ <code>Waker</code> å«åšå”¤é†’å™¨ï¼‰ï¼Œç„¶åæ³¨å†Œè¿™ä¸ª <code>Waker</code> åˆ°ä¸€ä¸ªâ€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€ä¸­ï¼Œæœ€åè¿”å› <code>Pending</code> è¡¨ç¤º <code>Future</code> æ²¡æœ‰è®¡ç®—å®Œæˆã€‚</p>
<p>åœ¨æœªæ¥æŸä¸€æ—¶åˆ»ï¼Œ<code>Future</code> ç­‰å¾…çš„ IO äº‹ä»¶å°±ç»ªäº†ï¼Œé‚£ä¹ˆâ€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€å°±ä¼šåˆ©ç”¨æˆ‘ä»¬æ³¨å†Œçš„ Waker é€šè¿‡æŸç§å”¤é†’æœºåˆ¶å”¤é†’è¿™ä¸ª <code>Future</code>ï¼Œé€šè¿‡ <code>poll</code> ç»§ç»­è®¡ç®—æ‰§è¡Œè¯¥ <code>Future</code>ã€‚</p>
<p>é€šè¿‡ <code>Waker</code> å”¤é†’å™¨ï¼Œæˆ‘ä»¬å¯ä»¥åªåœ¨ <code>Future</code> æƒ³è¦ç­‰å¾…çš„äº‹ä»¶å°±ç»ªæ—¶ï¼Œæ‰å»å”¤é†’ <code>Future</code>ã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸éœ€è¦é€šè¿‡ä¸€ä¸ªæ­»å¾ªç¯ä¸æ–­çš„è°ƒç”¨ <code>poll</code> æ–¹æ³•æ¥é©±åŠ¨ <code>Future</code> çš„æ‰§è¡Œï¼Œè¿™æ˜¯å¼‚æ­¥ç¼–ç¨‹ä¹‹æ‰€ä»¥é«˜æ•ˆçš„å…³é”®æ‰€åœ¨ã€‚</p>
<h2 id="å°æ —å­"><a class="header" href="#å°æ —å­">å°æ —å­</a></h2>
<p>ä¸‹é¢æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥ä»‹ç» <code>Future trait</code> çš„ä½¿ç”¨ã€‚</p>
<p>å‡è®¾æˆ‘ä»¬å‡†å¤‡è¯»å–ä¸€ä¸ª <code>socket</code>ï¼Œä½†æ˜¯å®ƒå¯èƒ½è¿˜æ²¡æœ‰å‡†å¤‡å¥½æ•°æ®ã€‚å¦‚æœæ•°æ®å‡†å¤‡å¥½äº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¯»å–å®ƒç„¶åç„¶åè¿”å› <code>Poll::Ready(data)</code>ï¼Œä½†æ˜¯å¦‚æœæ•°æ®æ²¡æœ‰å‡†å¤‡å¥½ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨å†Œä¸€ä¸ªå”¤é†’å™¨åˆ°â€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€ä¸­ï¼š</p>
<pre><code class="language-rust noplayground">struct SocketRead&lt;'a&gt; {
	socket: &amp;'a Socket
}

impl&lt;'a&gt; Future for SocketRead&lt;'a&gt; {
	type Output = Vec&lt;u8&gt;;
	
	fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_'&gt;) -&gt; Poll&lt;Self::Output&gt; {
		let data = self.socket.no_block_read::&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;(1024);
		match data {
			Some(data) =&gt; Poll::Ready(data),
			None =&gt; {
				REACTOR.registe_waker_and_event(self.socket, Type::Read, cx.waker().clone());
				Poll::Pending
			}
		}
	}
}</code></pre>
<p>ä»£ç ä¸­çš„ <code>REACTOR </code>å°±æ˜¯å‰æ–‡ä¸­æ‰€æåˆ°è¿‡çš„â€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€ã€‚å½“ <code>socket</code> ä¸­æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œ<code>REACTOR </code>å°±ä¼šä½¿ç”¨æ³¨å†Œçš„ <code>Waker</code> å”¤é†’è´Ÿè´£ <code>SocketRead </code>ï¼Œç„¶åè°ƒç”¨ <code>poll</code> æ–¹æ³•å†æ¬¡è®¡ç®—è¯¥ <code>Future</code>ã€‚</p>
<h2 id="leaf--non-leaf-future"><a class="header" href="#leaf--non-leaf-future">Leaf / Non-leaf Future</a></h2>
<p>åœ¨å‰æ–‡ä¸­æˆ‘ä»¬æåˆ°ä½¿ç”¨ <code>async</code> å…³é”®å­—å¯ä»¥åˆ›å»ºä¸€ä¸ª <code>Future</code> ç±»å‹ï¼Œè€Œåœ¨ä¸Šé¢çš„å°æ —å­ä¸­æˆ‘ä»¬é€šè¿‡å®ç° <code>Future trait</code> çš„æ–¹å¼ä¹Ÿåˆ›å»ºäº†ä¸€ä¸ª <code>Future</code> ç±»å‹ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ª <code>Future</code> æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ</p>
<h3 id="leaf-future"><a class="header" href="#leaf-future">Leaf Future</a></h3>
<p>é€šè¿‡ä¸ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹å®ç° <code>Future trait</code> çš„æ–¹å¼åˆ›å»ºçš„ <code>Future</code> è¢«ç§°ä¸º <code>Leaf Future</code>ã€‚ä¾‹å¦‚ä¸Šé¢çš„å°æ —å­ä¸­çš„ <code>SocketRead</code> ç±»å‹ï¼š</p>
<pre><code class="language-rust noplayground">struct SocketRead&lt;'a&gt; {
	socket: &amp;'a Socket
}

impl&lt;'a&gt; Future for SocketRead&lt;'a&gt; {
	/
}</code></pre>
<p><code>Leaf Future</code> ä¸­é€šå¸¸ä¼šæ¶‰åŠåˆ°å¯¹ IO çš„æ“ä½œï¼Œä¾‹å¦‚ä»ä¸€ä¸ª <code>socket</code> ä¸­è¯»å–æ•°æ®ï¼Œå¹¶ä¸”å¯¹ IO çš„æ“ä½œæ˜¯éé˜»å¡å¼çš„ã€‚</p>
<p>å½“è°ƒç”¨å¼‚æ­¥è¿è¡Œæ—¶æä¾›çš„å¼‚æ­¥è¯» <code>socket</code> çš„æ–¹æ³•æ—¶å°±ä¼šè¿”å›ä¸Šè¿°çš„ <code>Future</code>ï¼š</p>
<pre><code class="language-rust noplayground">impl async_runtime {
	fn read_socket(&amp;self) -&gt; SocketRead {
		// ...
	}
}

let mut leaf_future: SocketRead = async_runtime.read_socket();</code></pre>
<p>é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™äº› <code>Leaf Future</code> éƒ½æ˜¯ç”±å¼‚æ­¥è¿è¡Œæ—¶è‡ªå·±åˆ›å»ºçš„ï¼Œç”¨æˆ·åªéœ€è¦ä½¿ç”¨ <code>async/await</code> å…³é”®å­—å³å¯ã€‚</p>
<h3 id="non-leaf-future"><a class="header" href="#non-leaf-future">Non-leaf Future</a></h3>
<p><code>Non-leaf Future</code> æ˜¯æˆ‘ä»¬ä½¿ç”¨ <code>async</code> å…³é”®å­—åˆ›å»º <code>Future</code>ï¼Œå¹¶ä¸”ä¼šç”± <code>async runtime</code> æ¥è°ƒåº¦è¿è¡Œã€‚</p>
<p>åœ¨ <code>Non-leaf Future</code> ä¸­å¯ä»¥åˆ›å»ºå¤šä¸ª <code>Leaf Future</code>ï¼Œ å¹¶ä¸”é€šè¿‡ <code>await</code> <code>Leaf Future</code> æ¥å®Œæˆå¯¹ IO çš„æ“ä½œï¼š</p>
<pre><code class="language-rust noplayground">let non_leaf_future = async {
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
	
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
	
	let data = async_runtime.read_socket().await;
	println!(&quot;Receive data: {:?}&quot;, data);
}</code></pre>
<p>åœ¨ <code>await</code> ä¸€ä¸ª <code>Leaf Future</code> æ—¶ï¼Œå¦‚æœè¿”å›çš„æ˜¯ <code>Pending</code>ï¼Œé‚£ä¹ˆ<code>Non-Leaf Future</code> å°±ä¼šè®©å‡ºå¯¹å½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒï¼Œæ­¤æ—¶ <code>async runtime</code> å°±èƒ½å¤Ÿè°ƒåº¦æ‰§è¡Œå…¶ä»–çš„ <code>Non-Leaf Future</code> ã€‚å½“ <code>Non-Leaf Future</code> ä¸­çš„ IO æ“ä½œå°±ç»ªæ—¶ï¼Œ<code>async runtime</code> å°±ä¼šé‡æ–°æ¿€æ´»æŒ‚èµ·çš„ <code>Future</code>ï¼Œåœ¨<strong>ä¸Šæ¬¡ç¦»å¼€çš„åœ°æ–¹ç»§ç»­è¿è¡Œ</strong>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator"><a class="header" href="#generator">Generator</a></h1>
<p><code>Future</code> çš„åº•å±‚ä¾èµ–äºç”Ÿæˆå™¨ï¼Œå› æ­¤åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†ä¼šä»‹ç»ç”Ÿæˆå™¨çš„æ¦‚å¿µï¼Œä»¥åŠç”Ÿæˆå™¨æ˜¯å¦‚ä½•è½¬åŒ–ä¸º <code>Future</code> çš„ã€‚</p>
<h2 id="generator-å®šä¹‰"><a class="header" href="#generator-å®šä¹‰">Generator å®šä¹‰</a></h2>
<p><code>Generator</code> çš„å®šä¹‰ä½äºæ ‡å‡†åº“çš„ <code>ops</code> æ¨¡å—ä¸­ï¼Œå…·ä½“å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}

pub enum GeneratorState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}</code></pre>
<p><code>Generator</code> é€šå¸¸ä¹Ÿè¢«ç§°ä¸ºåç¨‹ï¼Œä¸»è¦ç›®çš„æ˜¯ä¸º <code>async/await</code> è¯­æ³•æä¾›æ„å»ºå—ï¼Œä½†æ˜¯æœªæ¥ä¹Ÿå¯èƒ½ä¼šæ‰©å±•åˆ°ä¸º <code>Iterator</code> å’Œå…¶ä»–ç±»å‹æä¾›ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„å®šä¹‰ã€‚</p>
<p><code>Generator</code> çš„å…³è”ç±»å‹ <code>Yield</code> å¯¹åº”äºä½¿ç”¨<code>yield</code> è¡¨è¾¾å¼äº§å‡ºçš„å€¼çš„ç±»å‹ã€‚</p>
<p><code>Generator</code> çš„å…³è”ç±»å‹ <code>Return</code> å¯¹åº”äºä½¿ç”¨ <code>return</code> è¯­å¥æˆ–è€…ç”Ÿæˆå™¨ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼è¿”å›çš„å€¼çš„ç±»å‹ã€‚</p>
<blockquote>
<p>æ³¨æ„ï¼š<code>Generator trait</code> ä¸­æ¶‰åŠåˆ°çš„ <code>Pin</code> å°†ä¼šåœ¨åé¢çš„ç« èŠ‚ä¸­ä»‹ç»ã€‚</p>
</blockquote>
<h2 id="resume"><a class="header" href="#resume">resume</a></h2>
<p>è°ƒç”¨ <code>Generator</code> çš„ <code>resume</code> æ–¹æ³•ä¼šæ¢å¤ç”Ÿæˆå™¨çš„è¿è¡Œï¼Œå¦‚æœè¿˜æ²¡æœ‰å¯åŠ¨ç”Ÿæˆå™¨çš„è¯åˆ™ä¼šå¯åŠ¨ç”Ÿæˆå™¨ã€‚</p>
<p>åœ¨æ‰§è¡Œç”Ÿæˆå™¨çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ° <code>yield</code> è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆç”Ÿæˆå™¨å°±ä¼šåœ¨è¿™ä¸ª <code>yield</code> ç‚¹æŒ‚èµ·ï¼Œå¹¶äº§å‡º <code>yield</code> è¡¨è¾¾å¼çš„å€¼ï¼š<code>GeneratorState::Yielded(Y)</code>ã€‚å½“å†æ¬¡è°ƒç”¨ <code>resume</code> æ–¹æ³•æ—¶ç”Ÿæˆå™¨å°±ä¼šåœ¨æŒ‚èµ·çš„ <code>yield</code> ç‚¹æ¢å¤è¿è¡Œã€‚</p>
<p>åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°çš„æ˜¯ <code>return</code> è¯­å¥æˆ–è€…ç”Ÿæˆå™¨æœ«å°¾çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ï¼Œé‚£ä¹ˆç”Ÿæˆå™¨æ‰§è¡Œå®Œæ¯•ï¼Œå¹¶è¿”å› <code>GeneratorState::Complete(R)</code>ï¼Œ<code>R</code> å°±æ˜¯ <code>return</code> è¯­å¥æˆ–è€…æœ«å°¾è¡¨è¾¾å¼çš„å€¼ã€‚</p>
<p>å¦‚æœç”Ÿæˆå™¨å·²ç»æ‰§è¡Œå®Œæ¯•ï¼Œè¿”å›äº† <code>GeneratorState::Complete</code>ï¼Œé‚£ä¹ˆå½“å†æ¬¡è°ƒç”¨ <code>Generator</code> çš„ <code>resume</code> æ–¹æ³•æ—¶å°†ä¼šå¯¼è‡´ <code>panic</code>ã€‚</p>
<h2 id="generator-ä½¿ç”¨"><a class="header" href="#generator-ä½¿ç”¨">Generator ä½¿ç”¨</a></h2>
<p>åœ¨é—­åŒ…ä¸­ä½¿ç”¨ <code>yield</code> å…³é”®å­—å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªç”Ÿæˆå™¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};


fn main() {
    let mut gen = || {
        for i in 0..10 {
            yield i;
        }
        
        return ();
    };
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(r) =&gt; {
                println!(&quot;Complete: {:?}&quot;, r);
                break;
            }
        }
    }
}</code></pre></pre>
<p>é€šè¿‡ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° <code>Generator trait</code> æ¥åˆ›å»ºç”Ÿæˆå™¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};


fn main() {
    let mut gen = MyGenerator { counter: 1, completed: false };
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(r) =&gt; {
                println!(&quot;Complete: {}&quot;, r);
                break;
            }
        }
    }
}


struct MyGenerator {
    counter: i32,
    completed: bool
}


impl&lt;R&gt; Generator&lt;R&gt; for MyGenerator {
    type Yield = i32;
    type Return = char;
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        if self.completed {
            panic!(&quot;MyGenerator has been completed.&quot;);
        }
        
        let counter = self.counter;
        if counter &lt; 10 {
            self.get_mut().counter = counter + 1;
            GeneratorState::Yielded(counter)
        } else {
            self.get_mut().completed = true;
            GeneratorState::Complete('ğŸ‰')
        }
    }
}</code></pre></pre>
<p>æŠŠç”Ÿæˆå™¨å½“ä½œè¿­ä»£å™¨ä½¿ç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::iter::Iterator;
use std::ops::{Generator, GeneratorState};


fn main() {
    let gen = MyGenerator { counter: 0, completed: false };
    
    for val in gen {
        println!(&quot;Got: {}&quot;, val);
    }

}


struct MyGenerator {
    counter: i32,
    completed: bool
}


impl&lt;R&gt; Generator&lt;R&gt; for MyGenerator {
    type Yield = i32;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        if self.completed {
            panic!(&quot;MyGenerator has been completed.&quot;);
        }
        
        let counter = self.counter;
        if counter &lt; 10 {
            self.get_mut().counter = counter + 1;
            GeneratorState::Yielded(counter)
        } else {
            self.get_mut().completed = true;
            GeneratorState::Complete(())
        }
    }
}

impl Iterator for MyGenerator {
    type Item = i32;
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match Pin::new(self).resume(()) {
            GeneratorState::Yielded(y) =&gt; Some(y),
            GeneratorState::Complete(_) =&gt; None
        }
    }
}</code></pre></pre>
<h2 id="from-generator-to-future"><a class="header" href="#from-generator-to-future">From Generator to Future</a></h2>
<p>Rust çš„ <code>core</code> åº“ä¸­çš„ <code>future</code> æ¨¡å—å®šä¹‰äº†å°†ç”Ÿæˆå™¨è½¬åŒ–ä¸º <code>Future</code> çš„å‡½æ•°ï¼ˆä¸ºäº†ä¾¿äºé˜…è¯»å»æ‰äº†æ³¨é‡Šéƒ¨åˆ†ï¼‰ï¼š</p>
<pre><code class="language-rust noplayground">pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
	where T: Generator&lt;ResumeTy, Yield = ()&gt;
{
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
   
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}</code></pre>
<p>ä»æºç ä¸­å¯ä»¥çœ‹å‡ºï¼Œå®é™…ä¸Šæˆ‘ä»¬ä½¿ç”¨ <code>async</code> åˆ›å»ºçš„ <code>Future</code> æ˜¯ä¸€ä¸ªå®ç°äº† <code>Future trait</code> çš„ç»“æ„ä½“ <code>GenFuture</code>ï¼Œè¿™ä¸ªç»“æ„ä½“çš„å†…éƒ¨æ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ã€‚</p>
<p>åœ¨æˆ‘ä»¬è°ƒç”¨ <code>Future</code> çš„ <code>poll</code> æ–¹æ³•æ—¶ï¼Œå®é™…ä¸Šå°±æ˜¯åœ¨è°ƒç”¨åº•å±‚çš„ç”Ÿæˆå™¨çš„ <code>resume</code> æ–¹æ³•ï¼Œå¹¶ä¸”ç”Ÿæˆå™¨è¿”å›çš„ <code>GeneratorState::Yielded/Complete(val)</code> ä¼šè¢«åˆ†åˆ«è½¬åŒ–ä¸º <code>poll</code> çš„è¿”å›ç±»å‹ï¼š<code>Poll::Pending/Ready(val)</code>ã€‚</p>
<h2 id="å°æ —å­-1"><a class="header" href="#å°æ —å­-1">å°æ —å­</a></h2>
<p>åœ¨æœ¬èŠ‚çš„æœ€åï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå°æ —å­æŠŠå‰é¢è®²çš„ <code>async/await</code>ã€<code>Future</code>ã€<code>Generator</code> çš„çŸ¥è¯†ä¸²è”èµ·æ¥ã€‚</p>
<p>æœ‰å¦‚ä¸‹çš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
async fn foo() -&gt; i32 {
    10
}

#[inline(never)]
async fn bar() -&gt; i32 {
    foo().await
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://rustc-dev-guide.rust-lang.org/hir.html">HIR</a> æ˜¯ Rust ä»£ç ç¼–è¯‘çš„ä¸­é—´äº§ç‰©ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬ç›´åˆ°ä»£ç åœ¨è„±ç³–åæ˜¯ä»€ä¹ˆæ ·å­ã€‚å¯ä»¥ä½¿ç”¨ Rust <code>Playground</code> çš„ <code>HIR</code> åŠŸèƒ½ç¼–è¯‘ä¸Šè¿°ä»£ç ï¼Œç»“æœå¦‚ä¸‹ï¼š</p>
<pre><code class="language-rust noplayground">#[inline(never)]
async fn foo()
    -&gt;
        /*impl Trait*/ #[lang = &quot;from_generator&quot;](move |mut _task_context|
        { { let _t = { 10 }; _t } })

#[inline(never)]
async fn bar()
    -&gt;
        /*impl Trait*/ #[lang = &quot;from_generator&quot;](move |mut _task_context|
        {
                {
                        let _t =
                            {
                                    match #[lang = &quot;into_future&quot;](foo()) {
                                            mut pinned =&gt;
                                                loop {
                                                        match unsafe {
                                                                            #[lang = &quot;poll&quot;](#[lang = &quot;new_unchecked&quot;](&amp;mut pinned),
                                                                                #[lang = &quot;get_context&quot;](_task_context))
                                                                        } {
                                                                #[lang = &quot;Ready&quot;] { 0: result } =&gt; break result,
                                                                #[lang = &quot;Pending&quot;] {} =&gt; { }
                                                            }
                                                        _task_context = (yield ());
                                                    },
                                        }
                                };
                        _t
                    }
            })</code></pre>
<p>åŸç”Ÿçš„ <code>HIR</code> ä»£ç éš¾ä»¥é˜…è¯»ï¼Œæˆ‘ä»¬å°†å…¶è½¬åŒ–ä¸ºä¸‹é¢çš„ Rust ä¼ªä»£ç ï¼š</p>
<pre><code class="language-rust noplayground">#[inline(never)]
async fn foo() -&gt; impl Future&lt;Output = i32&gt; {
    from_generator(move |mut _task_context| {
        let _t = 10;
        _t
    })
}

#[inline(never)]
async fn bar() -&gt; impl Future&lt;Output = i32&gt; {
    from_generator(move |mut _task_context| {
        let _t = {
            match into_future(foo()) {
                mut pinned =&gt; {
                    loop {
                        match unsafe Pin::new_unchecked(&amp;mut pinned).poll(get_context(_task_context)) {
                            Poll::Ready(result) =&gt; break result,
                            Poll::Pending =&gt; {}
                        }
                        _task_context = (yield ());
                    }
                }
            }
        };
        _t
    })
}</code></pre>
<p>å¯ä»¥çœ‹åˆ° <code>async</code> å‡½æ•°ä½“å†…çš„ä»£ç è¢«è½¬åŒ–æˆäº†ä¸€ä¸ªç”Ÿæˆå™¨ï¼Œç„¶åå†è°ƒç”¨ <code>from_generator</code> å‡½æ•°ä¼ å…¥ç”Ÿæˆå™¨åˆ›å»ºä¸€ä¸ª <code>Future</code> ï¼Œè¿™ä¸æˆ‘ä»¬ä¸Šé¢ä»‹ç»çš„ <code>from_generator</code> å‡½æ•°çš„åŠŸèƒ½ä¸€è‡´ã€‚</p>
<p><code>await</code> éƒ¨åˆ†åˆ™è¢«è½¬åŒ–ä¸ºäº†ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œåœ¨å¾ªç¯çš„å†…éƒ¨ä¼šè°ƒç”¨ <code>await</code> çš„ <code>Future</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œå¦‚æœç»“æœæ˜¯ <code>Poll::Ready</code>ï¼Œåˆ™ç»ˆæ­¢å¾ªç¯å¹¶è¿”å› <code>result</code>ï¼Œç»§ç»­æ‰§è¡Œå‰©ä½™çš„ä»£ç ï¼›å¦‚æœç»“æœæ˜¯ <code>Poll::Pending</code>ï¼Œåˆ™ä¼šä½¿ç”¨ <code>yield</code> æŒ‚èµ·ç”Ÿæˆå™¨ï¼Œå°†æ§åˆ¶æƒè½¬ç§»ç»™è°ƒç”¨æ–¹ã€‚å½“è°ƒç”¨æ–¹æ¿€æ´»è¿™ä¸ªæŒ‚èµ·çš„ç”Ÿæˆå™¨æ—¶ï¼Œç”Ÿæˆå™¨å°±ä¼šæ¢å¤è¿è¡Œï¼Œæ‰§è¡Œå¾ªç¯ä½“ä¸­çš„ä»£ç ã€‚</p>
<p>å› æ­¤ï¼Œåªæœ‰å½“ <code>await</code> çš„ <code>Future</code> æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œæ‰ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œ <code>async</code> å—ä¸­çš„ä»£ç ï¼Œè¿™æ ·å°±ç¡®ä¿äº†èƒ½å¤Ÿä»¥åŒæ­¥çš„æ–¹å¼ç¼–å†™å¼‚æ­¥ä»£ç ï¼Œè®©æˆ‘ä»¬èƒ½æ‹¥æœ‰è‰¯å¥½çš„å¼€å‘ä½“éªŒã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="çŠ¶æ€æœº"><a class="header" href="#çŠ¶æ€æœº">çŠ¶æ€æœº</a></h1>
<p>åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®²åˆ°ç”Ÿæˆå™¨æ‰§è¡Œåˆ° <code>yield</code> è¡¨è¾¾å¼æ—¶ï¼Œä¼šåœ¨è¿™ä¸ª <code>yield</code> ç‚¹æŒ‚èµ·ï¼Œå½“å†æ¬¡æ¿€æ´»ç”Ÿæˆå™¨æ—¶ä¼šåœ¨æŒ‚èµ·çš„ <code>yield</code> ç‚¹æ¢å¤è¿è¡Œï¼Œé‚£ä¹ˆç”Ÿæˆå™¨æ˜¯æ€ä¹ˆä¿å­˜åœ¨ <code>yield</code> ç‚¹æŒ‚èµ·æ—¶çš„çŠ¶æ€å‘¢ï¼Ÿ</p>
<p>äº‹å®ä¸Šï¼Œç¼–è¯‘å™¨ä¼šæŠŠç”Ÿæˆå™¨è½¬åŒ–ä¸ºä¸€ä¸ªçŠ¶æ€æœºï¼ŒçŠ¶æ€æœºä¸­ä¼šä¿å­˜æ¯ä¸€ä¸ª <code>yield</code> ç‚¹çš„ç”Ÿæˆå™¨çš„æ‰§è¡ŒçŠ¶æ€ã€‚</p>
<p>å‡å¦‚æˆ‘ä»¬å†™äº†ä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„ç”Ÿæˆå™¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = || {
        yield 1;
        yield 2;

        ()
    };

    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}</code></pre></pre>
<p>ç¼–è¯‘å™¨ä¼šæŠŠç”Ÿæˆå™¨è½¬åŒ–ä¸ºä¸‹é¢çš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::mem;
use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = MyGenerator::new();

    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}

enum MyGenerator {
    Enter,
    State1(i32),
    State2(i32),
    Exit
}

impl&lt;R&gt; Generator&lt;R&gt; for MyGenerator {
    type Yield = i32;
    type Return = ();

    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        let mut_gen = self.get_mut();
        match mem::replace(mut_gen, MyGenerator::Exit) {
            MyGenerator::Enter =&gt; {
                *mut_gen = MyGenerator::State1(1);
                GeneratorState::Yielded(1)
            }
            MyGenerator::State1(_) =&gt; {
                *mut_gen = MyGenerator::State2(2);
                GeneratorState::Yielded(2)
            }
            MyGenerator::State2(_) =&gt; {
                *mut_gen = MyGenerator::Exit;
                GeneratorState::Complete(())
            }
            MyGenerator::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
        }
    }
}

impl MyGenerator {
    fn new() -&gt; Self {
        Self::Enter
    }
}</code></pre></pre>
<p>åŒæ—¶ï¼Œç”±äºæ¯ä¸ª <code>async</code> å‡½æ•°æœ€ç»ˆéƒ½ä¼šç”Ÿæˆä¸€ä¸ªçŠ¶æ€æœºï¼Œå¹¶ä¸”æ¯ä¸ªå¯æ‰§è¡Œæ–‡ä»¶éƒ½ä¼šæ†ç»‘ä¸€ä¸ªå¼‚æ­¥è¿è¡Œæ—¶ï¼Œè¿™ä¼šå¯¼è‡´å¼‚æ­¥çš„ Rust ä»£ç åœ¨ç¼–è¯‘åäº§ç”Ÿæ›´å¤§çš„äºŒè¿›åˆ¶ä½“ç§¯ï¼Œè¿™ä¹Ÿæ˜¯ <code>async</code> Rust çš„ä¸€ä¸ªå°ç¼ºç‚¹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin"><a class="header" href="#pin">Pin</a></h1>
<p>å‰æ–‡çš„ <code>Future trait</code>ã€<code>Geneartor</code> å’ŒçŠ¶æ€æœºä¸­éƒ½å‡ºç°äº† <code>Pin</code>ï¼Œé‚£ä¹ˆ <code>Pin</code> åˆ°åº•æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šè¯¦ç»†åœ°ä»‹ç»å®ƒã€‚</p>
<h2 id="è‡ªå¼•ç”¨ç»“æ„"><a class="header" href="#è‡ªå¼•ç”¨ç»“æ„">è‡ªå¼•ç”¨ç»“æ„</a></h2>
<p>åœ¨ Safe Rust ä¸­ï¼Œæˆ‘ä»¬æ— æ³•åˆ›å»ºè‡ªå¼•ç”¨ç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let s = &quot;Hello World&quot;.to_string();
    let _ = SelfReference {
        a: s,
        b: &amp;s
    };
}

struct SelfReference&lt;'a&gt; {
	a: String,
	b: &amp;'a String
}</code></pre></pre>
<p>å¦‚æœç¼–è¯‘ï¼Œå°†ä¼šå‘ç”ŸæŠ¥é”™ï¼š</p>
<pre><code class="language-rust noplayground">error[E0382]: borrow of moved value: `s`
 --&gt; src/main.rs:5:12
  |
2 |     let s = &quot;Hello World&quot;.to_string();
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     let _ = SelfReference {
4 |         a: s,
  |            - value moved here
5 |         b: &amp;s
  |            ^^ value borrowed here after move</code></pre>
<p>è¿™æ˜¯å› ä¸º <code>s</code> å·²ç»å‘ç”Ÿäº† <code>move</code>ï¼Œå› æ­¤ <code>b</code> å°±ä¸èƒ½å€Ÿç”¨å·²ç» <code>move</code> äº†çš„ <code>s</code>ã€‚</p>
<p>ä¸ºäº†åˆ›å»ºè‡ªå¼•ç”¨ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨è£¸æŒ‡é’ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(&amp;mut self) {
        let ptr_to_a = &amp;self.a as *const _;
        self.b = ptr_to_a;
    }
    
    fn get_a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }
    
    fn get_b(&amp;self) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>ç¼–è¯‘è¿è¡Œï¼Œç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }</code></pre>
<p>æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬äº¤æ¢ <code>sr_1</code> å’Œ <code>sr_2</code> çš„å†…å­˜ä½ç½®çš„æ•°æ®ï¼Œå³ <code>sr_1</code> å’Œ <code>sr_2</code> äº’ç›¸ <code>move</code> ç»™å¯¹æ–¹ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
    
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    println!(&quot;\nAfter swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	 a: String,
</span><span class="boring">	 b: *const String
</span><span class="boring">}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   } 
</span><span class="boring">   fn init(&amp;mut self) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       self.b = ptr_to_a;
</span><span class="boring">   }   
</span><span class="boring">   fn get_a(&amp;self) -&gt; &amp;str {
</span><span class="boring">       &amp;self.a
</span><span class="boring">   }    
</span><span class="boring">   fn get_b(&amp;self) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>ç¼–è¯‘è¿è¡Œï¼Œç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<p>å¯ä»¥çœ‹å‡ºï¼Œåœ¨äº¤æ¢ <code>sr_1</code> å’Œ <code>sr_2</code>  åï¼Œå­—æ®µ <code>a</code> çš„æ•°æ®ä¹Ÿå‘ç”Ÿäº†äº¤æ¢ï¼Œä½†æ˜¯å­—æ®µ <code>b</code> çš„æ•°æ®æ²¡æœ‰æ”¹å˜ï¼Œä»ç„¶æŒ‡å‘ä¹‹å‰çš„ä½ç½®ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š</p>
<p><img src="async-await/../imgs/swap_problem.jpg" alt="swap problem" /></p>
<p>è¿™æ„å‘³ç€ï¼Œ<code>sr</code>ï¼ˆ<code>sr_1</code>ã€<code>sr_2</code>ï¼‰å°†ä¸å†æ˜¯è‡ªå¼•ç”¨ç»“æ„ä½“ï¼Œå¹¶ä¿å­˜äº†ä¸€ä¸ªæŒ‡å‘å…¶ä»–å¯¹è±¡çš„è£¸æŒ‡é’ˆã€‚å› æ­¤ï¼Œ<code>sr</code> çš„å­—æ®µ <code>b</code> çš„ç”Ÿå‘½å‘¨æœŸå°†ä¸å†å’Œå…¶ç»“æ„ä½“æœ¬èº«ç›¸å…³è”ï¼Œæˆ‘ä»¬å°†éš¾ä»¥ä¿è¯ <code>sr.b</code> æŒ‡é’ˆä¸ä¼šå˜æˆæ‚¬å‚æŒ‡é’ˆã€‚</p>
<p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œç”±äºä½¿ç”¨ <code>swap</code> å‡½æ•°å¯¼è‡´å‡ºç°äº†æˆ‘ä»¬ä¸æƒ³è¦çš„ç»“æœï¼Œåœ¨åç»­çš„ä»£ç ä¸­å¯¹ <code>sr</code> çš„ä½¿ç”¨å¾ˆå¯èƒ½ä¼šå‡ºç°æ®µé”™è¯¯ã€UB ç­‰å…¶ä»–ç±»å‹çš„é”™è¯¯ã€‚</p>
<h2 id="lets-pin-it"><a class="header" href="#lets-pin-it">Let's pin it!</a></h2>
<p>Rust æ˜¯ä¸€é—¨æä¸ºæ³¨é‡å†…å­˜å®‰å…¨çš„è¯­è¨€ï¼Œä¸ºäº†èƒ½å¤Ÿå®‰å…¨åœ°ä½¿ç”¨è‡ªå¼•ç”¨ç»“æ„ï¼ŒRust å‘æ˜äº† <code>Pin</code>ã€‚</p>
<h3 id="pin-1"><a class="header" href="#pin-1">Pin</a></h3>
<p><code>Pin</code> ä½äº <code>std</code> åº“çš„ <code>pin</code> æ¨¡å—ä¸­ï¼Œæºä»£ç å®šä¹‰å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[lang = &quot;pin&quot;]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}</code></pre>
<p><code>Pin</code> å®ç°äº† <code>Deref</code> å’Œ <code>DerefMut</code> <code>trait</code>ï¼Œå› æ­¤ <code>Pin</code> æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆã€‚å¹¶ä¸” <code>Pin</code> çš„å†…éƒ¨åŒ…è£¹äº†å¦ä¸€ä¸ªæŒ‡é’ˆ <code>P</code>ï¼Œå› æ­¤æˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨ <code>Pin&lt;P&lt;T&gt;&gt;</code> çš„æ–¹å¼æ¥è¡¨ç¤ºä¸€ä¸ª <code>Pin</code> ç»“æ„ï¼ˆ<code>T</code> æ˜¯æŒ‡é’ˆ <code>P</code> æŒ‡å‘çš„ç±»å‹ï¼‰ã€‚</p>
<p>æ—¢ç„¶æœ‰ <code>Pin</code>ï¼Œé‚£ä¹ˆè‡ªç„¶å°±æœ‰ <code>Unpin</code>ï¼Œé‚£ä¹ˆ <code>Unpin</code> æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ<code>Unpin</code> æ˜¯ä¸€ä¸ª <code>auto trait</code>ï¼Œç¼–è¯‘å™¨ä¼šé»˜è®¤ä¸ºæ‰€æœ‰çš„ç±»å‹å®ç° <code>Unpin</code>ï¼Œé™¤éè¿™äº›ç±»å‹å®ç°äº† <code>!Unpin</code>ã€‚</p>
<p>è¦æƒ³è·å– <code>Pin&lt;P&lt;T&gt;&gt;</code> ä¸­ <code>T</code> çš„å¯å˜å¼•ç”¨ <code>&amp;mut T</code>ï¼Œå¯ä»¥ä½¿ç”¨ <code>Pin</code> æä¾›çš„ <code>get_mut</code> æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯ <code>Pin</code> æä¾›çš„ <code>api</code> ä¸­<strong>å”¯ä¸€</strong>å¯ä»¥<strong>å®‰å…¨åœ°</strong>è·å– <code>&amp;mut T</code> çš„æ–¹æ³•ï¼Œå…¶å‡½æ•°ç­¾åå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">pub fn get_mut(self) -&gt; &amp;'a mut T
where
    T: Unpin,</code></pre>
<p>å‘ç°äº†å—ï¼Ÿè¦æƒ³å®‰å…¨åœ°æ‹¿åˆ° <code>&amp;mut T</code>ï¼Œ<code>T</code> å°±å¿…é¡»å®ç° <code>Unpin</code>ã€‚å¦‚æœ <code>T</code> å®ç°äº† <code>!Unpin</code>ï¼Œé‚£ä¹ˆå°±ä¸å¯èƒ½å®‰å…¨åœ°æ‹¿åˆ° <code>T</code> çš„å¯å˜å¼•ç”¨ï¼Œæˆ‘ä»¬è‡ªç„¶ä¹Ÿå°±æ— æ³•ä½¿ç”¨ <code>std::mem::swap(x: &amp;mut T, y: &amp;mut T)</code> ç­‰ç±»ä¼¼çš„å‡½æ•° <code>move</code> <code>T</code>ï¼Œå°±ä¸ä¼šå‘ç”Ÿå‰æ–‡çš„ä¾‹å­ä¸­å‡ºç°çš„æœªå®šä¹‰è¡Œä¸ºã€‚</p>
<p>å› æ­¤ï¼Œ<code>Pin&lt;P&lt;T&gt;&gt;</code> åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿä¿è¯ï¼šå¦‚æœ <code>T</code> å®ç°äº† <code>!Unpin</code>ï¼Œé‚£ä¹ˆå°±ä¸å¯èƒ½åœ¨ Safe Rust ä¸­è·å– <code>T</code> çš„å¯å˜å¼•ç”¨ã€‚ç›¸åï¼Œå¦‚æœ <code>T</code> å®ç°äº† <code>Unpin</code>ï¼Œé‚£ä¹ˆ <code>Pin</code> å°±ä»…ä»…æ˜¯å¯¹ <code>P&lt;T&gt;</code> çš„ä¸€å±‚åŒ…è£…ï¼Œæˆ‘ä¹ˆå¯ä»¥éšæ„åœ°æ‹¿åˆ° <code>&amp;mut T</code>ã€‚</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¼šä½¿ç”¨ <code>Pin</code> è§£å†³ä¸Šé¢çš„é‚£ä¸ªä¾‹å­ä¸­å‡ºç°çš„é—®é¢˜ã€‚</p>
<h3 id="pin-to-stack"><a class="header" href="#pin-to-stack">Pin to stack</a></h3>
<p><code>Pin</code> åˆ°æ ˆä¸Šæ˜¯æŒ‡æˆ‘ä»¬æƒ³è¦ <code>Pin</code> ä½çš„å€¼åœ¨æ ˆä¸Šï¼Œä½¿ç”¨ <code>Pin::new_unchecked</code> å‡½æ•°æŠŠ <code>&amp;mut T</code> åŒ…è£…æˆ <code>Pin&lt;&amp;mut T&gt;</code> å³å¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1 = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2 = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let ptr_to_a = &amp;self.a as *const _;
        unsafe {
            self.get_unchecked_mut().b = ptr_to_a;
        }
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>æ­¤æ—¶ä»£ç å°†ä¸ä¼šé€šè¿‡ç¼–è¯‘ï¼š</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:25
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:41
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>è¿™è¯´æ˜å½“æˆ‘ä»¬æŠŠ <code>&amp;mut SelfReference</code> <code>Pin</code> åˆ°æ ˆä¸Šä¹‹åï¼Œæ— æ³•é€šè¿‡ <code>get_mut</code> æ–¹æ³•æ‹¿åˆ° <code>&amp;mut SelfReference</code>ï¼Œé‚£ä¹ˆè‡ªç„¶å°±æ— æ³•ä½¿ç”¨ <code>swap</code> å‡½æ•°ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µå°±ä¿è¯äº†ä¸ä¼šå‡ºç°å†…å­˜å®‰å…¨é—®é¢˜ã€‚</p>
<p><code>Pin::new_unchecked</code> æ˜¯ä¸€ä¸ª <code>unsafe</code> å‡½æ•°ï¼Œè¿™æ˜¯å› ä¸º<strong>éœ€è¦ä½¿ç”¨è€…è‡ªå·±éµå®ˆçº¦å®š</strong>åªä½¿ç”¨ <code>Pin</code> æä¾›çš„ <code>api</code> æ¥è·å–å¹¶ä½¿ç”¨å¯å˜å¼•ç”¨ã€‚</p>
<p>å‡å¦‚ä½¿ç”¨è€…æå‰ <code>drop</code> æ‰ <code>Pin</code>ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥è·å– <code>T</code> çš„å¯å˜å¼•ç”¨ï¼Œä»ç„¶ä¼šå¯¼è‡´å†…å­˜å®‰å…¨é—®é¢˜ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1_pin.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2_pin.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
    
    drop(sr_1_pin);
    drop(sr_2_pin);
    

    println!(&quot;\nAfter swap:&quot;);
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    
    let sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    let sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
}
<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	a: String,
</span><span class="boring">	b: *const String
</span><span class="boring">}
</span><span class="boring">impl !Unpin for SelfReference {}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   }    
</span><span class="boring">   fn init(self: Pin&lt;&amp;mut Self&gt;) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       unsafe {
</span><span class="boring">           self.get_unchecked_mut().b = ptr_to_a;
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       &amp;self.get_ref().a
</span><span class="boring">   }   
</span><span class="boring">   fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}    </span></code></pre></pre>
<p>ç¼–è¯‘è¿è¡Œï¼Œå°†ä¼šå‡ºç°å’Œä¹‹å‰çš„ä¾‹å­ä¸­ä¸€æ ·çš„é—®é¢˜ï¼š</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<h3 id="pin-to-heap"><a class="header" href="#pin-to-heap">Pin to heap</a></h3>
<p><code>Pin</code> åˆ°å †ä¸Šæ˜¯æŒ‡æŠŠæˆ‘ä»¬æƒ³è¦ <code>Pin</code> ä½çš„å€¼è£…ç®±åˆ°å †ä¸Šé¢ï¼Œä½¿ç”¨<code>Box::pin</code> å‡½æ•°å³å¯æŠŠ <code>T</code> åŒ…è£…æˆ <code>Pin&lt;Box&lt;T&gt;&gt;</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let sr = Self {
            a: msg.to_string(),
            b: std::ptr::null()
        };
        let mut boxed = Box::pin(sr);
        let ptr_to_a = &amp;boxed.a as *const _;
        unsafe {
            boxed.as_mut().get_unchecked_mut().b = ptr_to_a;
        }
        
        boxed
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>æ­¤æ—¶ä»£ç å°†ä¸ä¼šé€šè¿‡ç¼–è¯‘ï¼š</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:34
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                  ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:59
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                                           ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p><code>Pin</code> åˆ°å †ä¸Šçš„ä¼˜ç‚¹æ˜¯ä¸éœ€è¦ä½¿ç”¨è€…ç¼–å†™ <code>unsafe</code> å‡½æ•°æ¥æ„é€  <code>Pin</code>ï¼Œä¹Ÿä¸éœ€è¦ä½¿ç”¨è€…è‡ªå·±éµå®ˆçº¦å®šåªä½¿ç”¨ <code>Pin</code> æä¾›çš„ <code>api</code> æ¥è·å–å¯å˜å¼•ç”¨ï¼Œå› ä¸º <code>Pin</code> åˆ°å †ä¸Šåï¼Œç”¨æˆ·åªèƒ½ä½¿ç”¨ <code>Pin&lt;Box&lt;T&gt;&gt;</code>ï¼›ç¼ºç‚¹æ˜¯ <code>Pin</code> åˆ°å †ä¸Šä¼šæœ‰é¢å¤–çš„æ€§èƒ½å¼€é”€ã€‚</p>
<h2 id="pin-and-async"><a class="header" href="#pin-and-async">Pin and async</a></h2>
<p>åœ¨å‰æ–‡ä¸­æˆ‘ä»¬ç»™å‡ºäº† <code>Future</code> å’Œ <code>Generator</code> çš„å®šä¹‰ï¼š</p>
<pre><code class="language-rust noplayground">pub trait Future {
    type Output;	
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}</code></pre>
<p>è¿˜æœ‰å°† <code>Generator</code> è½¬åŒ–ä¸º <code>Future</code> çš„å‡½æ•°ï¼š</p>
<pre><code class="language-rust noplayground">pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
    where T: Generator&lt;ResumeTy, Yield = ()&gt;
{
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
   
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}</code></pre>
<p>å¯ä»¥çœ‹åˆ°è¦è°ƒç”¨ <code>Future</code> çš„ <code>Poll</code> æ–¹æ³•å’Œ <code>Generator</code> çš„ <code>resume</code> æ–¹æ³•å¿…é¡»ä½¿ç”¨ <code>Pin&lt;&amp;mut Self&gt;</code> æ‰è¡Œã€‚å¹¶ä¸”åœ¨ <code>from_generator</code> å‡½æ•°ä¸­ä¸º <code>GenFuture</code> å®ç°äº† <code>!Unpin</code>ã€‚</p>
<p>ç»è¿‡å‰é¢çš„å­¦ä¹ ï¼Œæˆ‘ä»¬çŸ¥é“ä¸º <code>T</code> å®ç°äº† <code>!Unpin</code> åï¼Œå°±æ— æ³•åœ¨ Safe Rust ä¸­è·å– <code>T</code> çš„å¯å˜å¼•ç”¨ï¼Œè€Œ Rust ä¼šä¸»åŠ¨ä¸º <code>Future</code> å®ç° <code>!Unpin</code>ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆ Rust éœ€è¦ <code>Pin</code> ä½ <code>Future</code> å‘¢ï¼Ÿ</p>
<p>å‡è®¾æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªç”Ÿæˆå™¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

fn main(){
    let _gen = || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
}</code></pre></pre>
<p>ç¼–è¯‘åå°†ä¼šå‘ç”ŸæŠ¥é”™ï¼š</p>
<pre><code class="language-rust noplayground">error[E0626]: borrow may still be in use when generator yields
 --&gt; src/main.rs:6:26
  |
6 |         let borrowed_s = &amp;s;
  |                          ^^
7 |         
8 |         yield borrowed_s.len();
  |         ---------------------- possible yield occurs here
</code></pre>
<p>ç¼–è¯‘å™¨æç¤ºæˆ‘ä»¬ç”Ÿæˆå™¨ä¸­å­˜åœ¨è·¨ <code>yield</code> å€Ÿç”¨ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆç¼–è¯‘å™¨ä¸å…è®¸è·¨ <code>yield</code> å€Ÿç”¨å‘¢ï¼Ÿ</p>
<p>æƒ³è¦çŸ¥é“åŸå› ï¼Œæˆ‘ä»¬è¿˜è¦ç»§ç»­æ·±å…¥åº•å±‚ï¼Œä¸Šè¿°çš„ç”Ÿæˆå™¨ä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªçŠ¶æ€æœºï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = Gen::new();
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}


impl&lt;R&gt; Generator&lt;R&gt; for Gen {
    type Yield = usize;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        let mut_gen = self.get_mut();
        match mut_gen {
            Gen::Enter =&gt; {
                let s = &quot;Hello World&quot;.to_string();
                let borrowed_s = &amp;s;
                let len = borrowed_s.len();
                
                *mut_gen = Gen::Yielded {
                    s,
                    borrowed_s: std::ptr::null()
                };
                if let Gen::Yielded { s, borrowed_s } = mut_gen {
                    *borrowed_s = s as *const _;
                }
                
                GeneratorState::Yielded(len)
            }
            Gen::Yielded{ borrowed_s, .. } =&gt; {
                let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
                println!(&quot;{}&quot;, borrowed_s);
                *mut_gen = Gen::Exit;
                
                GeneratorState::Complete(())
            }
            Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
        }
    }
}

impl Gen {
    fn new() -&gt; Self {
        Self::Enter
    }
}</code></pre></pre>
<p>ç¼–è¯‘ä¸Šè¿°ä»£ç ï¼Œç»“æœä¼¼ä¹å°±æ˜¯æˆ‘ä»¬æ‰€æœŸå¾…çš„ï¼š</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<p>ä»ä¸Šè¿°çš„ä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼Œ<strong>ç”Ÿæˆçš„çŠ¶æ€æœºä¸­å­˜åœ¨è‡ªå¼•ç”¨ç»“æ„</strong>ã€‚å› æ­¤å¦‚æœç”Ÿæˆå™¨ä¸­å­˜åœ¨è·¨ <code>yield</code> ç‚¹å€Ÿç”¨ï¼Œé‚£ä¹ˆå°±å¯èƒ½äº§ç”Ÿå†…å­˜å®‰å…¨é—®é¢˜ï¼Œç¼–è¯‘å™¨å¹²è„†å°±ç¦æ­¢å­˜åœ¨è·¨ <code>yield</code> ç‚¹å€Ÿç”¨çš„ç”Ÿæˆå™¨é€šè¿‡ç¼–è¯‘ã€‚</p>
<p>ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ <code>swap</code> å‡½æ•° <code>move</code> ç”Ÿæˆå™¨å°±å¯èƒ½å‘ç”Ÿå¼‚å¸¸ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(&amp;mut gen_1, &amp;mut gen_2);
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
}
<span class="boring">enum Gen {
</span><span class="boring">   Enter,
</span><span class="boring">   Yielded{
</span><span class="boring">       s: String,
</span><span class="boring">       borrowed_s: *const String
</span><span class="boring">   },
</span><span class="boring">   Exit
</span><span class="boring">}
</span><span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = self.get_mut();
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>ç¼–è¯‘è¿è¡Œå°†ä¼šå‘ç”Ÿæ®µé”™è¯¯ï¼š</p>
<pre><code class="language-rust noplayground">/playground/tools/entrypoint.sh: line 11:    12 Segmentation fault
Yielded: 11
Yielded: 11
Hello World
Complete: ()</code></pre>
<p>ä¸ºäº†é˜²æ­¢ <code>move</code> æ‰ç”Ÿæˆå™¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸º <code>Gen</code> å®ç° <code>!Unpin</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    let mut boxed_pin_1 = Box::pin(gen_1);
    let mut boxed_pin_2 = Box::pin(gen_2);
    
    match boxed_pin_1.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match boxed_pin_2.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}

impl !Unpin for Gen {}

<span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = unsafe { self.get_unchecked_mut() };
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>ç¼–è¯‘ä¿®æ”¹åçš„ä»£ç å°†ä¼šç›´æ¥æŠ¥é”™ï¼š</p>
<pre><code class="language-rust noplayground">error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:41
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:73
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>é€šè¿‡ä¸ºç”Ÿæˆå™¨å®ç° <code>!Unpin</code>ï¼Œæˆ‘ä»¬æœ‰æ•ˆçš„é˜²æ­¢äº†å¯èƒ½ä¼šå‡ºç°çš„å†…å­˜å®‰å…¨é—®é¢˜ã€‚</p>
<p>ä½†æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•ä¸ºä½¿ç”¨é—­åŒ…ç¼–å†™çš„ç”Ÿæˆå™¨å®ç° <code>!Unpin</code>ï¼Œé‚£ä¹ˆæ€ä¹ˆè®©æˆ‘ä»¬çš„åˆç‰ˆä»£ç ç¼–è¯‘é€šè¿‡å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨ <code>static</code> å…³é”®å­—æ ‡è®°ç”Ÿæˆå™¨ï¼Œè¿™å°±ç›¸å½“äºä¸ºæˆ‘ä»¬çš„ç”Ÿæˆå™¨å®ç°äº† <code>!Unpin</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};


fn main(){
    let gen = static || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
    
    let mut boxed_pin_gen = Box::pin(gen);
    
    loop {
        match boxed_pin_gen.as_mut().resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}</code></pre></pre>
<p>ç¼–è¯‘è¿è¡Œï¼Œä¸€åˆ‡æ­£å¸¸ï¼š</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<h3 id="å°æ€»ç»“"><a class="header" href="#å°æ€»ç»“">å°æ€»ç»“</a></h3>
<p><code>async</code> åˆ›å»ºçš„ <code>Future</code> åœ¨ç¼–è¯‘åä¼šç”Ÿæˆä¸€ä¸ªçŠ¶æ€æœºï¼Œå¦‚æœ <code>async</code> ä»£ç ä¸­å­˜åœ¨è·¨ <code>await</code> å€Ÿç”¨ï¼Œé‚£ä¹ˆå¯¹åº”çš„åº•å±‚ç”Ÿæˆå™¨ä¸­ä¹Ÿä¼šå­˜åœ¨è·¨ <code>yield</code> ç‚¹å€Ÿç”¨ï¼Œæœ€ç»ˆç”Ÿæˆçš„çŠ¶æ€æœºä¸­å°±ä¼šå­˜åœ¨è‡ªå¼•ç”¨ç»“æ„ï¼Œä¸ºäº†é¿å…å¯èƒ½å‘ç”Ÿçš„å†…å­˜å®‰å…¨é—®é¢˜ï¼ŒRust è‡ªåŠ¨ä¸º <code>Future</code> å®ç°äº† <code>!Unpin</code>ï¼Œå¹¶ä¸”åªèƒ½ä½¿ç”¨ <code>Pin&lt;&amp;mut Self&gt;</code> æ¥è°ƒç”¨ <code>Future</code> çš„ <code>poll</code> æ–¹æ³•å’Œ <code>Generator</code> çš„ <code>resume</code> æ–¹æ³•ï¼Œä»è€Œé¿å…äº†ä½¿ç”¨è€…åœ¨ Safe Rust ä¸­è·å– <code>Future</code> æˆ– <code>Generator</code> çš„å¯å˜å¼•ç”¨ï¼Œæœ€ç»ˆé¿å…äº†ä½¿ç”¨è€…ä½¿ç”¨ <code>swap</code> ä¹‹ç±»çš„å‡½æ•° <code>move</code> æ‰ <code>Future</code> æˆ– <code>Generator</code> è€Œé€ æˆçš„å†…å­˜å®‰å…¨é—®é¢˜ã€‚ </p>
<h2 id="pin-æ€»ç»“"><a class="header" href="#pin-æ€»ç»“">Pin æ€»ç»“</a></h2>
<p>å®˜æ–¹çš„ <code>Async Book</code> ä¸Šç»™å‡ºäº†å…³äº <code>Pin</code> çš„é»„é‡‘å…«æ¡ï¼š</p>
<ol>
<li>
<p>å¦‚æœ <code>T: Unpin</code>ï¼ˆé»˜è®¤ä¼šå®ç°ï¼‰ï¼Œé‚£ä¹ˆ <code>Pin&lt;'a, T&gt;</code> å®Œå…¨ç­‰ä»·äº <code>&amp;'a mut T</code>ã€‚æ¢è¨€ä¹‹ï¼š <code>Unpin</code> æ„å‘³ç€è¿™ä¸ªç±»å‹è¢«ç§»èµ°ä¹Ÿæ²¡å…³ç³»ï¼Œå°±ç®—å·²ç»è¢«å›ºå®šäº†ï¼Œæ‰€ä»¥ <code>Pin</code> å¯¹è¿™æ ·çš„ç±»å‹æ¯«æ— å½±å“ã€‚</p>
</li>
<li>
<p>å¦‚æœ <code>T: !Unpin</code>ï¼Œ è·å–å·²ç»è¢«å›ºå®šçš„ <code>T</code> ç±»å‹ç¤ºä¾‹çš„ <code>&amp;mut T</code>éœ€è¦ <code>unsafe</code>ã€‚</p>
</li>
<li>
<p>æ ‡å‡†åº“ä¸­çš„å¤§éƒ¨åˆ†ç±»å‹å®ç° <code>Unpin</code>ï¼Œåœ¨ Rust ä¸­é‡åˆ°çš„å¤šæ•°æ™®é€šç±»å‹ä¹Ÿæ˜¯ä¸€æ ·ã€‚ä½†æ˜¯ï¼Œ <code>async/await</code> ç”Ÿæˆçš„ <code>Future</code> æ˜¯ä¸ªä¾‹å¤–ã€‚</p>
</li>
<li>
<p>ä½ å¯ä»¥åœ¨ <code>nightly</code> é€šè¿‡ç‰¹æ€§æ ‡è®°æ¥ç»™ç±»å‹æ·»åŠ  <code>!Unpin</code> çº¦æŸï¼Œæˆ–è€…åœ¨ <code>stable</code> ç»™ä½ çš„ç±»å‹åŠ  <code>std::marker::PhatomPinned</code> å­—æ®µã€‚</p>
</li>
<li>
<p>ä½ å¯ä»¥å°†æ•°æ®å›ºå®šåˆ°æ ˆä¸Šæˆ–å †ä¸Šã€‚</p>
</li>
<li>
<p>å›ºå®š <code>!Unpin</code> å¯¹è±¡åˆ°æ ˆä¸Šéœ€è¦ <code>unsafe</code></p>
</li>
<li>
<p>å›ºå®š <code>!Unpin</code> å¯¹è±¡åˆ°å †ä¸Šä¸éœ€è¦<code> unsafe</code>ï¼Œ<code>Box::pin</code>å¯ä»¥å¿«é€Ÿå®Œæˆè¿™ç§å›ºå®šã€‚</p>
</li>
<li>
<p>å¯¹äº <code>T: !Unpin</code> çš„è¢«å›ºå®šæ•°æ®ï¼Œä½ å¿…é¡»ç»´æŠ¤å¥½æ•°æ®å†…å­˜ä¸ä¼šæ— æ•ˆçš„çº¦å®šï¼Œæˆ–è€…å«å›ºå®šæ—¶èµ·ç›´åˆ°é‡Šæ”¾ã€‚è¿™æ˜¯ <code>Pin</code> çº¦å®šä¸­çš„é‡è¦éƒ¨åˆ†ã€‚</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-æ¨¡å‹"><a class="header" href="#io-æ¨¡å‹">IO æ¨¡å‹</a></h1>
<h2 id="io-è®¿é—®"><a class="header" href="#io-è®¿é—®">IO è®¿é—®</a></h2>
<p>å¯¹äºä¸€æ¬¡ IO è®¿é—®ï¼ˆä¾‹å¦‚ <code>read</code> æ“ä½œï¼‰ï¼Œé€šå¸¸æœ‰ä¸¤ä¸ªä¸åŒçš„é˜¶æ®µï¼š</p>
<ol>
<li>ç­‰å¾…æ•°æ®å‡†å¤‡ (Waiting for the data to be ready)</li>
<li>å°†æ•°æ®ä»å†…æ ¸æ‹·è´åˆ°è¿›ç¨‹ä¸­ (Copying the data from the kernel to the process)</li>
</ol>
<p>ä¾‹å¦‚åœ¨ä¸€ä¸ª <code>socket</code> ä¸Šè¯»å–æ•°æ®ï¼Œé¦–å…ˆéœ€è¦ç­‰å¾…æ•°æ®åˆ°è¾¾ç½‘ç»œï¼Œå½“æ•°æ®åˆ°è¾¾æ—¶å°†æ•°æ®æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒºä¸­ï¼Œå†å°†æ•°æ®ä»å†…æ ¸ç¼“å†²åŒºä¸­æ‹·è´åˆ°ç”¨æˆ·è¿›ç¨‹çš„ç¼“å†²åŒºä¸­ã€‚</p>
<p>æ­£æ˜¯ç”±äº IO è®¿é—®ç»å†çš„ä¸¤ä¸ªé˜¶æ®µï¼ŒLinux ç³»ç»Ÿäº§ç”Ÿäº†ä¸‹é¢äº”ç§ IO æ¨¡å‹ï¼š</p>
<ul>
<li>é˜»å¡ IOï¼ˆblocking IOï¼‰</li>
<li>éé˜»å¡ IOï¼ˆnonblocking IOï¼‰</li>
<li>IO å¤šè·¯å¤ç”¨ï¼ˆIO multiplexingï¼‰</li>
<li>ä¿¡å·é©±åŠ¨ IOï¼ˆsignal driven IOï¼‰</li>
<li>å¼‚æ­¥ IOï¼ˆasynchronous IOï¼‰</li>
</ul>
<h2 id="io-æ¨¡å‹ä¸-future"><a class="header" href="#io-æ¨¡å‹ä¸-future">IO æ¨¡å‹ä¸ Future</a></h2>
<p>åœ¨ä»‹ç» <code>Future trait</code> çš„é‚£ä¸€ç« ä¸­æˆ‘ä»¬æåˆ°ï¼šå¦‚æœä¸€ä¸ª <code>Future</code> æ²¡æœ‰è®¡ç®—å®Œæˆï¼Œä¾‹å¦‚æƒ³è¦ç­‰å¾…ä¸€ä¸ª IO äº‹ä»¶å‘ç”Ÿï¼Œé‚£ä¹ˆé€šå¸¸ä¼šæ³¨å†Œ <code>waker</code> åˆ°ä¸€ä¸ªâ€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€ä¸­ï¼Œå½“è¿™ä¸ª IO äº‹ä»¶å°±ç»ªæ—¶ï¼Œâ€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€å°±ä¼šé€šè¿‡ <code>waker</code> å”¤é†’ä¹‹å‰çš„ <code>Future</code> ç»§ç»­æ‰§è¡Œã€‚</p>
<p>é‚£ä¹ˆâ€œäº‹ä»¶é€šçŸ¥ç³»ç»Ÿâ€è¦æ€ä¹ˆçŸ¥é“ <code>Future</code> æƒ³è¦ç­‰å¾…çš„ IO äº‹ä»¶ä»€ä¹ˆæ—¶å€™å°±ç»ªå‘¢ï¼Ÿè¿™ä¸ IO æ¨¡å‹æœ‰å…³ï¼Œå› æ­¤åœ¨æœ¬ç« ä¸­æˆ‘ä»¬å°†ä¼šä»‹ç»å‡ ç§ä¸åŒçš„ IO æ¨¡å‹ä»¥åŠå®ƒä»¬çš„ç‰¹ç‚¹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é˜»å¡-io"><a class="header" href="#é˜»å¡-io">é˜»å¡ IO</a></h1>
<p>åœ¨ Linux ä¸­ï¼Œé˜»å¡ IO æ˜¯æœ€æµè¡Œçš„ IO æ¨¡å‹ï¼Œé»˜è®¤æƒ…å†µä¸‹æ‰€æœ‰çš„ <code>socket</code> éƒ½æ˜¯é˜»å¡çš„ï¼ˆblockingï¼‰ã€‚å¯¹äºé˜»å¡ IO æ¥è¯´ï¼Œè¯»æ“ä½œçš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Blocking-IO.png" alt="Blocking IO Model" /></p>
<p>å½“ç”¨æˆ·è¿›ç¨‹å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨åï¼Œå†…æ ¸å¼€å§‹ IO çš„ç¬¬ä¸€ä¸ªé˜¶æ®µï¼šç­‰å¾…æ•°æ®å‡†å¤‡å¥½ï¼ŒæŠŠæ•°æ®ä»ç¡¬ä»¶æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒºï¼ˆå¯¹äºç½‘ç»œ IOï¼Œè¦å…ˆç­‰å¾…æ•°æ®æŠ¥æ–‡åˆ°è¾¾ï¼‰ã€‚å½“æ•°æ®å‡†å¤‡å¥½åï¼Œå¼€å§‹ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µï¼šæŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°ç”¨æˆ·è¿›ç¨‹çš„ç¼“å†²åŒºã€‚å½“ä¸¤ä¸ª IO é˜¶æ®µéƒ½å®Œæˆåï¼Œ<code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨è¿”å›ï¼Œä¹Ÿå°±æ˜¯è¯´ç”¨æˆ·è¿›ç¨‹ä»å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨ç›´åˆ°è¿”å›éƒ½æ˜¯å¤„äºé˜»å¡çŠ¶æ€ã€‚</p>
<p>å› æ­¤ï¼Œ<strong>å¯¹äºé˜»å¡ IO æ¥è¯´ï¼Œç”¨æˆ·è¿›ç¨‹åœ¨ IO çš„ä¸¤ä¸ªé˜¶æ®µéƒ½è¢« <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨é˜»å¡äº†</strong>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="éé˜»å¡-io"><a class="header" href="#éé˜»å¡-io">éé˜»å¡ IO</a></h1>
<p>åœ¨ Linux ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ª <code>socket</code> è®¾ç½®ä¸ºéé˜»å¡ï¼ˆnonblockingï¼‰ã€‚å¯¹äºéé˜»å¡ IO æ¥è¯´ï¼Œè¯»æ“ä½œçš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Nonblocking-IO.png" alt="Nonblocking IO Model" /></p>
<p>å½“ç”¨æˆ·è¿›ç¨‹å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨åï¼Œå¦‚æœæ•°æ®æ²¡æœ‰å‡†å¤‡å¥½ï¼Œ<code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨ä¼šç«‹å³è¿”å› <code>EWOULDBLOCK</code> é”™è¯¯ã€‚ç”¨æˆ·è¿›ç¨‹å¯ä»¥é€šè¿‡ä¸€ä¸ªæ­»å¾ªç¯ä¸æ–­å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨ï¼Œä¸€æ—¦æ•°æ®å‡†å¤‡å¥½äº†ï¼Œå°±è¿›å…¥ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µï¼šæŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°ç”¨æˆ·ç”¨è¿›ç¨‹çš„ç¼“å†²åŒºï¼Œå½“æ‹·è´å®Œæˆåï¼Œ<code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨æ­£å¸¸è¿”å›ã€‚</p>
<p>å› æ­¤ï¼Œ<strong>å¯¹äº Nonblocking IO æ¥è¯´ï¼Œç”¨æˆ·è¿›ç¨‹éœ€è¦ä¸æ–­è½®è¯¢å†…æ ¸æ•°æ®å‡†å¤‡å¥½äº†æ²¡æœ‰ï¼Œå¹¶ä¸”ç”¨æˆ·è¿›ç¨‹åœ¨ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µä»ç„¶ä¼šè¢« <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨é˜»å¡</strong>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä¿¡å·é©±åŠ¨-io"><a class="header" href="#ä¿¡å·é©±åŠ¨-io">ä¿¡å·é©±åŠ¨ IO</a></h1>
<p>å¯¹äºä¿¡å·é©±åŠ¨ IO æ¥è¯´ï¼Œè¯»æ“ä½œçš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Signal-Driven-IO.png" alt="Signal Driven IO" /></p>
<p>å½“ç”¨æˆ·è¿›ç¨‹å‘èµ· <code>sigaction</code> ç³»ç»Ÿè°ƒç”¨åï¼Œè¿™ä¸ªç³»ç»Ÿè°ƒç”¨ä¼šé©¬ä¸Šè¿”å›ã€‚å†…æ ¸åœ¨å‡†å¤‡å¥½æ•°æ®åä¼šå‘ç”¨æˆ·è¿›ç¨‹å‘é€ <code>SIGIO</code> ä¿¡å·ï¼Œç”¨æˆ·è¿›ç¨‹æ”¶åˆ°ä¿¡å·ä¹‹åä¼šåœ¨ä¿¡å·å¤„ç†ç¨‹åºä¸­å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨å°†æ•°æ®ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°ç”¨æˆ·è¿›ç¨‹ç¼“å†²åŒºä¸­ï¼Œè‡³æ­¤ IO çš„ä¸¤ä¸ªé˜¶æ®µå…¨éƒ¨å®Œæˆã€‚</p>
<p>å› æ­¤ï¼Œ<strong>å¯¹äºä¿¡å·é©±åŠ¨ IO æ¥è¯´ï¼Œç”¨æˆ·è¿›ç¨‹åœ¨ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µè¢« <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨é˜»å¡äº†</strong>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-å¤šè·¯å¤ç”¨"><a class="header" href="#io-å¤šè·¯å¤ç”¨">IO å¤šè·¯å¤ç”¨</a></h1>
<p>IO å¤šè·¯å¤ç”¨æ˜¯æŒ‡é€šè¿‡ä¸€ç§æœºåˆ¶å®ç°åœ¨å•ä¸ªçº¿ç¨‹ä¸­å¯ä»¥ç›‘è§†å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆä¾‹å¦‚ <code>socket</code> æè¿°ç¬¦ï¼‰ï¼Œå½“æ–‡ä»¶æè¿°è¯»/å†™å°±ç»ªæ—¶ï¼Œç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥è·å–å°±ç»ªçš„æ–‡ä»¶å¥æŸ„ã€‚<code>select</code>ã€<code>poll</code>ã€<code>epoll</code> éƒ½æ˜¯ IO å¤šè·¯å¤ç”¨çš„ä¸€ç§å®ç°ã€‚</p>
<p>ä»¥ <code>select</code> ä¸ºä¾‹ï¼Œè¯»æ“ä½œçš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/IO-Multiplexing-Model.png" alt="IO Multiplexing Model" /></p>
<p>å½“ç”¨æˆ·è¿›ç¨‹å‘èµ· <code>select</code> ç³»ç»Ÿè°ƒç”¨åï¼Œç”¨æˆ·è¿›ç¨‹è¢«é˜»å¡ï¼Œè€Œå†…æ ¸ä¼šç›‘æ§ <code>select</code> è´Ÿè´£çš„æ‰€æœ‰æ–‡ä»¶æè¿°ç¬¦ï¼Œå½“ä»»æ„ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦çš„æ•°æ®å‡†å¤‡å¥½æ—¶ï¼Œ<code>select</code> ä¼šè¿”å›å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦ã€‚æ­¤æ—¶ï¼Œç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥å¯¹å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦å‘èµ· <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨ï¼Œå¼€å§‹ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µï¼šå°†æ•°æ®ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°ç”¨æˆ·è¿›ç¨‹çš„ç¼“å†²åŒºï¼Œå½“æ‹·è´ç»“æŸå <code>recvfrom</code> è°ƒç”¨æ­£å¸¸è¿”å›ã€‚ </p>
<p>å› æ­¤ï¼Œ<strong>å¯¹äº IO å¤šè·¯å¤ç”¨æ¥è¯´ï¼Œç”¨æˆ·è¿›ç¨‹åœ¨ IO çš„ä¸¤ä¸ªé˜¶æ®µéƒ½è¢«é˜»å¡äº†ï¼šåœ¨ IO çš„ç¬¬ä¸€ä¸ªé˜¶æ®µè¢« <code>select</code> ç³»ç»Ÿè°ƒç”¨é˜»å¡ï¼Œåœ¨ IO çš„ç¬¬äºŒä¸ªé˜¶æ®µè¢« <code>recvfrom</code> ç³»ç»Ÿè°ƒç”¨é˜»å¡</strong>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¼‚æ­¥-io"><a class="header" href="#å¼‚æ­¥-io">å¼‚æ­¥ IO</a></h1>
<p>å¯¹äºå¼‚æ­¥ IO æ¥è¯´ï¼Œè¯»æ“ä½œçš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Asynchronous-IO.png" alt="Asynchronous IO Model" /></p>
<p>å½“ç”¨æˆ·è¿›ç¨‹å‘èµ·å¼‚æ­¥æ¡†æ¶ <code>AIO</code> æä¾›çš„ <code>aio_read</code> ç³»ç»Ÿè°ƒç”¨åï¼Œè¿™ä¸ªç³»ç»Ÿè°ƒç”¨ä¼šé©¬ä¸Šè¿”å›ã€‚å†…æ ¸ä¼šå‡†å¤‡å¥½æ•°æ®ç„¶åæŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´åˆ°ç”¨æˆ·è¿›ç¨‹ç¼“å†²åŒºï¼Œå½“ IO çš„ä¸¤ä¸ªé˜¶æ®µéƒ½å®Œæˆåï¼Œå†…æ ¸ä¼šå‘é€ä¸€ä¸ªä¿¡å·é€šçŸ¥ç”¨æˆ·è¿›ç¨‹ <code>read</code> æ“ä½œå®Œæˆäº†ã€‚</p>
<p>å› æ­¤ï¼Œ<strong>å¯¹äºå¼‚æ­¥ IO æ¥è¯´ï¼Œç”¨æˆ·è¿›ç¨‹åœ¨ IO çš„ä¸¤ä¸ªé˜¶æ®µéƒ½ä¸ä¼šè¢«é˜»å¡</strong>ã€‚</p>
<h2 id="æ€»ç»“"><a class="header" href="#æ€»ç»“">æ€»ç»“</a></h2>
<p><code>POSIX</code> å¯¹åŒæ­¥ IO å’Œå¼‚æ­¥ IO çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>
<ul>
<li>åŒæ­¥ IO æ“ä½œä¼šå¯¼è‡´å‘èµ·è¯·æ±‚çš„è¿›ç¨‹è¢«é˜»å¡ï¼Œç›´åˆ° IO æ“ä½œå®Œæˆã€‚</li>
<li>å¼‚æ­¥ IO æ“ä½œå¯¼è‡´å‘èµ·è¯·æ±‚çš„è¿›ç¨‹è¢«é˜»å¡ã€‚</li>
</ul>
<p>æ ¹æ® <code>PISIX</code> çš„å®šä¹‰ï¼Œå¯ä»¥æŠŠ IO æ¨¡å‹åˆ†ä¸ºä»¥ä¸‹ä¸¤ç±»ï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/IO-Summary.png" alt="" /></p>
<p>æœ€åï¼Œå„ä¸ª IO æ¨¡å‹çš„æ¯”è¾ƒå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="IO%E6%A8%A1%E5%9E%8B/../imgs/Comparison-IO-Model.png" alt="Comparison IO Model" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll"><a class="header" href="#epoll">Epoll</a></h1>
<p><code>Epoll</code> æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ IO äº‹ä»¶é€šçŸ¥æœºåˆ¶ï¼Œæ˜¯å‰æ–‡æ‰€è¿°çš„åœ¨ Linux ä¸­ IO å¤šè·¯å¤ç”¨çš„ä¸€ç§å®ç°ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šç®€ç•¥ä»‹ç» <code>Epoll</code> çš„åŸç†ï¼Œå¹¶ä½¿ç”¨ <code>Epoll</code> å®ç°ä¸€ä¸ªç®€å•çš„ <code>echo server</code>ã€‚</p>
<p>åœ¨æœ€åä¸€ç« ã€Šå¼‚æ­¥è¿è¡Œæ—¶ã€‹ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿä¼šä½¿ç”¨ <code>Epoll</code> ä½œä¸ºåŸºç¡€æ¥å®ç°ä¸€ä¸ª <code>Reactor</code>ï¼ˆ<code>Reactor</code> çš„æ¦‚å¿µä¼šåœ¨åé¢ä»‹ç»ï¼‰ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-ä»‹ç»"><a class="header" href="#epoll-ä»‹ç»">Epoll ä»‹ç»</a></h1>
<h2 id="epoll-å·¥ä½œæµç¨‹"><a class="header" href="#epoll-å·¥ä½œæµç¨‹">Epoll å·¥ä½œæµç¨‹</a></h2>
<p><code>Epoll</code> çš„å¤§è‡´å·¥ä½œæµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="Epoll/../imgs/epoll.png" alt="" /></p>
<blockquote>
<ol>
<li><code>int epoll_create(int size)</code></li>
</ol>
</blockquote>
<p>å†…æ ¸ä¼šäº§ç”Ÿä¸€ä¸ª <code>Epoll</code> å®ä¾‹æ•°æ®ç»“æ„å¹¶è¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œè¿™ä¸ªç‰¹æ®Šçš„æè¿°ç¬¦æ˜¯ <code>epoll</code> å®ä¾‹çš„å¥æŸ„ã€‚</p>
<p><code>size</code> å‚æ•°åªæ˜¯å‘Šè¯‰å†…æ ¸Â <code>Epoll</code> å¤„ç†çš„äº‹ä»¶çš„å¤§è‡´æ•°ç›®ï¼Œè€Œä¸æ˜¯èƒ½å¤Ÿå¤„ç†çš„äº‹ä»¶çš„æœ€å¤§ä¸ªæ•°ã€‚åœ¨ Linux æœ€æ–°çš„ä¸€äº›å†…æ ¸ç‰ˆæœ¬ä¸­ï¼Œ<code>size</code> å‚æ•°æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚</p>
<br/>
<blockquote>
<ol start="2">
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></li>
</ol>
</blockquote>
<p>å°†è¢«ç›‘å¬çš„æè¿°ç¬¦æ·»åŠ åˆ°çº¢é»‘æ ‘æˆ–ä»çº¢é»‘æ ‘ä¸­åˆ é™¤æˆ–è€…å¯¹ç›‘å¬äº‹ä»¶è¿›è¡Œä¿®æ”¹ã€‚</p>
<p><code>op</code> å‚æ•°ç”¨äºè¯´æ˜æ“ä½œç±»å‹ï¼š</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>ï¼šæ·»åŠ ä¸€ä¸ªéœ€è¦ç›‘è§†çš„æè¿°ç¬¦</li>
<li><code>EPOLL_CTL_DEL</code>ï¼šåˆ é™¤ä¸€ä¸ªæè¿°ç¬¦</li>
<li><code>EPOLL_CTL_MOD</code>ï¼šä¿®æ”¹ä¸€ä¸ªæè¿°ç¬¦</li>
</ul>
<p><code>struct epoll_event</code> ç»“æ„æè¿°ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ <code>fd</code> çš„ <code>epoll</code> è¡Œä¸ºï¼š</p>
<pre><code class="language-c">typedef union epoll_data {
    void *ptr; 				/* æŒ‡å‘ç”¨æˆ·è‡ªå®šä¹‰æ•°æ® */
    int fd; 				/* æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦ */
    uint32_t u32; 			/* 32-bit integer */
    uint64_t u64; 			/* 64-bit integer */
} epoll_data_t;

struct epoll_event {
    uint32_t events; 		/* æè¿°epolläº‹ä»¶ */
    epoll_data_t data; 		/* è§ä¸Šé¢çš„ç»“æ„ä½“ */
};
</code></pre>
<p>å¸¸ç”¨çš„ <code>epoll</code> äº‹ä»¶å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<ul>
<li><code>EPOLLIN</code>ï¼šæè¿°ç¬¦å¤„äºå¯è¯»çŠ¶æ€</li>
<li><code>EPOLLOUT</code>ï¼šæè¿°ç¬¦å¤„äºå¯å†™çŠ¶æ€</li>
<li><code>EPOLLET</code>ï¼šå°† <code>epoll event</code> é€šçŸ¥æ¨¡å¼è®¾ç½®æˆ <code>edge trigger</code></li>
<li><code>EPOLLONESHOT</code>ï¼šç¬¬ä¸€æ¬¡è¿›è¡Œé€šçŸ¥ï¼Œä¹‹åä¸å†ç›‘æµ‹</li>
<li><code>EPOLLHUP</code>ï¼šæœ¬ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶ï¼Œé»˜è®¤ç›‘æµ‹äº‹ä»¶</li>
<li><code>EPOLLRDHUP</code>ï¼šå¯¹ç«¯æè¿°ç¬¦äº§ç”Ÿä¸€ä¸ªæŒ‚æ–­äº‹ä»¶</li>
<li><code>EPOLLPRI</code>ï¼šç”±å¸¦å¤–æ•°æ®è§¦å‘</li>
<li><code>EPOLLERR</code>ï¼šæè¿°ç¬¦äº§ç”Ÿé”™è¯¯æ—¶è§¦å‘ï¼Œé»˜è®¤æ£€æµ‹äº‹ä»¶</li>
</ul>
<br/>
<blockquote>
<ol start="3">
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></li>
</ol>
</blockquote>
<p>é˜»å¡ç­‰å¾…æ³¨å†Œçš„äº‹ä»¶å‘ç”Ÿï¼Œè¿”å›è§¦å‘çš„äº‹ä»¶çš„æ•°ç›®ï¼Œå¹¶å°†è§¦å‘çš„äº‹ä»¶å†™å…¥ <code>events</code> æ•°ç»„ä¸­ã€‚</p>
<p><code>maxevents</code> æ˜¯è¿”å›çš„ <code>event</code> çš„æœ€å¤§æ•°é‡ã€‚<code>events</code> æ•°ç»„çš„é•¿åº¦åº”è¯¥ä¸ <code>maxevents</code> ä¸€è‡´ã€‚<code>timeout</code> æ˜¯ <code>epoll_wait</code> è°ƒç”¨é˜»å¡çš„æ—¶é—´ä¸Šé™ã€‚</p>
<h2 id="epoll-è§¦å‘æœºåˆ¶"><a class="header" href="#epoll-è§¦å‘æœºåˆ¶">Epoll è§¦å‘æœºåˆ¶</a></h2>
<p><code>Epoll</code> ç›‘æ§å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦çš„ IO äº‹ä»¶ï¼Œæ”¯æŒè¾¹ç¼˜è§¦å‘ï¼ˆedge triggerï¼ŒETï¼‰å’Œæ°´å¹³è§¦å‘ï¼ˆlevel triggerï¼ŒLTï¼‰ã€‚</p>
<h3 id="æ°´å¹³è§¦å‘"><a class="header" href="#æ°´å¹³è§¦å‘">æ°´å¹³è§¦å‘</a></h3>
<p>å¯¹äºè¯»æ“ä½œï¼Œåªè¦æ–‡ä»¶æè¿°ç¬¦çš„è¯»ç¼“å†²åŒºä¸ä¸ºç©ºï¼Œè§¦å‘å¯è¯»äº‹ä»¶ã€‚</p>
<p>å¯¹äºå†™æ“ä½œï¼Œåªè¦æ–‡ä»¶æè¿°çš„å†™ç¼“å†²åŒºä¸æ»¡ï¼Œè§¦å‘å¯å†™äº‹ä»¶ã€‚</p>
<h3 id="è¾¹ç¼˜è§¦å‘"><a class="header" href="#è¾¹ç¼˜è§¦å‘">è¾¹ç¼˜è§¦å‘</a></h3>
<p>å½“æ–‡ä»¶æè¿°ç¬¦çš„ç¼“å†²åŒºçŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶è§¦å‘ã€‚</p>
<p>å¯¹äºè¯»æ“ä½œï¼š</p>
<ul>
<li>å½“è¯»ç¼“å†²åŒºæ•°æ®ä¸ºç©ºå˜ä¸ºéç©ºæ—¶ï¼Œè§¦å‘å¯è¯»äº‹ä»¶ã€‚</li>
<li>å½“è¯»ç¼“å†²åŒºæ¥æ”¶åˆ°æ–°æ•°æ®æ—¶ï¼Œå³è¯»ç¼“å†²åŒºå¾…è¯»æ•°æ®å˜å¤šæ—¶ï¼Œè§¦å‘å¯è¯»äº‹ä»¶ã€‚</li>
<li>å½“è¯»ç¼“å†²åŒºæœ‰æ•°æ®å¯è¯»ï¼Œä¸”è¿›ç¨‹å¯¹ç›¸åº”çš„æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œ <code>EPOLL_CTL_MOD</code> ä¿®æ”¹ <code>EPOLLIN</code> äº‹ä»¶æ—¶ï¼Œè§¦å‘å¯è¯»äº‹ä»¶ã€‚</li>
</ul>
<p>å¯¹äºå†™æ“ä½œï¼š</p>
<ul>
<li>å½“å†™ç¼“å†²åŒºç”±ä¸å¯å†™å˜ä¸ºå¯å†™æ—¶ï¼Œè§¦å‘å¯å†™äº‹ä»¶ã€‚</li>
<li>å½“æœ‰æ—§æ•°æ®è¢«å‘é€èµ°ï¼Œå³è¯»ç¼“å†²åŒºä¸­çš„å†…å®¹å˜å°‘çš„æ—¶å€™ï¼Œè§¦å‘å¯å†™äº‹ä»¶ã€‚</li>
<li>å½“å†™ç¼“å†²åŒºæœ‰ç©ºé—´å¯å†™ï¼Œä¸”è¿›ç¨‹å¯¹ç›¸åº”çš„æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œ <code>EPOLL_CTL_MOD</code> ä¿®æ”¹ <code>EPOLLOUT</code> äº‹ä»¶æ—¶ï¼Œè§¦å‘å¯å†™äº‹ä»¶ã€‚</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-server-example"><a class="header" href="#epoll-server-example">Epoll server example</a></h1>
<p>åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šç¼–å†™ä¸€ä¸ªç®€å•çš„ <code>epoll server</code>ï¼Œæ¥çœ‹ä¸€ä¸‹ <code>epoll</code> æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚<a href="https://crates.io/crates/libc">libc crate</a> ä¸­æä¾›äº†ä¸ <code>epoll</code> ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå› æ­¤è¿™ä¸ªå°é¡¹ç›®éœ€è¦æ·»åŠ  <code>libc crate</code> ä¾èµ–ã€‚ </p>
<p>æºä»£ç çš„ä»“åº“åœ°å€ï¼š<a href="https://github.com/night-cruise/rust-epoll-example">rust epoll example</a>ã€‚</p>
<h2 id="epoll-è°ƒç”¨å®"><a class="header" href="#epoll-è°ƒç”¨å®">epoll è°ƒç”¨å®</a></h2>
<p>ä¸ºäº†æ–¹ä¾¿åœ°è°ƒç”¨ <code>epoll</code> ç›¸å…³çš„ <code>api</code>ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™å¦‚ä¸‹æ‰€ç¤ºçš„å®ï¼š</p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! syscall {
    ($fn: ident ( $($arg: expr),* $(,)* ) ) =&gt; {{
        let res = unsafe { libc::$fn($($arg, )*) };
        if res == -1 {
            Err(std::io::Error::last_os_error())
        } else {
            Ok(res)
        }
    }};
}</code></pre>
<p>ä¾‹å¦‚ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥è¿™æ ·è°ƒç”¨ <code>epoll_wait</code>ï¼š</p>
<pre><code class="language-rust noplayground">syscall!(epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000
))</code></pre>
<p>å®å±•å¼€åçš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">{
    let res = unsafe {
        libc::epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000
        )
    };
    if res == -1 {
        Err(std::io::Error::last_os_error())
    } else {
        Ok(res)
}</code></pre>
<h2 id="epoll-æ¨¡å—"><a class="header" href="#epoll-æ¨¡å—">epoll æ¨¡å—</a></h2>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¼šåˆ©ç”¨ <code>epoll</code> æä¾›çš„ <code>api</code> æ¥ç¼–å†™ IO äº‹ä»¶çš„æ³¨å†Œã€ä¿®æ”¹ç­‰åŠŸèƒ½ã€‚æœ¬æ¨¡å—éœ€è¦å¯¼å…¥çš„é¡¹ï¼š</p>
<pre><code class="language-rust noplayground">use std::io;
use std::os::unix::io::RawFd;

use crate::syscall;</code></pre>
<h3 id="åˆ›å»º-epoll-å®ä¾‹"><a class="header" href="#åˆ›å»º-epoll-å®ä¾‹">åˆ›å»º epoll å®ä¾‹</a></h3>
<pre><code class="language-rust noplayground">/// åŒ…è£…epoll_createï¼Œåˆ›å»ºä¸€ä¸ªepollå®ä¾‹
pub fn epoll_create() -&gt; io::Result&lt;RawFd&gt; {
    // åˆ›å»ºä¸€ä¸ªepollå®ä¾‹ï¼Œè¿”å›epollå¯¹è±¡çš„æ–‡ä»¶æè¿°ç¬¦fd
    let fd = syscall!(epoll_create1(0))?;

    // fcntl(fd, libc::F_GETFD) å‡½æ•°è¿”å›ä¸ fd å…³è”çš„ close_on_exec æ ‡å¿—
    // close_on_exec ç”¨äºç¡®å®šåœ¨ç³»ç»Ÿè°ƒç”¨ execve() åæ˜¯å¦éœ€è¦å…³é—­æ–‡ä»¶æè¿°ç¬¦
    if let Ok(flags) = syscall!(fcntl(fd, libc::F_GETFD)) {

        // è®¾ç½®åœ¨ç³»ç»Ÿè°ƒç”¨ execve() åå…³é—­æ–‡ä»¶æè¿°ç¬¦ fd
        let _ = syscall!(fcntl(fd, libc::F_SETFD, flags | libc::FD_CLOEXEC));
    }

    Ok(fd)
}</code></pre>
<h3 id="æ³¨å†Œæ–‡ä»¶æè¿°å¹¶ç›‘å¬äº‹ä»¶"><a class="header" href="#æ³¨å†Œæ–‡ä»¶æè¿°å¹¶ç›‘å¬äº‹ä»¶">æ³¨å†Œæ–‡ä»¶æè¿°å¹¶ç›‘å¬äº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">/// åŒ…è£… epoll_ctlï¼Œæ³¨å†Œæ–‡ä»¶æè¿°ç¬¦å’Œäº‹ä»¶
pub fn add_interest(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    // epoll_fd æ˜¯ epoll å®ä¾‹çš„çš„æ–‡ä»¶æè¿°ç¬¦
    // fd æ˜¯è¦æ³¨å†Œçš„ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦
    // event æ˜¯è¦åœ¨ fd ä¸Šç›‘å¬çš„äº‹ä»¶
    // libc::EPOLL_CTL_ADD è¡¨ç¤ºæ·»åŠ ä¸€ä¸ªéœ€è¦ç›‘è§†çš„æ–‡ä»¶æè¿°ç¬¦
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_ADD, fd, &amp;mut event))?;

    Ok(())
}</code></pre>
<h3 id="ä¿®æ”¹æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦"><a class="header" href="#ä¿®æ”¹æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦">ä¿®æ”¹æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦</a></h3>
<pre><code class="language-rust noplayground">/// åŒ…è£… epoll_ctlï¼Œä¿®æ”¹æ–‡ä»¶æè¿°ç¬¦
pub fn modify_interest(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    // epoll_fd æ˜¯ epoll å®ä¾‹çš„çš„æ–‡ä»¶æè¿°ç¬¦
    // fd æ˜¯è¦ä¿®æ”¹ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦
    // event æ˜¯è¦åœ¨ fd ä¸Šç›‘å¬çš„äº‹ä»¶
    // libc::EPOLL_CTL_MOD è¡¨ç¤ºä¿®æ”¹æ–‡ä»¶æè¿°ç¬¦ fd
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_MOD, fd, &amp;mut event))?;

    Ok(())
}</code></pre>
<h3 id="åˆ é™¤æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦"><a class="header" href="#åˆ é™¤æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦">åˆ é™¤æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦</a></h3>
<pre><code class="language-rust noplayground">/// åŒ…è£… epoll_ctlï¼Œåˆ é™¤æ–‡ä»¶æè¿°ç¬¦
pub fn remove_interest(epoll_fd: RawFd, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // epoll_fd æ˜¯ epoll å®ä¾‹çš„çš„æ–‡ä»¶æè¿°ç¬¦
    // fd æ˜¯è¦åˆ é™¤çš„ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦
    // libc::EPOLL_CTL_DEL è¡¨ç¤ºè¦åˆ é™¤æ–‡ä»¶æè¿°ç¬¦ fd
    syscall!(epoll_ctl(
        epoll_fd,
        libc::EPOLL_CTL_DEL,
        fd,
        std::ptr::null_mut() // å°†ç›‘å¬çš„ event è®¾ç½®ä¸ºç©º
    ))?;

    Ok(())
}</code></pre>
<h3 id="å…³é—­æ–‡ä»¶æè¿°ç¬¦"><a class="header" href="#å…³é—­æ–‡ä»¶æè¿°ç¬¦">å…³é—­æ–‡ä»¶æè¿°ç¬¦</a></h3>
<pre><code class="language-rust noplayground">/// å…³é—­æ–‡ä»¶æè¿°ç¬¦ fd
pub fn close(fd: RawFd) {
    let _ = syscall!(close(fd));
}</code></pre>
<h3 id="åˆ›å»ºä¸€ä¸ªè¯»äº‹ä»¶"><a class="header" href="#åˆ›å»ºä¸€ä¸ªè¯»äº‹ä»¶">åˆ›å»ºä¸€ä¸ªè¯»äº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">const READ_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLIN;

/// åˆ›å»ºä¸€ä¸ªè¯»äº‹ä»¶
pub fn listener_read_event(key: u64) -&gt; libc::epoll_event {
    // key ç”¨äºåŒºåˆ†ä¸åŒçš„æ–‡ä»¶æè¿°ç¬¦
    libc::epoll_event {
        events: READ_FLAGS as u32,
        u64: key,
    }
}</code></pre>
<h3 id="åˆ›å»ºä¸€ä¸ªå†™äº‹ä»¶"><a class="header" href="#åˆ›å»ºä¸€ä¸ªå†™äº‹ä»¶">åˆ›å»ºä¸€ä¸ªå†™äº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">const WRITE_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLOUT;

/// åˆ›å»ºä¸€ä¸ªå†™äº‹ä»¶
pub fn listener_write_event(key: u64) -&gt; libc::epoll_event {
    // key ç”¨äºåŒºåˆ†ä¸åŒçš„æ–‡ä»¶æè¿°ç¬¦
    libc::epoll_event {
        events: WRITE_FLAGS as u32,
        u64: key,
    }
}</code></pre>
<h2 id="http-æ¨¡å—"><a class="header" href="#http-æ¨¡å—">http æ¨¡å—</a></h2>
<p>åœ¨ <code>http</code> æ¨¡å—ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šç¼–å†™å¤„ç† <code>HTTP</code> è¯·æ±‚ç›¸å…³çš„å‡½æ•°ï¼Œéœ€è¦å¯¼å…¥çš„é¡¹ï¼š</p>
<pre><code class="language-rust noplayground">use std::io;
use std::net::TcpStream;
use std::io::{Read, Write};
use std::os::unix::io::{AsRawFd, RawFd};

use crate::epoll::{
    close, listener_read_event, listener_write_event, modify_interest, remove_interest,
};</code></pre>
<h3 id="è¯·æ±‚ä¸Šä¸‹æ–‡"><a class="header" href="#è¯·æ±‚ä¸Šä¸‹æ–‡">è¯·æ±‚ä¸Šä¸‹æ–‡</a></h3>
<p>å°†ä¸å®¢æˆ·ç«¯å»ºç«‹çš„è¿æ¥æŠ½è±¡æˆè¯·æ±‚ä¸Šä¸‹æ–‡ï¼š</p>
<pre><code class="language-rust noplayground">/// è¯·æ±‚ä¸Šä¸‹æ–‡ï¼Œç”¨äºå¤„ç† HTTP è¯·æ±‚
#[derive(Debug)]
pub struct RequestContext {
    /// ä¸å®¢æˆ·ç«¯å»ºç«‹çš„è¿æ¥çš„ stream æµ
    pub stream: TcpStream,
    /// æ”¶åˆ°çš„ HTTP è¯·æ±‚çš„ content-length çš„å€¼
    pub content_length: usize,
    /// æ”¶åˆ°çš„ HTTP è¯·æ±‚çš„æ•°æ®å†™å…¥çš„ç¼“å†²åŒº
    pub buf: Vec&lt;u8&gt;,
}</code></pre>
<p>æ¥ä¸‹æ¥ç¼–å†™çš„å‡½æ•°ï¼Œéƒ½æ˜¯ä¸º <code>RequestContext</code> å®ç°çš„æ–¹æ³•ã€‚</p>
<h3 id="åˆ›å»ºè¯·æ±‚ä¸Šä¸‹æ–‡"><a class="header" href="#åˆ›å»ºè¯·æ±‚ä¸Šä¸‹æ–‡">åˆ›å»ºè¯·æ±‚ä¸Šä¸‹æ–‡</a></h3>
<pre><code class="language-rust noplayground">pub fn new(stream: TcpStream) -&gt; Self {
    Self {
        stream,
        buf: Vec::new(),
        content_length: 0,
    }
}</code></pre>
<h3 id="ä»-stream-æµä¸­è¯»å–æ•°æ®"><a class="header" href="#ä»-stream-æµä¸­è¯»å–æ•°æ®">ä» stream æµä¸­è¯»å–æ•°æ®</a></h3>
<pre><code class="language-rust noplayground">pub fn read_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
    let mut buf = [0u8; 4096];

    // ä» stream æµä¸­è¯»å–æ•°æ®å†™å…¥åˆ° buf ä¸­
    match self.stream.read(&amp;mut buf) {
        Ok(_) =&gt; {
            if let Ok(data) = std::str::from_utf8(&amp;buf) {

                // è§£æå¹¶ä¸”è®¾ç½®è¯»å–åˆ°çš„ HTTP è¯·æ±‚çš„ content-length å­—æ®µçš„å€¼
                self.parse_and_set_content_length(data);
            }
        }
        Err(e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {}
        Err(e) =&gt; {
            return Err(e);
        }
    };

    // å°†è¯»å–çš„æ•°æ®æ‰©å±•åˆ° RequestContext çš„ buf ä¸­
    self.buf.extend_from_slice(&amp;buf);

    // å¦‚æœ buf ä¸­çš„æ•°æ®é•¿åº¦å¤§äºç­‰äº content-lengthï¼Œè¯´æ˜ä»å®¢æˆ·ç«¯å‘é€çš„ HTTP è¯·æ±‚å·²ç»è¯»å–å®Œæ¯•
    if self.buf.len() &gt;= self.content_length {
        println!(&quot;got all data: {} bytes&quot;, self.buf.len());

        // å°†åœ¨ stream ä¸Šç›‘å¬çš„äº‹ä»¶ä¿®æ”¹ä¸ºå†™äº‹ä»¶
        modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_write_event(key))?;
    } else {

        // å°†åœ¨ stream ä¸Šç›‘å¬çš„äº‹ä»¶ä¿®æ”¹ä¸ºè¯»äº‹ä»¶ï¼Œç»§ç»­è¯»å–å‰©ä¸‹çš„ HTTP è¯·æ±‚
        modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_read_event(key))?;
    }

    Ok(())
}</code></pre>
<h3 id="è§£æ-http-è¯·æ±‚"><a class="header" href="#è§£æ-http-è¯·æ±‚">è§£æ HTTP è¯·æ±‚</a></h3>
<pre><code class="language-rust noplayground">/// è§£æå¹¶ä¸”è®¾ç½®è¯»å–åˆ°çš„ HTTP è¯·æ±‚çš„ content-length å­—æ®µçš„å€¼
pub fn parse_and_set_content_length(&amp;mut self, data: &amp;str) {
    if data.contains(&quot;HTTP&quot;) {
        if let Some(content_length) = data
            .lines()
            .find(|l| l.to_lowercase().starts_with(&quot;content-length: &quot;))
        {
            if let Some(len) = content_length
                .to_lowercase()
                .strip_prefix(&quot;content-length: &quot;)
            {
                self.content_length = len.parse::&lt;usize&gt;().expect(&quot;content-length is valid&quot;);
                println!(&quot;set content length: {} bytes&quot;, self.content_length);
            }
        }
    }
}</code></pre>
<h3 id="å†™å…¥è¿”å›æ•°æ®åˆ°-stream-æµä¸­"><a class="header" href="#å†™å…¥è¿”å›æ•°æ®åˆ°-stream-æµä¸­">å†™å…¥è¿”å›æ•°æ®åˆ° stream æµä¸­</a></h3>
<p>ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç›´æ¥è¿”å›ä¸€æ®µå›ºå®šçš„ <code>HTTP</code> æ–‡æœ¬ã€‚</p>
<pre><code class="language-rust noplayground">// è¿”å›çš„å“åº”ä¸ºå›ºå®šçš„ HTTP æ–‡æœ¬
const HTTP_RESP: &amp;[u8] = br#&quot;HTTP/1.1 200 OK
content-type: text/html
content-length: 28

Hello! I am an epoll server.&quot;#;

/// å°†è¦è¿”å›çš„ HTTP æ•°æ®å†™å…¥åˆ° stream æµä¸­
pub fn write_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // å†™å…¥æ•°æ®åˆ° stream æµä¸­
    match self.stream.write(HTTP_RESP) {
        Ok(_) =&gt; println!(&quot;answered from request {}&quot;, key),
        Err(e) =&gt; eprintln!(&quot;could not answer to request {}, {}&quot;, key, e),
    };

    // å…³é—­ stream æµ
    self.stream.shutdown(std::net::Shutdown::Both)?;

    let fd = self.stream.as_raw_fd();
    // ç§»é™¤åœ¨ epoll ä¸­æ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦ fd
    remove_interest(epoll_fd, fd)?;

    // å…³é—­æ–‡ä»¶æè¿°ç¬¦ fd
    close(fd);

    Ok(())
}</code></pre>
<h2 id="main-æ¨¡å—"><a class="header" href="#main-æ¨¡å—">main æ¨¡å—</a></h2>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¼šç¼–å†™ <code>server</code> çš„å…¥å£å‡½æ•°ï¼Œä¸»è¦çš„é€»è¾‘ä¸ºï¼šæ³¨å†Œæ–‡ä»¶æè¿°ç¬¦  =&gt;  è°ƒç”¨ <code>epoll_wait</code> è·å–å°±ç»ªçš„äº‹ä»¶  =&gt;  æ ¹æ®ä¸åŒçš„äº‹ä»¶è¿›è¡Œå¤„ç†ã€‚</p>
<pre><code class="language-rust noplayground">use std::collections::HashMap;
use std::io;
use std::net::TcpListener;
use std::os::unix::io::AsRawFd;

use rust_epoll_example::epoll::{add_interest, epoll_create, listener_read_event, modify_interest};
use rust_epoll_example::http::RequestContext;
use rust_epoll_example::syscall;

fn main() -&gt; io::Result&lt;()&gt; {
    // å­˜å‚¨ RequestContext å®ä¾‹ï¼Œkey ç”¨æ¥åŒºåˆ†ä¸åŒçš„ RequestContext
    let mut request_contexts: HashMap&lt;u64, RequestContext&gt; = HashMap::new();

    // å­˜å‚¨å°±ç»ªçš„ event
    let mut events: Vec&lt;libc::epoll_event&gt; = Vec::with_capacity(1024);

    // key å¯¹åº” epoll_event ä¸­çš„ u64 å­—æ®µï¼Œç”¨äºåŒºåˆ†æ–‡ä»¶æè¿°ã€RequestContext
    let mut key = 100;

    // åˆ›å»ºä¸€ä¸ª listenerï¼Œå¹¶ç›‘å¬ 8000 ç«¯å£
    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;)?;

    // å°† socket è®¾ç½®ä¸ºéé˜»å¡
    listener.set_nonblocking(true)?;

    // è·å– listener å¯¹åº”æ–‡ä»¶æè¿°ç¬¦
    let listener_fd = listener.as_raw_fd();

    // åˆ›å»º epoll å®ä¾‹ï¼Œè¿”å› epoll æ–‡ä»¶æè¿°ç¬¦
    let epoll_fd = epoll_create().expect(&quot;can create epoll queue&quot;);

    // åœ¨ epoll å®ä¾‹ä¸­æ³¨å†Œ listener æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶ç›‘å¬è¯»äº‹ä»¶
    // key ç­‰äº 100ï¼Œå¯¹åº” listener æ–‡ä»¶æè¿°ç¬¦
    add_interest(epoll_fd, listener_fd, listener_read_event(key))?;

    loop {
        println!(&quot;requests in flight: {}&quot;, request_contexts.len());
        events.clear();

        // å°†å°±ç»ªçš„äº‹ä»¶æ·»åŠ åˆ° events vec ä¸­ï¼Œè¿”å›å°±ç»ªçš„äº‹ä»¶æ•°é‡
        let res = match syscall!(epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000,
        )) {
            Ok(v) =&gt; v,
            Err(e) =&gt; panic!(&quot;error during epoll wait: {}&quot;, e),
        };

        // safe  as long as the kernel does nothing wrong - copied from mio
        // æ ¹æ®å°±ç»ªçš„äº‹ä»¶æ•°é‡è®¾ç½® events vec çš„é•¿åº¦
        unsafe { events.set_len(res as usize) };

        // éå†å¤„ç†å°±ç»ªçš„äº‹ä»¶
        for ev in &amp;events {
            match ev.u64 {
                // key = 100 è¯´æ˜æ˜¯åœ¨ listener fd ä¸Šç›‘å¬çš„è¯»äº‹ä»¶å°±ç»ªäº†
                100 =&gt; {
                    match listener.accept() {

                        // stream æ˜¯ä¸å®¢æˆ·ç«¯å»ºç«‹çš„è¿æ¥çš„ stream æµ
                        Ok((stream, addr)) =&gt; {
                            // è®¾ç½®ä¸ºéé˜»å¡
                            stream.set_nonblocking(true)?;

                            // æœ‰ä¸€ä¸ªæ–°çš„è¿æ¥æ¥äº†
                            println!(&quot;new client: {}&quot;, addr);
                            key += 1;

                            // åœ¨ epoll ä¸­æ³¨å†Œ stream æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶ç›‘å¬è¯»äº‹ä»¶
                            add_interest(epoll_fd, stream.as_raw_fd(), listener_read_event(key))?;

                            // åˆ›å»ºä¸€ä¸ª RequestContextï¼Œå¹¶ä¿å­˜åˆ° request_contexts ä¸­
                            request_contexts.insert(key, RequestContext::new(stream));
                            // ä¸Šé¢ä½¿ç”¨çš„ keyï¼Œç”¨æ¥åŒºåˆ†ä¸åŒçš„æ–‡ä»¶æè¿°ç¬¦å’Œ RequestContext
                        }
                        Err(e) =&gt; eprintln!(&quot;couldn't accept: {}&quot;, e),
                    };

                    // ä¿®æ”¹åœ¨ listener fd ä¸Šç›‘å¬çš„çš„äº‹ä»¶ä¸ºè¯»äº‹ä»¶ï¼ˆç»§ç»­ç­‰å¾…æ–°çš„è¿æ¥åˆ°æ¥ï¼‰
                    modify_interest(epoll_fd, listener_fd, listener_read_event(100))?;
                }
                // key != 100ï¼Œè¯´æ˜æ˜¯å…¶ä»–çš„ fd ä¸Šç›‘å¬çš„äº‹ä»¶å°±ç»ªäº†
                key =&gt; {
                    let mut to_delete = None;

                    // è·å–è¿™ä¸ª key å¯¹åº”çš„ RequestContext
                    if let Some(context) = request_contexts.get_mut(&amp;key) {

                        let events: u32 = ev.events;

                        // åŒ¹é…å°±ç»ªçš„äº‹ä»¶æ˜¯è¯»äº‹ä»¶è¿˜æ˜¯å†™äº‹ä»¶
                        match events {

                            // è¯»äº‹ä»¶å°±ç»ª
                            v if v as i32 &amp; libc::EPOLLIN == libc::EPOLLIN =&gt; {

                                // è¯»å–è¯·æ±‚æ•°æ®
                                context.read_cb(key, epoll_fd)?;
                            }
                            // å†™äº‹ä»¶å°±ç»ª
                            v if v as i32 &amp; libc::EPOLLOUT == libc::EPOLLOUT =&gt; {

                                // å†™å…¥è¿”å›æ•°æ®
                                context.write_cb(key, epoll_fd)?;

                                // è¿”å›æ•°æ®åï¼Œå°±åˆ é™¤å¯¹åº”çš„ RequestContextï¼Œ
                                // å½“å®¢æˆ·ç«¯å†æ¬¡å‘èµ·è¯·æ±‚æ—¶ä¼šå»ºç«‹æ–°çš„è¿æ¥ï¼Œåˆ›å»ºæ–°çš„ RequestContext
                                to_delete = Some(key);
                            }
                            v =&gt; println!(&quot;unexpected events: {}&quot;, v),
                        };
                    }

                    // å†™äº‹ä»¶å¤„ç†å®Œæ¯•ï¼Œåˆ é™¤å¯¹åº”çš„ RequestContext
                    if let Some(key) = to_delete {
                        request_contexts.remove(&amp;key);
                    }
                }
            }
        }
    }
}</code></pre>
<p><code>HTTP</code> åè®®æ˜¯æ— çŠ¶æ€çš„ï¼Œæˆ‘ä»¬åœ¨å®Œæ•´å¤„ç†ä¸€æ¬¡è¯·æ±‚åå°±åˆ é™¤å¯¹åº”çš„è¯·æ±‚ä¸Šä¸‹æ–‡ï¼Œå½“å®¢æˆ·ç«¯å†æ¬¡å‘èµ·è¯·æ±‚æ—¶ä¼šå»ºç«‹æ–°çš„è¿æ¥ï¼Œåˆ›å»ºæ–°çš„è¯·æ±‚ä¸Šä¸‹æ–‡ã€‚</p>
<p>è‡³æ­¤ï¼Œ<code>epoll server</code> ç¼–å†™å®Œæ¯•ã€‚</p>
<h2 id="è¿è¡Œ-server"><a class="header" href="#è¿è¡Œ-server">è¿è¡Œ server</a></h2>
<p>ä½¿ç”¨ <code>cargo run</code> å¯åŠ¨ <code>server</code>ï¼Œç„¶åè¿™ä¸ª <code>server</code> ä¼šç›‘å¬åœ°å€ï¼š<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a> ã€‚</p>
<p>ä¸ºäº†æµ‹è¯• <code>server</code>ï¼Œç¼–å†™ä¸€ä¸ª <code>Python</code> å°è„šæœ¬ï¼Œä½¿ç”¨å¤šçº¿ç¨‹å¾ªç¯å‘é€ <code>HTTP</code> è¯·æ±‚ï¼š</p>
<pre><code class="language-python">import requests

from threading import Thread

with open('image.jpeg', 'rb') as f:
    FILE = f.read()


# send request to http://127.0.0.1:8000
def send_request(host, port):
    for _ in range(100):
        r = requests.post(f&quot;http://{host}:{port}&quot;, data={'file': FILE})
        print(f&quot;Receive response: '{r.text}' from {r.url}&quot;)


if __name__ == '__main__':
    t_lst = []
    for _ in range(4):
        t = Thread(target=send_request, args=('127.0.0.1', 8000))
        t_lst.append(t)
        t.start()

    for t in t_lst:
        t.join()
</code></pre>
<p><code>client</code> ç«¯çš„è¾“å‡ºï¼š</p>
<pre><code>.....
.....
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
Receive response: 'Hello! I am an epoll server.' from http://127.0.0.1:8000/
</code></pre>
<p><code>server</code> ç«¯çš„è¾“å‡ºï¼š</p>
<pre><code>.....
.....
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
requests in flight: 3
got all data: 9379840 bytes
requests in flight: 3
answered from request 195
</code></pre>
<p>æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„é‚£æ ·ï¼Œ<code>server</code> åœ¨åŒæ—¶å¤„ç†å¤šä¸ªè¯·æ±‚ï¼</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¼‚æ­¥è¿è¡Œæ—¶"><a class="header" href="#å¼‚æ­¥è¿è¡Œæ—¶">å¼‚æ­¥è¿è¡Œæ—¶</a></h1>
<p>åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®²åˆ°è¿‡å¼‚æ­¥è¿è¡Œæ—¶è´Ÿè´£è°ƒåº¦æ‰§è¡Œä½¿ç”¨è€…åˆ›å»ºçš„ <code>Future</code>ï¼Œé‚£ä¹ˆå¼‚æ­¥è¿è¡Œæ—¶åˆ°åº•æ˜¯å¦‚ä½•å·¥ä½œçš„å‘¢ï¼Ÿåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šå®ç°ä¸€ä¸ªç®€å•çš„å•çº¿ç¨‹å¼‚æ­¥è¿è¡Œæ—¶ï¼Œæä¾›å¼‚æ­¥çš„ç½‘ç»œIOè¯»å†™æ“ä½œï¼Œä»¥æ¢è®¨è¿è¡Œæ—¶çš„å…·ä½“å·¥ä½œæœºåˆ¶ã€‚</p>
<p>æœ¬ç« èŠ‚çš„æºä»£ç ä»“åº“åœ°å€ï¼š<a href="https://github.com/night-cruise/async-runtime">async-runtime</a>ã€‚</p>
<p>åœ¨æ­£å¼å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆæ˜ç¡®ä¸€ä¸‹å³å°†å®ç°çš„è¿è¡Œæ—¶çš„å·¥ä½œåŸç†ï¼š</p>
<p><img src="imgs/async-runtime.png" alt="" /></p>
<ol>
<li>
<p>ç”¨æˆ·ä½¿ç”¨ <code>async fn</code> æˆ–è€… <code>async {}</code> çš„æ–¹å¼åˆ›å»º <code>Non-Leaf Future</code>ï¼Œç„¶åä½¿ç”¨ <code>spawn</code> æ–¹æ³•åˆ›å»ºä¸€ä¸ªå¼‚æ­¥ <code>task</code>ï¼Œå¹¶å°†è¿™ä¸ª <code>task</code> å‘é€åˆ° <code>executor</code> çš„ä»»åŠ¡é˜Ÿåˆ—ä¸­ã€‚</p>
</li>
<li>
<p><code>executor</code> ä» <code>task_queue</code> ä¸­å–å‡º <code>task</code>ï¼Œè°ƒç”¨<code>task</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œé©±åŠ¨ <code>Non-Leaf Future</code> å¼€å§‹æ‰§è¡Œï¼ˆå¦‚æœå·²ç»å¼€å§‹æ‰§è¡Œäº†ï¼Œåˆ™ä»ä¸Šæ¬¡çš„ <code>await</code> æ–­ç‚¹å¤„ç»§ç»­æ‰§è¡Œï¼‰ï¼Œå°±è¿™æ ·ä¸€ç›´æ‰§è¡Œ <code>Future</code> ä¸­çš„ä»£ç ï¼Œç›´åˆ°é‡åˆ° <code>Leaf Future.await</code>ã€‚</p>
</li>
<li>
<p>è°ƒç”¨ <code>Leaf Future</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œå¦‚æœ <code>Leaf Future</code> å¯¹åº”çš„IOäº‹ä»¶å·²ç»å°±ç»ªï¼Œåˆ™ç›´æ¥è¿”å› <code>Poll::Ready(data)</code>ï¼›å¦‚æœå¯¹åº”çš„IOäº‹ä»¶æ²¡æœ‰å°±ç»ªï¼Œåˆ™è°ƒç”¨ <code>Reactor</code> çš„ <code>register</code> æ–¹æ³•æ³¨å†Œç­‰å¾…çš„IOäº‹ä»¶å’Œ <code>waker</code>ï¼Œç„¶å <code>Poll::Pending</code>ï¼ˆ<code>Non-Leaf Future</code> å°†ä¼šè¢«æŒ‚èµ·ï¼‰ï¼Œ<code>executor</code> å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–çš„ <code>task</code>ã€‚</p>
</li>
<li>
<p><code>Reactor</code> ä¼šæŠŠæ³¨å†Œçš„æ–‡ä»¶æè¿°ç¬¦ <code>fd</code>ã€<code>waker</code> ä¿å­˜åœ¨<code>BTreeMap&lt;fd, waker&gt;</code> ä¸­ï¼Œç„¶åè°ƒç”¨ <code>Epoll</code> æä¾›çš„æ–¹æ³•æ³¨å†Œåœ¨ <code>fd</code> ä¸Šæƒ³è¦ç­‰å¾…çš„ <code>event</code> åˆ° <code>Epoll</code> ç³»ç»Ÿä¸­ã€‚</p>
</li>
<li>
<p><code>Reactor</code> è°ƒç”¨ <code>Epoll</code> æä¾›çš„ <code>wait</code> æ–¹æ³•è·å–æ‰€æœ‰å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦ <code>fds</code>ï¼Œç„¶åéå† <code>fds</code>ï¼Œé€šè¿‡ <code>fd</code> åŒ¹é…ä¹‹å‰åœ¨ <code>BTreeMap</code> ä¸­å­˜å‚¨çš„ <code>waker</code>ï¼Œç„¶åè°ƒç”¨ <code>waker</code> çš„ <code>wake</code> æ–¹æ³•æŠŠ <code>task</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œè¿™æ ·ä¹‹å‰æŒ‚èµ·çš„ <code>Non-Leaf Future</code> å°±èƒ½å¤Ÿç»§ç»­æ‰§è¡Œäº†ã€‚</p>
</li>
</ol>
<p>é€šè¿‡ä¸Šé¢çš„åŸç†è®²è§£æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå¼‚æ­¥ä»£ç ä¹‹æ‰€ä»¥é«˜æ•ˆçš„åŸå› å°±æ˜¯é¿å…äº†IOå¯¹çº¿ç¨‹çš„é˜»å¡ï¼š</p>
<ul>
<li>
<p>å½“æ‰§è¡Œä¸€ä¸ª <code>task</code> æ—¶ï¼Œå¦‚æœé‡åˆ°äº†æ²¡æœ‰å°±ç»ªçš„ IO æ“ä½œï¼Œå°±æ³¨å†Œ <code>waker</code> åˆ° <code>Reactor</code> ä¸­ï¼Œç„¶åæŒ‚èµ·è¿™ä¸ª <code>task</code>ï¼Œ<code>executor</code> å°±å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–çš„ <code>task</code>ã€‚</p>
</li>
<li>
<p>å½“ <code>task</code> ç­‰å¾…çš„ IO äº‹ä»¶å°±ç»ªæ—¶ï¼Œ<code>Reactor</code> å°±ä¼šé€šè¿‡ <code>waker</code> å”¤é†’å…³è”çš„ <code>task</code>ï¼Œç„¶åå°±å¯ä»¥æ‰§è¡Œä¹‹å‰æŒ‚èµ·çš„ <code>task</code> äº†ã€‚</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoll-1"><a class="header" href="#epoll-1">epoll</a></h1>
<p>å°±åƒ <code>Epoll servere example</code> ä¸€èŠ‚ä¸­é‚£æ ·ï¼Œä¸ºäº†æ–¹ä¾¿åœ°è°ƒç”¨ <code>libc</code> æä¾›çš„ <code>api</code>ï¼Œæˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ª <code>syscall</code> å®ï¼š</p>
<pre><code class="language-rust noplayground">macro_rules! syscall {
    ($fn: ident ( $($arg: expr),* $(,)* ) ) =&gt; {{
        let res = unsafe { libc::$fn($($arg, )*) };
        if res == -1 {
            Err(io::Error::last_os_error())
        } else {
            Ok(res)
        }
    }};
}</code></pre>
<h2 id="epoll-2"><a class="header" href="#epoll-2">Epoll</a></h2>
<p>æŠ½è±¡å‡º <code>Epoll</code> å’Œ <code>EpollEventType</code> ç±»å‹ï¼š</p>
<pre><code class="language-rust noplayground">pub(crate) struct Epoll {
    fd: RawFd,
}

pub(crate) enum EpollEventType {
    // Only event types used in this example
    In,
    Out,
}</code></pre>
<p><code>RawFd</code> è¡¨ç¤ºåŸå§‹æ–‡ä»¶æè¿°ç¬¦ã€‚</p>
<h2 id="æ–¹æ³•å®ç°"><a class="header" href="#æ–¹æ³•å®ç°">æ–¹æ³•å®ç°</a></h2>
<h3 id="new"><a class="header" href="#new">new</a></h3>
<p>åˆ›å»ºä¸€ä¸ª <code>Epoll</code> å®ä¾‹ï¼š</p>
<pre><code class="language-rust noplayground">pub(crate) fn new() -&gt; io::Result&lt;Self&gt; {
    let fd = syscall!(epoll_create1(libc::EPOLL_CLOEXEC))?;
    Ok(Epoll { fd })
}</code></pre>
<h3 id="æ·»åŠ äº‹ä»¶ä¿®æ”¹äº‹ä»¶"><a class="header" href="#æ·»åŠ äº‹ä»¶ä¿®æ”¹äº‹ä»¶">æ·»åŠ äº‹ä»¶/ä¿®æ”¹äº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">fn run_ctl(&amp;self, epoll_ctl: libc::c_int, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    let mut event: libc::epoll_event = unsafe { mem::zeroed() };
    event.u64 = fd as u64;
    event.events = match op {
        EpollEventType::In =&gt; libc::EPOLLIN as u32,
        EpollEventType::Out =&gt; libc::EPOLLOUT as u32,
    };

    let event_p: *mut _ = &amp;mut event as *mut _;
    syscall!(epoll_ctl(self.fd, epoll_ctl, fd, event_p))?;

    Ok(())
}

pub(crate) fn add_event(&amp;self, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    self.run_ctl(libc::EPOLL_CTL_ADD, fd, op)
}

#[allow(dead_code)]
pub(crate) fn mod_event(&amp;self, fd: RawFd, op: EpollEventType) -&gt; io::Result&lt;()&gt; {
    self.run_ctl(libc::EPOLL_CTL_MOD, fd, op)
}</code></pre>
<p><code>add_event</code> å’Œ <code>mod_event</code> éƒ½æ˜¯é€šè¿‡è°ƒç”¨<code>run_ctl</code> æ–¹æ³•å®ç°çš„ã€‚åœ¨ <code>run_ctl</code> æ–¹æ³•ä¸­æ ¹æ® <code>op</code> ç±»å‹è®¾ç½®è¦æ³¨å†Œ/ä¿®æ”¹çš„äº‹ä»¶ç±»å‹ï¼Œç„¶åè°ƒç”¨ <code>epoll_ctl</code> æ–¹æ³•æ¥æ³¨å†Œ/ä¿®æ”¹äº‹ä»¶ã€‚</p>
<h3 id="åˆ é™¤äº‹ä»¶"><a class="header" href="#åˆ é™¤äº‹ä»¶">åˆ é™¤äº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">pub(crate) fn del_event(&amp;self, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    syscall!(epoll_ctl(
        self.fd,
        libc::EPOLL_CTL_DEL,
        fd,
        std::ptr::null_mut() as *mut libc::epoll_event
    ))?;

    Ok(())
}</code></pre>
<p>åˆ é™¤åœ¨ <code>Epoll</code> å®ä¾‹ä¸­æ³¨å†Œæè¿°ç¬¦ <code>fd</code>ã€‚</p>
<h3 id="ç­‰å¾…å°±ç»ªäº‹ä»¶"><a class="header" href="#ç­‰å¾…å°±ç»ªäº‹ä»¶">ç­‰å¾…å°±ç»ªäº‹ä»¶</a></h3>
<pre><code class="language-rust noplayground">pub(crate) fn wait(&amp;self, events: &amp;mut [libc::epoll_event]) -&gt; io::Result&lt;usize&gt; {
    let nfd = syscall!(epoll_wait(
        self.fd,
        events.as_mut_ptr(),
        events.len() as i32,
        -1
    ))?;

    Ok(nfd as usize)
}</code></pre>
<p>è°ƒç”¨ <code>epoll_wait</code> å‡½æ•°è·å–æ‰€æœ‰å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶å°†å°±ç»ªçš„æè¿°ç¬¦å­˜æ”¾åˆ° <code>events</code> ä¸­ï¼Œæœ€åè¿”å›å°±ç»ªçš„æè¿°ç¬¦æ•°é‡ã€‚</p>
<h2 id="å…³é—­epoll"><a class="header" href="#å…³é—­epoll">å…³é—­Epoll</a></h2>
<p>ä¸º <code>Epoll</code> å®ç° <code>Drop trait</code>ï¼Œåœ¨æ¸…ç† <code>Epoll</code> æ—¶å…³é—­ <code>Epoll</code> çš„æ–‡ä»¶æè¿°ç¬¦ï¼š</p>
<pre><code class="language-rust noplayground">impl Drop for Epoll {
    fn drop(&amp;mut self) {
        syscall!(close(self.fd)).ok();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactor"><a class="header" href="#reactor">reactor</a></h1>
<h2 id="reactor-1"><a class="header" href="#reactor-1">Reactor</a></h2>
<pre><code class="language-rust noplayground">pub(crate) struct Reactor {
    pub epoll: Epoll,
    pub wakers: Mutex&lt;BTreeMap&lt;RawFd, Waker&gt;&gt;,
}</code></pre>
<p>å­—æ®µ <code>epoll</code> å­˜å‚¨åˆ›å»ºçš„ <code>Epoll</code> å®ä¾‹ï¼Œ<code>wakers</code> å­˜å‚¨ç­‰å¾…çš„IOäº‹ä»¶çš„æ–‡ä»¶æè¿°ç¬¦å’Œå¯¹åº”çš„ <code>waker</code>ã€‚</p>
<p>æˆ‘ä»¬ç¨åå°†ä¼šåˆ›å»º <code>Epoll</code> çš„é™æ€å˜é‡ï¼Œä¸ºäº†å†…éƒ¨å¯å˜æ€§ï¼Œå°±æŠŠ <code>BTreeMap&lt;RawFd, Waker&gt;</code> åŒ…åœ¨ <code>Mutex</code> ä¸­ã€‚</p>
<h2 id="æ·»åŠ äº‹ä»¶"><a class="header" href="#æ·»åŠ äº‹ä»¶">æ·»åŠ äº‹ä»¶</a></h2>
<pre><code class="language-rust noplayground">impl Reactor {
    pub(crate) fn add_event(&amp;self, fd: RawFd, op: EpollEventType, waker: Waker) -&gt; io::Result&lt;()&gt; {
        info!(&quot;(Reactor) add event: {}&quot;, fd);
        self.epoll.add_event(fd, op)?;
        self.wakers.lock().unwrap().insert(fd, waker);
        Ok(())
    }
}</code></pre>
<p>åœ¨ <code>Reactor</code> çš„æ·»åŠ äº‹ä»¶çš„æ–¹æ³•ä¸­ï¼Œé¦–å…ˆè°ƒç”¨ <code>epoll</code> çš„ <code>add_event</code> æ–¹æ³•æ³¨å†Œæ–‡ä»¶æè¿°ç¬¦å’Œç›‘å¬çš„äº‹ä»¶ï¼Œç„¶åæŠŠæè¿°ç¬¦å’Œå¯¹åº”çš„ <code>waker</code> å­˜å‚¨åœ¨ <code>BTreeMap&lt;RawFd, Waker&gt;</code> ä¸­ã€‚</p>
<h2 id="reactor-å¾ªç¯"><a class="header" href="#reactor-å¾ªç¯">reactor å¾ªç¯</a></h2>
<pre><code class="language-rust noplayground">fn reactor_main_loop() -&gt; io::Result&lt;()&gt; {
    info!(&quot;Start reactor main loop&quot;);
    let max_event = 32;
    let event: libc::epoll_event = unsafe { mem::zeroed() };
    let mut events = vec![event; max_event];
    let reactor = &amp;REACTOR;

    loop {
        let nfd = reactor.epoll.wait(&amp;mut events)?;
        info!(&quot;(Reactor) wake up. nfd = {}&quot;, nfd);

        #[allow(clippy::needless_range_loop)]
        for i in 0..nfd {
            let fd = events[i].u64 as RawFd;
            if let Some(waker) = reactor.wakers.lock().unwrap().remove(&amp;fd) {
                info!(&quot;(Reactor) delete event: {}&quot;, fd);
                reactor.epoll.del_event(fd)?;
                waker.wake();
            }
        }
    }
}</code></pre>
<p>åœ¨ <code>reactor_main_loop</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª <code>loop</code> å¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­è°ƒç”¨ <code>epoll</code> çš„ <code>wait</code> æ–¹æ³•è·å–æ‰€æœ‰å°±ç»ªçš„ IO äº‹ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¦‚æœæ²¡æœ‰äº‹ä»¶å°±ç»ªï¼Œ<code>wait</code> æ–¹æ³•å°±ä¼šé˜»å¡ <code>reactor</code> çº¿ç¨‹ï¼Œé¿å… CPU ç©ºè½¬ã€‚</p>
<p>ç„¶åéå†å°±ç»ªçš„æè¿°ç¬¦ï¼Œä» <code>wakers</code> ä¸­è·å–æè¿°ç¬¦å¯¹åº”çš„ <code>waker</code>ï¼Œä¹‹åè°ƒç”¨ <code>epoll</code> çš„ <code>delete_event</code> æ–¹æ³•åˆ é™¤æè¿°ç¬¦ï¼Œè¡¨ç¤ºè¿™ä¸ªäº‹ä»¶å·²ç»å¤„ç†å®Œæ¯•ã€‚</p>
<p>æœ€åï¼Œè°ƒç”¨ <code>waker</code> çš„ <code>wake</code> æ–¹æ³•ï¼ŒæŠŠå› ä¸ºç­‰å¾…IOäº‹ä»¶è€ŒæŒ‚èµ·çš„ <code>task</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ã€‚</p>
<h2 id="reactor-é™æ€å˜é‡"><a class="header" href="#reactor-é™æ€å˜é‡">REACTOR é™æ€å˜é‡</a></h2>
<pre><code class="language-rust noplayground">lazy_static! {
    pub(crate) static ref REACTOR: Reactor = {
        // Start reactor main loop
        std::thread::spawn(move || {
            reactor_main_loop()
        });

        Reactor {
            epoll: Epoll::new().expect(&quot;failed to create epoll&quot;),
            wakers: Mutex::new(BTreeMap::new())
        }
    };
}</code></pre>
<p><code>Executor</code> åœ¨ä¸»çº¿ç¨‹è¿è¡Œï¼Œè´Ÿè´£è°ƒåº¦æ‰§è¡Œ <code>task</code>ï¼Œè€Œ <code>reactor_main_loop</code> å†…éƒ¨ä½¿ç”¨ä¸€ä¸ªæ— çº¿å¾ªç¯ä¸æ–­åœ°è·å–å°±ç»ªçš„ <code>fd</code>ï¼Œå¹¶å”¤é†’æŒ‚èµ·çš„ <code>task</code>ã€‚ä¸ºäº†é¿å… <code>reactor_main_loop</code> é˜»å¡ <code>Executor</code>ï¼Œæˆ‘ä»¬å°±å¼€ä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œ <code>reactor_main_loop</code>ã€‚</p>
<p>ä¹‹æ‰€ä»¥æŠŠ <code>REACTOR</code> åˆ›å»ºæˆå…¨å±€é™æ€å˜é‡ï¼Œæ˜¯ä¸ºäº†åœ¨å…¶ä»–çš„æ¨¡å—ä¸­æ–¹ä¾¿åœ°è°ƒç”¨ <code>REACTOR</code> çš„æ–¹æ³•ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async_io"><a class="header" href="#async_io">async_io</a></h1>
<p>åœ¨ <code>async_io</code> æ¨¡å—ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šåˆ›å»º <code>Leaf Future</code>ï¼Œå¼‚æ­¥åŒ–ç½‘ç»œIOçš„ç›‘å¬å’Œè¯»å†™æ“ä½œã€‚</p>
<h2 id="ipv4addr"><a class="header" href="#ipv4addr">Ipv4Addr</a></h2>
<pre><code class="language-rust noplayground">pub struct Ipv4Addr(libc::in_addr);

impl Ipv4Addr {
    pub fn new(a: u8, b: u8, c: u8, d: u8) -&gt; Self {
        Ipv4Addr(libc::in_addr {
            s_addr: ((u32::from(a) &lt;&lt; 24)
                | (u32::from(b) &lt;&lt; 16)
                | (u32::from(c) &lt;&lt; 8)
                | u32::from(d))
            .to_be(),
        })
    }
}</code></pre>
<p><code>Ipv4Addr</code> å°±æ˜¯ <code>IPv4</code> åœ°å€ï¼Œ<code>new</code> æ–¹æ³•è´Ÿè´£åˆ›å»ºä¸€ä¸ª <code>Ipv4Addr</code> ç±»å‹ã€‚</p>
<h2 id="tcplistener"><a class="header" href="#tcplistener">TcpListener</a></h2>
<pre><code class="language-rust noplayground">pub struct TcpListener(RawFd);

impl TcpListener {
    // NOTE: bind() may be block. So this should be an async function in reality.
    pub fn bind(addr: Ipv4Addr, port: u16) -&gt; io::Result&lt;TcpListener&gt; {
        let backlog = 128;
        let sock = syscall!(socket(
            libc::PF_INET,
            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,
            0
        ))?;
        let opt: i32 = 1;
        syscall!(setsockopt(
            sock,
            libc::SOL_SOCKET,
            libc::SO_REUSEADDR,
            &amp;opt as *const _ as *const libc::c_void,
            std::mem::size_of_val(&amp;opt) as u32
        ))?;

        let sin: libc::sockaddr_in = libc::sockaddr_in {
            sin_family: libc::AF_INET as libc::sa_family_t,
            sin_port: port.to_be(),
            sin_addr: addr.0,
            ..unsafe { mem::zeroed() }
        };
        let addr_p: *const libc::sockaddr = &amp;sin as *const _ as *const _;
        let len = mem::size_of_val(&amp;sin) as libc::socklen_t;

        syscall!(bind(sock, addr_p, len))?;
        syscall!(listen(sock, backlog))?;

        info!(&quot;(TcpListener) listen: {}&quot;, sock);
        let listener = TcpListener(sock);
        listener.nonblocking()?;
        Ok(listener)
    }

    pub(crate) fn accept(&amp;self) -&gt; io::Result&lt;TcpStream&gt; {
        let mut sin_client: libc::sockaddr_in = unsafe { mem::zeroed() };
        let addr_p: *mut libc::sockaddr = &amp;mut sin_client as *mut _ as *mut _;
        let mut len: libc::socklen_t = unsafe { mem::zeroed() };
        let len_p: *mut _ = &amp;mut len as *mut _;
        let sock_client = syscall!(accept(self.0, addr_p, len_p))?;
        info!(&quot;(TcpStream)  accept: {}&quot;, sock_client);
        Ok(TcpStream(sock_client))
    }

    pub fn incoming(&amp;self) -&gt; Incoming&lt;'_&gt; {
        Incoming(self)
    }

    fn nonblocking(&amp;self) -&gt; io::Result&lt;()&gt; {
        let flag = syscall!(fcntl(self.0, libc::F_GETFL, 0))?;
        syscall!(fcntl(self.0, libc::F_SETFL, flag | libc::O_NONBLOCK))?;
        Ok(())
    }
}

impl Drop for TcpListener {
    fn drop(&amp;mut self) {
        info!(&quot;(TcpListener) close : {}&quot;, self.0);
        syscall!(close(self.0)).ok();
    }
}


pub struct Incoming&lt;'a&gt;(&amp;'a TcpListener);

impl&lt;'a&gt; Incoming&lt;'a&gt; {
    pub fn next(&amp;self) -&gt; AcceptFuture&lt;'a&gt; {
        AcceptFuture(self.0)
    }
}</code></pre>
<p><code>bind</code> æ–¹æ³•è´Ÿè´£ç»‘å®šä¼ å…¥çš„çš„ <code>IpV4</code> åœ°å€å’Œç«¯å£å·ï¼Œåˆ›å»ºä¸€ä¸ª <code>TcpListener</code> å®ä¾‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¦æŠŠ <code>TcpListener</code> è®¾ç½®ä¸ºéé˜»å¡ï¼š<code>listener.nonblocking()</code>ï¼Œè¿™æ ·åœ¨è°ƒç”¨ <code>accept</code> æ–¹æ³•æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥æ—¶æ‰ä¸ä¼šé˜»å¡ã€‚</p>
<p><code>accept</code> æ–¹æ³•è´Ÿè´£æ¥æ”¶åˆ°æ¥çš„å®¢æˆ·ç«¯è¿æ¥ï¼Œç„¶ååˆ›å»º <code>TcpStream</code>ï¼Œå¦‚æœæ²¡æœ‰è¿æ¥åˆ°æ¥å°±è¿”å›ä¸€ä¸ª <code>io error</code>ã€‚</p>
<p><code>nonblocking</code> æ–¹æ³•è°ƒç”¨ <code>libc::fcntl</code> å‡½æ•°æŠŠ <code>TcpListener</code> è®¾ç½®ä¸ºéé˜»å¡ã€‚</p>
<p><code>incoming</code> æ–¹æ³•æŠŠ <code>TcpListener</code> çš„å¼•ç”¨åŒ…åœ¨ <code>Incoming</code> ä¸­ï¼Œç„¶åè¿”å›ä¸€ä¸ª <code>Incoming</code> çš„å®ä¾‹ã€‚</p>
<p><code>Incoming</code> è¡¨ç¤º <code>TcpListener</code> æ¥æ”¶è¿æ¥çš„æµå¼å¤„ç†ï¼Œæ¯å½“æˆ‘ä»¬æƒ³è¦æ¥æ”¶ä¸€ä¸ªæ–°çš„è¿æ¥æ—¶ï¼Œå°±è°ƒç”¨ <code>next</code> æ–¹æ³•è¿”å›ä¸€ä¸ª <code>AcceptFuture</code>ï¼ˆåé¢ä¼šè®²è¿™ä¸ªï¼‰ã€‚</p>
<h2 id="tcpstream"><a class="header" href="#tcpstream">TcpStream</a></h2>
<pre><code class="language-rust noplayground">pub struct TcpStream(RawFd);

impl TcpStream {
    fn nonblocking(&amp;self) -&gt; io::Result&lt;()&gt; {
        let flag = syscall!(fcntl(self.0, libc::F_GETFL, 0))?;
        syscall!(fcntl(self.0, libc::F_SETFL, flag | libc::O_NONBLOCK))?;
        Ok(())
    }

    pub fn read&lt;'a&gt;(&amp;'a self, buf: &amp;'a mut [u8]) -&gt; ReadFuture&lt;'a&gt; {
        ReadFuture(self, buf)
    }

    pub fn write&lt;'a&gt;(&amp;'a self, buf: &amp;'a [u8]) -&gt; WriteFuture&lt;'a&gt; {
        WriteFuture(self, buf)
    }

    pub fn raw_fd(&amp;self) -&gt; RawFd {
        self.0
    }
}

impl Drop for TcpStream {
    fn drop(&amp;mut self) {
        info!(&quot;(TcpStream)  close : {}&quot;, self.0);
        syscall!(close(self.0)).ok();
    }
}</code></pre>
<p><code>nonblocking</code> æ–¹æ³•è°ƒç”¨ <code>libc::fcntl</code> å‡½æ•°æŠŠ <code>TcpStream</code> è®¾ç½®ä¸ºéé˜»å¡ã€‚</p>
<p><code>read/write</code> æ–¹æ³•åˆ†åˆ«è¿”å› <code>RreadFture/WriteFuture</code>ï¼Œå’Œä¸Šé¢çš„ <code>AcceptFuture</code> ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨ä¸‹é¢è®²è§£è¿™äº› <code>Future</code> çš„å®šä¹‰å’Œä½œç”¨ã€‚</p>
<h2 id="leaf-future-1"><a class="header" href="#leaf-future-1">Leaf Future</a></h2>
<pre><code class="language-rust noplayground">pub struct AcceptFuture&lt;'a&gt;(&amp;'a TcpListener);
pub struct ReadFuture&lt;'a&gt;(&amp;'a TcpStream, &amp;'a mut [u8]);
pub struct WriteFuture&lt;'a&gt;(&amp;'a TcpStream, &amp;'a [u8]);

impl&lt;'a&gt; Future for AcceptFuture&lt;'a&gt; {
    type Output = Option&lt;io::Result&lt;TcpStream&gt;&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        match self.0.accept() {
            Ok(stream) =&gt; {
                stream.nonblocking()?;
                Poll::Ready(Some(Ok(stream)))
            }
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::In, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Some(Err(e))),
        }
    }
}

impl&lt;'a&gt; Future for ReadFuture&lt;'a&gt; {
    type Output = io::Result&lt;usize&gt;;

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let res = syscall!(read(
            (self.0).0,
            self.1.as_mut_ptr() as *mut libc::c_void,
            self.1.len()
        ));
        match res {
            Ok(n) =&gt; Poll::Ready(Ok(n as usize)),
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::In, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Err(e)),
        }
    }
}

impl&lt;'a&gt; Future for WriteFuture&lt;'a&gt; {
    type Output = io::Result&lt;usize&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let res = syscall!(write(
            (self.0).0,
            self.1.as_ptr() as *mut libc::c_void,
            self.1.len()
        ));
        match res {
            Ok(n) =&gt; Poll::Ready(Ok(n as usize)),
            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
                REACTOR.add_event((self.0).0, EpollEventType::Out, cx.waker().clone())?;
                Poll::Pending
            }
            Err(e) =&gt; Poll::Ready(Err(e)),
        }
    }
}</code></pre>
<p>åœ¨åŒæ­¥çš„å¤„ç†æ–¹å¼ä¸­ï¼Œç›‘å¬ <code>TcpListener</code> å’Œè¯»å†™ <code>TcpStream</code> æ˜¯é˜»å¡å¼çš„ï¼Œå³ä¼šé˜»å¡çº¿ç¨‹ç›´åˆ°ç›¸åº”çš„ IO äº‹ä»¶å‘ç”Ÿï¼›</p>
<p>è€Œåœ¨å¼‚æ­¥çš„å¤„ç†æ–¹å¼ä¸­ï¼Œç›‘å¬ <code>TcpListener</code> å’Œè¯»å†™ <code>TcpStream</code>  ä¸ä¼šé˜»å¡æ‰çº¿ç¨‹ï¼Œè€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ªå¯¹åº”çš„ <code>Leaf Future</code>ï¼š</p>
<ul>
<li><code>Incoming</code> çš„ <code>next</code> æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª <code>AcceptFuture</code>ã€‚</li>
<li><code>TcpStream</code> çš„ <code>read/write</code> æ–¹æ³•åˆ†åˆ«è¿”å› <code>ReadFuture/WriteFuture</code>ã€‚</li>
</ul>
<p>ä¸º <code>AcceptFuture/ReadFuture/WriteFuture</code> å®ç° <code>Future trait</code>ï¼Œè¿™æ ·å®ƒä»¬å°±æœ‰äº† <code>poll</code> æ–¹æ³•ã€‚ä¸Šè¿°ä¸‰ä¸ª <code>Future</code> çš„ <code>poll</code> æ–¹æ³•çš„æ‰§è¡Œæµç¨‹æ—¶ç±»ä¼¼çš„ï¼Œå› æ­¤ä¸‹é¢æˆ‘ä»¬åªè®²è§£ <code>ReadFutrue</code> çš„æ‰§è¡Œæµç¨‹ã€‚</p>
<p>å½“è°ƒç”¨ <code>ReadFutrue.await</code> æ—¶ï¼Œä¼šè°ƒç”¨ <code>ReadFutrue</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œåœ¨ <code>poll</code> æ–¹æ³•å†…éƒ¨ï¼š</p>
<ul>
<li>
<p>è°ƒç”¨ <code>libc::read</code> å‡½æ•°ä» <code>TcpStream</code> ä¸­è¯»å–æ•°æ®ï¼Œè¿”å› <code>res</code>ã€‚</p>
</li>
<li>
<p>åŒ¹é… <code>res</code> çš„å€¼ï¼š</p>
<ul>
<li>
<p>å¦‚æœæ˜¯ <code>Ok(n)</code>ï¼Œåˆ™è¯»å–åˆ°äº†æ•°æ®ï¼Œæ­¤æ—¶ç›´æ¥è¿”å› <code>Poll::Ready(OK(n))</code>ï¼Œè°ƒç”¨æ–¹ç»§ç»­æ‰§è¡Œ <code>ReadFutrue.await</code> ä¸‹é¢çš„ä»£ç ã€‚</p>
</li>
<li>
<p>å¦‚æœæ˜¯ <code>Err(e)</code>ï¼Œå¹¶ä¸” <code>e.kind() == io::ErrorKind::WouldBlock</code>ï¼Œåˆ™è¯´æ˜ <code>TcpStream</code> ä¸­æ²¡æœ‰æ•°æ®å¯è¯»ï¼Œè¿™æ—¶å°±è°ƒç”¨ <code>REACTOR</code> çš„ <code>add_event</code> æ–¹æ³•æ³¨å†Œæ–‡ä»¶æè¿°ç¬¦ï¼ˆå…³è”è¯»äº‹ä»¶ï¼‰å’Œ <code>waker</code>ã€‚æœ€åè¿”å› <code>Poll::Pending</code>ï¼Œè°ƒç”¨æ–¹æ¥æ”¶åˆ° <code>Poll::Pending</code> åå°±ä¼šè°ƒç”¨ <code>yield</code> è¡¨è¾¾å¼æŒ‚èµ·å½“å‰çš„æ‰§è¡Œæµï¼ˆ<code>Task</code>ï¼‰ã€‚</p>
</li>
<li>
<p>å¦‚æœæ˜¯å…¶ä»–çš„ <code>Err(e)</code>ï¼Œåˆ™è¯´æ˜è¯»å–æ•°æ®å‘ç”Ÿäº†å…¶ä»–é”™è¯¯ï¼Œæ­¤æ—¶è¿”å› <code>Poll::Ready(Err(e))</code> è¡¨ç¤ºè¯»å–å¤±è´¥ï¼Œè°ƒç”¨æ–¹ç»§ç»­æ‰§è¡Œ <code>ReadFutrue.await</code> ä¸‹é¢çš„ä»£ç ã€‚</p>
</li>
</ul>
</li>
</ul>
<p>å½“æ³¨å†Œåˆ° <code>REACTOR</code> ä¸­çš„äº‹ä»¶å°±ç»ªæ—¶ï¼Œ<code>REACTOR</code> å°±ä¼šä½¿ç”¨æ³¨å†Œçš„ <code>waker</code> å”¤é†’æŒ‚èµ·çš„ <code>Task</code>ï¼Œç»§ç»­è°ƒç”¨ <code>ReadFutrue</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œé‡å¤ä¸Šè¿°çš„æ‰§è¡Œæµç¨‹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task"><a class="header" href="#task">task</a></h1>
<p><code>Task</code> æ˜¯å¯¹ <code>async fn</code> æˆ–è€… <code>async {}</code> åˆ›å»ºçš„ <code>Non-Leaf Future</code> çš„æŠ½è±¡ï¼Œä¸€ä¸ª <code>task</code> å°±ä»£è¡¨ä¸€ä¸ªå¼‚æ­¥æ‰§è¡Œçš„ä»»åŠ¡ï¼š</p>
<pre><code class="language-rust noplayground">#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub(crate) struct TaskId(u64);

impl TaskId {
    pub(crate) fn new() -&gt; Self {
        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
        TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed))
    }
}

pub(crate) struct Task {
    id: TaskId,
    future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt;&gt;,
    task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
<p><code>Task</code> ä¸­æœ‰ä¸‰ä¸ªå­—æ®µï¼š</p>
<ul>
<li>
<p><code>id</code>ï¼šæ¯ä¸ª <code>task</code> éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„ <code>TaskId</code>ï¼Œ<code>TaskId</code> æ˜¯æœ‰å¯èƒ½åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­åˆ›å»ºçš„ï¼Œå› æ­¤ä½¿ç”¨åŸå­ç±»å‹ <code>AtomicU64</code> æ¥åˆ›å»º <code>TaskId</code> çš„å®ä¾‹ï¼Œä¿è¯å”¯ä¸€æ€§ã€‚</p>
</li>
<li>
<p><code>future</code>ï¼šå¯¹ç”¨æˆ·åˆ›å»ºçš„ <code>Non-Leaf Future</code> çš„åŒ…è£…ï¼Œä½¿ç”¨ <code>Pin</code> çš„ç›®çš„æ˜¯ä¸ºäº†å®‰å…¨åœ°ä½¿ç”¨è‡ªå¼•ç”¨ç»“æ„ï¼ˆ<code>Future</code> ç”Ÿæˆçš„çŠ¶æ€æœºä¸­å¯èƒ½å­˜åœ¨è‡ªå¼•ç”¨ç»“æ„ï¼‰ï¼Œä½¿ç”¨ <code>Mutex</code> çš„ç›®çš„ç¨åè®²è§£ã€‚</p>
</li>
<li>
<p><code>task_sender</code>ï¼šä¸€ä¸ª <code>channel</code> çš„å‘é€ç«¯ï¼Œå‘é€çš„ item æ˜¯ <code>Arc&lt;Task&gt;</code>ï¼Œä¹‹æ‰€ä»¥ä½¿ç”¨ <code>Arc&lt;Task&gt;</code> ä¸€æ–¹é¢æ˜¯æƒ³è¦å‡å°å…‹éš† <code>Task</code> çš„å¼€é”€ï¼Œå¦ä¸€æ–¹é¢ä¸ <code>Waker</code> çš„å®ç°æœºåˆ¶æœ‰å…³ï¼ˆç¨åè®²è§£ï¼‰ã€‚</p>
</li>
</ul>
<h2 id="æ–¹æ³•å®ç°-1"><a class="header" href="#æ–¹æ³•å®ç°-1">æ–¹æ³•å®ç°</a></h2>
<pre><code class="language-rust noplayground">impl Task {
    pub(crate) fn new(
        future: impl Future&lt;Output = ()&gt; + 'static + Send,
        task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
    ) -&gt; Self {
        Task {
            id: TaskId::new(),
            future: Mutex::new(Box::pin(future)),
            task_sender,
        }
    }

    pub(crate) fn task_id(&amp;self) -&gt; TaskId {
        self.id
    }

    pub(crate) fn poll(&amp;self, context: &amp;mut Context) -&gt; Poll&lt;()&gt; {
        self.future
            .lock()
            .expect(&quot;get lock failed&quot;)
            .as_mut()
            .poll(context)
    }
}</code></pre>
<p><code>new</code> æ–¹æ³•ä¸­ä¼ å…¥å‚æ•° <code>future</code> å’Œ <code>task_sender</code> ååˆ›å»ºä¸€ä¸ª <code>Task</code> å®ä¾‹ï¼š</p>
<ul>
<li>å‚æ•° <code>Future</code> è¦æ±‚æ»¡è¶³ <code>'static</code> ç”Ÿå‘½å‘¨æœŸæ˜¯å› ä¸º <code>task</code> çš„å­˜åœ¨æ—¶é—´å¯èƒ½æ˜¯ä»»æ„é•¿çš„ï¼Œå› æ­¤éœ€è¦ <code>Future</code> å…·æœ‰é™æ€ç”Ÿå‘½å‘¨æœŸã€‚</li>
<li>è¦æ±‚ <code>Future</code> æ»¡è¶³ <code>Send</code> æ˜¯å› ä¸º <code>Task</code> éœ€è¦è·¨çº¿ç¨‹å‘é€ã€‚</li>
<li>ç”±äº <code>Future</code> æœ€ç»ˆä½¿ç”¨ <code>Mutex</code> åŒ…äº†èµ·æ¥ï¼Œå› æ­¤ <code>future</code> å­—æ®µæœ€ç»ˆåŒæ—¶æ»¡è¶³ <code>Send + Sync + 'static</code>ã€‚</li>
<li><code>Task</code> çš„å…¶ä»–ä¸¤ä¸ªå­—æ®µä¹Ÿæ»¡è¶³ <code>Send + Sync + 'static</code> ï¼Œå› æ­¤ <code>Task</code> æ»¡è¶³ <code>Send + Sync + 'static</code>ã€‚</li>
</ul>
<p>ç”±äº <code>task_sender</code> å‘é€çš„ item æ˜¯ <code>Arc&lt;Task&gt;</code>ï¼Œ<code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­æ”¶åˆ°çš„ä¹Ÿæ˜¯ <code>Arc&lt;Task&gt;</code>ï¼Œå› æ­¤ <code>poll</code> æ–¹æ³•çš„å®šä¹‰ä¸­åªèƒ½ä½¿ç”¨ <code>&amp;self</code> ä¸å˜å¼•ç”¨ã€‚</p>
<p>åˆå› ä¸º <code>Future</code> çš„ <code>poll</code> æ–¹æ³•è°ƒç”¨éœ€è¦å¯å˜å¼•ç”¨ï¼Œä¸ºäº†å®ç°å†…éƒ¨å¯å˜æ€§ï¼Œæˆ‘ä»¬å°±ç”¨ <code>Mutex</code> æŠŠ <code>Pin&lt;Box&lt;Future&gt;&gt;</code> åŒ…äº†èµ·æ¥ï¼Œè¿™å°±æ˜¯ä½¿ç”¨ <code>Mutex</code> çš„åŸå› ã€‚</p>
<p>åœ¨ <code>poll</code> æ–¹æ³•ä¸­ï¼Œé¦–å…ˆè°ƒç”¨ <code>self.future.lock()</code> è·å–é”ï¼Œç„¶åå°†è°ƒç”¨ <code>.as_mut()</code> æ–¹æ³•è·å– <code>Pin&lt;&amp;mut dyn Future&gt;</code>ï¼Œæœ€åå†è°ƒç”¨ <code>Future</code> ä¸­çš„ <code>poll</code> æ–¹æ³•æ‰§è¡Œ <code>Future</code>ã€‚</p>
<h2 id="å®ç°-wake-trait"><a class="header" href="#å®ç°-wake-trait">å®ç° Wake trait</a></h2>
<p>ä¸º <code>Task</code> å®ç° <code>Wake trait</code>ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ <code>Task</code> æ¥æ„å»ºä¸€ä¸ª <code>Waker</code>ï¼š</p>
<pre><code class="language-rust noplayground">impl Wake for Task {
    fn wake(self: Arc&lt;Self&gt;) {
        self.task_sender
            .send(self.clone())
            .expect(&quot;send task failed&quot;);
    }

    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) {
        self.task_sender
            .send(self.clone())
            .expect(&quot;send task failed&quot;);
    }
}</code></pre>
<p><code>Wake</code> ä¸­çš„ <code>wake/wake_by_ref</code> æ–¹æ³•å®ç°å°±æ˜¯å…·ä½“çš„å”¤é†’ <code>task</code> çš„æœºåˆ¶ï¼Œåœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œæˆ‘ä»¬æŠŠæƒ³è¦å”¤é†’çš„ <code>task</code> é€šè¿‡ <code>task_sender</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œè¿™æ · <code>executor</code> å°±å¯ä»¥æ‰§è¡Œè¿™ä¸ª <code>task</code> äº†ï¼Œè¿™ä¹Ÿæ˜¯åœ¨ <code>Task</code> å®šä¹‰ä¸­ï¼Œéœ€è¦ <code>task_sender</code> å­—æ®µçš„åŸå› ã€‚</p>
<p>æ­¤å¤–ï¼Œ<code>wake/wake_by_ref</code> æ–¹æ³•ä¸­éƒ½éœ€è¦ <code>Arc&lt;Task&gt;</code>ï¼Œè¿™æ˜¯ <code>task_sender</code> çš„ item ç±»å‹ä¸º <code>Arc&lt;Task&gt;</code> çš„åŸå› ä¹‹ä¸€ã€‚</p>
<h2 id="æ„é€ -waker"><a class="header" href="#æ„é€ -waker">æ„é€  Waker</a></h2>
<p>å¯¹äºå®ç°äº† <code>Wake trait</code> çš„ <code>Task</code>ï¼Œå¯ä»¥ä½¿ç”¨  <code>std::task::Waker</code> çš„ <code>from</code> æ–¹æ³•æ„é€ ä¸€ä¸ª <code>Waker</code>ï¼š</p>
<pre><code class="language-rust noplayground">impl&lt;W: Wake + Send + Sync + 'static&gt; From&lt;Arc&lt;W&gt;&gt; for Waker {
    fn from(waker: Arc&lt;W&gt;) -&gt; Waker {}
}</code></pre>
<p>é€šè¿‡å‰é¢çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“ <code>Task</code> å·²ç»åŒæ—¶æ»¡è¶³ <code>Wake + Send + Sync + 'static</code>ï¼Œå› æ­¤å¯ä»¥å®‰å…¨åœ°ä½¿ç”¨ <code>from</code> æ–¹æ³•æ„é€ ä¸€ä¸ª <code>Waker</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">executor</a></h1>
<h2 id="executor-1"><a class="header" href="#executor-1">Executor</a></h2>
<pre><code class="language-rust noplayground">pub struct Executor {
    task_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
    waker_cache: BTreeMap&lt;TaskId, Waker&gt;,
}</code></pre>
<p><code>task_queue</code> æ˜¯ä¸€ä¸ª <code>channel</code> çš„æ¥æ”¶ç«¯ï¼Œå½“ <code>spawn</code> æˆ–è€… <code>wake</code> ä¸€ä¸ª <code>task</code> æ—¶ï¼Œå°±ä¼šå‘é€ <code>Arc&lt;Task&gt;</code> åˆ° <code>task_queue</code> ä¸­ã€‚</p>
<p><code>waker_cache</code> ä½¿ç”¨ <code>BTreeMap</code> ç¼“å­˜å¯èƒ½ä¼šé‡å¤ä½¿ç”¨çš„ <code>Waker</code>ï¼Œè¿™æ˜¯ä¸ºäº†å‡å°æ„é€  <code>Waker</code> çš„å¼€é”€ã€‚</p>
<blockquote>
<p>å®é™…ä¸Šï¼Œ<code>Executor</code> ä¸­çš„ <code>task_queue</code> åªæ˜¯ä¸€ä¸ªç®¡é“çš„æ¥æ”¶ç«¯ï¼Œå¹¶ä¸æ˜¯é˜Ÿåˆ—ï¼Œåªæ˜¯æˆ‘ä¸ªäººæ›´ä¹ æƒ¯ç§°ä¹‹ä¸ºé˜Ÿåˆ—ã€‚</p>
</blockquote>
<h3 id="æ–¹æ³•å®ç°-2"><a class="header" href="#æ–¹æ³•å®ç°-2">æ–¹æ³•å®ç°</a></h3>
<pre><code class="language-rust noplayground">impl Executor {
    fn new(task_queue: Receiver&lt;Arc&lt;Task&gt;&gt;) -&gt; Self {
        Self {
            task_queue,
            waker_cache: BTreeMap::new(),
        }
    }

    fn run_ready_task(&amp;mut self) {
        while let Ok(task) = self.task_queue.recv() {
            let waker = self
                .waker_cache
                .entry(task.task_id())
                .or_insert_with(|| Waker::from(task.clone()));

            let mut context = Context::from_waker(waker);
            match task.poll(&amp;mut context) {
                Poll::Ready(_) =&gt; {
                    self.waker_cache.remove(&amp;task.task_id());
                }
                Poll::Pending =&gt; {}
            }
        }
    }

    pub fn run(&amp;mut self) {
        self.run_ready_task();
    }
}</code></pre>
<p><code>new</code> æ–¹æ³•æ¥æ”¶ <code>Receiver&lt;Arc&lt;Task&gt;&gt;</code> å‚æ•°ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ‰§è¡Œå™¨å®ä¾‹ã€‚</p>
<p><code>run_ready_task</code> æ–¹æ³•ä¸­ï¼š</p>
<ul>
<li>
<p>ä» <code>task_queue</code> ä¸­æ¥æ”¶ <code>task: Arc&lt;Task&gt;</code>ï¼Œç„¶åä» <code>waker_cache</code> ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å¯¹åº”çš„ <code>waker</code>ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ„é€ ä¸€ä¸ª <code>Waker</code>ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>Context</code> çš„ <code>from_waker</code> æ–¹æ³•é€šè¿‡ <code>waker</code> çš„å¼•ç”¨åˆ›å»º <code>context</code>ã€‚</p>
</li>
<li>
<p>è°ƒç”¨ <code>task</code> çš„ <code>poll</code> æ–¹æ³•ï¼Œä¼ å…¥ <code>&amp;mut context</code> å‚æ•°ï¼Œå¼€å§‹æ‰§è¡Œ<code>task</code>ã€‚</p>
<ul>
<li>å¦‚æœè¿”å›çš„æ˜¯ <code>Poll::Ready</code>ï¼Œè¯´æ˜ <code>task</code> æ‰§è¡Œå®Œæ¯•ï¼Œä» <code>waker_cache</code> ä¸­åˆ é™¤ç¼“å­˜çš„ <code>waker</code>ã€‚</li>
<li>å¦‚æœè¿”å›çš„æ˜¯ <code>Poll::Pending</code>ï¼Œåˆ™ä»€ä¹ˆéƒ½ä¸åšï¼ˆæœ€ç»ˆæ‰§è¡Œçš„ <code>Leaf-Future</code> ä¸­ä¼šæ³¨å†Œç­‰å¾…çš„äº‹ä»¶å’Œ <code>waker</code>ï¼‰ã€‚</li>
</ul>
</li>
</ul>
<h2 id="spawner"><a class="header" href="#spawner">Spawner</a></h2>
<p>åœ¨åˆå§‹çŠ¶æ€ä¸‹ï¼Œ<code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­æ˜¯ç©ºçš„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æœºåˆ¶èƒ½å¤Ÿè®©ç”¨æˆ·æ‰‹åŠ¨åœ°åˆ›å»º <code>task</code> å¹¶å°† <code>task</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œæœ€åå¼€å¯ <code>executor</code> çš„æ‰§è¡Œã€‚<code>Spawner</code> æŠ½è±¡ä¾¿æä¾›äº†è¿™ç§æœºåˆ¶ï¼š</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
pub struct Spawner {
    task_sender: Sender&lt;Arc&lt;Task&gt;&gt;,
}</code></pre>
<p><code>Spawner</code> ä¸­çš„ <code>task_sender</code> å’Œ <code>Task</code> çš„ <code>task_sender</code> ä¸€æ ·ï¼Œéƒ½æ˜¯ä¸ºäº†æŠŠ <code>task</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ã€‚</p>
<h3 id="æ–¹æ³•å®ç°-3"><a class="header" href="#æ–¹æ³•å®ç°-3">æ–¹æ³•å®ç°</a></h3>
<pre><code class="language-rust noplayground">impl Spawner {
    fn new(task_sender: Sender&lt;Arc&lt;Task&gt;&gt;) -&gt; Self {
        Self { task_sender }
    }

    pub fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let task = Task::new(future, self.task_sender.clone());
        self.task_sender
            .send(Arc::new(task))
            .expect(&quot;send task failed&quot;);
    }
}</code></pre>
<p><code>new</code> æ–¹æ³•æ¥æ”¶<code>Sender&lt;Arc&lt;Task&gt;&gt;</code> å‚æ•°ï¼Œç„¶ååˆ›å»ºä¸€ä¸ª <code>Spawner</code> å®ä¾‹ã€‚</p>
<p><code>spawn</code> æ–¹æ³•ä¸­ï¼Œä½¿ç”¨ä¼ å…¥çš„  <code>future</code>  å‚æ•°åˆ›å»ºä¸€ä¸ª <code>Task</code> å®ä¾‹ï¼Œç„¶åæŠŠè¿™ä¸ª <code>task</code> å‘é€åˆ° <code>executor</code> çš„æ‰§è¡Œé˜Ÿåˆ—ä¸­ã€‚å½“ <code>executor</code> å¼€å§‹æ‰§è¡Œçš„æ—¶å€™å°±å¯ä»¥ä»é˜Ÿåˆ—ä¸­æ¥æ”¶ <code>task</code>ï¼Œé©±åŠ¨ <code>task</code> çš„æ‰§è¡Œäº†ã€‚</p>
<h2 id="åˆ›å»º-spawner--executor"><a class="header" href="#åˆ›å»º-spawner--executor">åˆ›å»º Spawner &amp; Executor</a></h2>
<p>å®šä¹‰ä¸€ä¸ªå…¬å¼€çš„å‡½æ•°ï¼Œåˆ›å»º <code>Spawner</code> å’Œ <code>Executor</code> å®ä¾‹ï¼š</p>
<pre><code class="language-rust noplayground">pub fn spawner_and_executor() -&gt; (Spawner, Executor) {
    let (task_sender, task_queue) = bounded(10000);
    let spawner = Spawner::new(task_sender);
    let executor = Executor::new(task_queue);
    (spawner, executor)
}</code></pre>
<p>åœ¨ <code>spawner_and_executor</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ <code>crossbeam-channel</code> æä¾›çš„ <code>unbounded</code> å‡½æ•°åˆ›å»ºä¸€ä¸ªå®¹é‡ä¸º 10000 çš„ç®¡é“ï¼Œåˆ†åˆ«è¿”å›ç®¡é“çš„å‘é€ç«¯å’Œæ¥æ”¶ç«¯ï¼Œç„¶ååˆ›å»º <code>Spawner</code> å’Œ <code>Executor</code> å®ä¾‹å¹¶è¿”å›ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">example</a></h1>
<p>åœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¹‹å‰å®ç°çš„å¼‚æ­¥è¿è¡Œæ—¶åˆ›å»ºä¸€ä¸ª <code>tcp echo server</code>ã€‚éœ€è¦å¯¼å…¥çš„æ¨¡å—å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code class="language-rust noplayground">use std::env;
use std::io::Write;

use log::info;

use async_runtime::async_io::{Ipv4Addr, TcpListener, TcpStream};
use async_runtime::executor::{spawner_and_executor, Spawner};</code></pre>
<h2 id="æ—¥å¿—æ‰“å°"><a class="header" href="#æ—¥å¿—æ‰“å°">æ—¥å¿—æ‰“å°</a></h2>
<pre><code class="language-rust noplayground">fn init_log() {
    // format = [file:line] msg
    env::set_var(&quot;RUST_LOG&quot;, &quot;info&quot;);
    env_logger::Builder::from_default_env()
        .format(|buf, record| {
            writeln!(
                buf,
                &quot;[{}:{:&gt;3}] {}&quot;,
                record.file().unwrap_or(&quot;unknown&quot;),
                record.line().unwrap_or(0),
                record.args(),
            )
        })
        .init();
}</code></pre>
<p><code>init_log</code> å‡½æ•°æ˜¯ä¸ºäº†è®¾ç½®æ—¥å¿—æ‰“å°çš„æ¶ˆæ¯æ ¼å¼ï¼Œè¿™è·Ÿå¼‚æ­¥è¿è¡Œæ—¶çš„ä½¿ç”¨æ²¡å•¥å…³ç³»ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚</p>
<h2 id="handle_client"><a class="header" href="#handle_client">handle_client</a></h2>
<pre><code class="language-async">async fn handle_client(stream: TcpStream) {
    let mut buf = [0u8; 1024];
    info!(&quot;(handle client) {}&quot;, stream.raw_fd());
    loop {
        let n = stream.read(&amp;mut buf).await.unwrap();
        if n == 0 {
            break;
        }
        stream.write(&amp;buf[..n]).await.unwrap();
    }
}
</code></pre>
<p>åœ¨ <code>handle_client</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆåˆ›å»ºä¸€ä¸ª <code>buf</code> æ•°ç»„ï¼Œç„¶åæ‰“å°ä¸€ä¸ª <code>handle client</code> çš„æ—¥å¿—æ¶ˆæ¯ï¼Œæ¥ç€å¼€å¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼š</p>
<ul>
<li>
<p>è°ƒç”¨ <code>stream.read(&amp;mut buf)</code> æ–¹æ³•åä¼šè¿”å›ä¸€ä¸ª <code>ReadFuture</code>ï¼Œåœ¨ <code>ReadFuture</code> ä¸Šè°ƒç”¨ <code>await</code> æ–¹æ³•ï¼š</p>
<ul>
<li>
<p><code>ReadFuture.await</code> ä¼šå±•å¼€æˆä¸€ä¸ªæ— é™å¾ªç¯ï¼Œåœ¨å¾ªç¯å†…éƒ¨ä¼šè°ƒç”¨ <code>ReadFuture</code> çš„ <code>poll</code> æ–¹æ³•ã€‚</p>
</li>
<li>
<p>å¦‚æœè¿”å› <code>Poll::Pending</code>ï¼Œåˆ™ä½¿ç”¨ <code>Yield</code> è¡¨è¾¾å¼æŒ‚èµ·å½“å‰çš„ <code>task</code>ï¼›</p>
</li>
<li>
<p>å¦‚æœè¿”å› <code>poll::Ready</code> åˆ™ä¸­æ–­å¾ªç¯å¹¶è¿”å›ç»“æœã€‚</p>
</li>
</ul>
</li>
<li>
<p>å¦‚æœ <code>n== 0</code>ï¼Œåˆ™è¯´æ˜å®¢æˆ·ç«¯å·²ç»æ–­å¼€äº†è¿æ¥ï¼Œåˆ™é€€å‡ºå¾ªç¯ã€‚</p>
</li>
<li>
<p>è°ƒç”¨ <code>stream.write(&amp;mut buf[.n])</code> ä¼šè¿”å›ä¸€ä¸ª <code>WriteFuture</code>ï¼Œåœ¨ <code>WriteFuture</code> ä¸Šè°ƒç”¨ <code>await</code> æ–¹æ³•åæ‰§è¡Œæµç¨‹ä¸ <code>ReadFuture</code> ä¸€è‡´ã€‚</p>
</li>
</ul>
<h2 id="server_loop"><a class="header" href="#server_loop">server_loop</a></h2>
<pre><code class="language-rust noplayground">async fn server_loop(spawner: Spawner) {
    let addr = Ipv4Addr::new(127, 0, 0, 1);
    let port = 8080;
    let listener = TcpListener::bind(addr, port).unwrap();

    let incoming = listener.incoming();

    while let Some(stream) = incoming.next().await {
        let stream = stream.unwrap();
        spawner.spawn(handle_client(stream));
    }
}</code></pre>
<p>åœ¨ <code>server_loop</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨ <code>TcpListener</code> çš„ <code>bind</code> æ–¹æ³•åˆ›å»ºä¸€ä¸ª <code>TcpListener</code> å®ä¾‹ï¼Œç„¶åè°ƒç”¨ <code>incoming</code> æ–¹æ³•åˆ›å»ºä¸€ä¸ª <code>Incoming</code> å®ä¾‹ã€‚</p>
<p>æ¥ç€ï¼Œåœ¨ <code>While let</code> å¾ªç¯ä¸­ï¼Œè°ƒç”¨ <code>incoming</code> çš„ <code>next</code> æ–¹æ³•è¿”å›ä¸€ä¸ª <code>AcceptFuture</code> å®ä¾‹ï¼Œåœ¨ <code>AcceptFuture</code> ä¸Šè°ƒç”¨ <code>await</code> æ–¹æ³•åï¼Œå¦‚æœè¿”å›çš„ <code>Poll::Pending</code>ï¼Œåˆ™æŒ‚èµ·å½“å‰çš„ <code>task</code>ã€‚</p>
<p>å½“æœ‰å®¢æˆ·ç«¯è¿æ¥åˆ°æ¥æ—¶ï¼Œ<code>AcceptFuture</code> ç­‰å¾…çš„ IO äº‹ä»¶å°±ç»ªï¼Œä¼šè¿”å› <code>io::Readult&lt;TcpStream&gt;</code> çš„å®ä¾‹å¹¶ç»‘å®šåˆ° <code>stream</code> å˜é‡ä¸Šï¼Œæ¥ç€ä½¿ç”¨ <code>spawner</code> è°ƒç”¨ <code>spawn</code> æ–¹æ³•åˆ›å»ºä¸€ä¸ª <code>task</code> å¤„ç†ä¸å®¢æˆ·ç«¯çš„äº¤äº’ã€‚</p>
<p>æœ€åï¼Œåˆè¿›å…¥å¾ªç¯çš„å¼€å§‹ä½ç½®ï¼Œç»§ç»­ç­‰å¾…æ–°çš„è¿æ¥åˆ°æ¥ã€‚</p>
<h2 id="main-å‡½æ•°"><a class="header" href="#main-å‡½æ•°">main å‡½æ•°</a></h2>
<pre><code class="language-rust noplayground">fn main() {
    init_log();

    let (spawner, mut executor) = spawner_and_executor();

    spawner.spawn(server_loop(spawner.clone()));

    executor.run();
}</code></pre>
<p>åœ¨ <code>main</code> å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè°ƒç”¨ <code>init_log</code> å‡½æ•°è®¾ç½®æ—¥å¿—æ¶ˆæ¯æ ¼å¼ï¼Œæ¥ç€ä½¿ç”¨ <code>spawner_and_executor</code> å‡½æ•°åˆ›å»º <code>Spawner</code> å’Œ <code>Executor</code> çš„å®ä¾‹ã€‚</p>
<p>ç„¶åè°ƒç”¨ <code>spawner.spawn</code> æ–¹æ³•åˆ›å»ºä¸€ä¸ª <code>task</code> ç”¨äºæ‰§è¡Œ <code>server_loop</code>ã€‚</p>
<p>æœ€åè°ƒç”¨ <code>executor.run()</code> æ–¹æ³•å¼€å¯ <code>executor</code> çš„è¿è¡Œï¼Œå¼€å§‹è°ƒåº¦æ‰§è¡Œå„ä¸ª <code>task</code>ã€‚</p>
<h2 id="è¿è¡Œç¤ºä¾‹"><a class="header" href="#è¿è¡Œç¤ºä¾‹">è¿è¡Œç¤ºä¾‹</a></h2>
<p>å¼€å¯è¿è¡Œåçš„ <code>echo server</code> ä¼šç›‘å¬åœ°å€ï¼š<code>127.0.0.1:8080</code>ï¼š</p>
<pre><code class="language-rust noplayground">cargo run --example echo_server
    Finished dev [unoptimized + debuginfo] target(s) in 0.69s
     Running `target/debug/examples/echo_server`
[src/async_io.rs: 56] (TcpListener) listen: 3
[src/reactor.rs: 27] (Reactor) add event: 3
[src/reactor.rs: 35] Start reactor main loop</code></pre>
<p>ä½¿ç”¨ <code>Python</code> å†™ä¸€ä¸ªå°è„šæœ¬æ¨¡æ‹Ÿ <code>TCP</code> å®¢æˆ·ç«¯ï¼š</p>
<pre><code class="language-python">import socket
import threading

HOST = '127.0.0.1'
PORT = 8080


def send_request():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    for i in range(1, 1025):
        s.send(f&quot;HELLO WORLD[{i}]&quot;.encode())
        data = s.recv(1024).decode()
        print(f&quot;RECEIVE DATA: '{data}' in THREAD[{threading.currentThread().name}]&quot;)
    s.close()


def main():
    t_lst = []
    for _ in range(10):
        t = threading.Thread(target=send_request)
        t_lst.append(t)
        t.start()

    for t in t_lst:
        t.join()


if __name__ == '__main__':
    main()
</code></pre>
<p>è¿è¡Œè„šæœ¬ï¼ŒæœåŠ¡ç«¯ä¼šè¾“å‡ºä»¥ä¸‹å†…å®¹ï¼š</p>
<pre><code>.....
.....
.....
[src/reactor.rs: 43] (Reactor) wake up. nfd = 2
[src/reactor.rs: 49] (Reactor) delete event: 6
[src/reactor.rs: 49] (Reactor) delete event: 7
[src/reactor.rs: 43] (Reactor) wake up. nfd = 3
[src/reactor.rs: 49] (Reactor) delete event: 9
[src/reactor.rs: 27] (Reactor) add event: 6
[src/reactor.rs: 49] (Reactor) delete event: 10
[src/reactor.rs: 49] (Reactor) delete event: 11
[src/reactor.rs: 43] (Reactor) wake up. nfd = 2
</code></pre>
<p>å®¢æˆ·ç«¯çš„è¾“å‡ºå†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><code>.....
.....
.....
RECEIVE DATA: 'HELLO WORLD[1022]' in THREAD[Thread-3]
RECEIVE DATA: 'HELLO WORLD[1015]' in THREAD[Thread-7]
RECEIVE DATA: 'HELLO WORLD[1013]' in THREAD[Thread-6]
RECEIVE DATA: 'HELLO WORLD[1021]' in THREAD[Thread-1]
RECEIVE DATA: 'HELLO WORLD[1023]' in THREAD[Thread-3]
RECEIVE DATA: 'HELLO WORLD[1008]' in THREAD[Thread-10]
RECEIVE DATA: 'HELLO WORLD[1014]' in THREAD[Thread-6]
RECEIVE DATA: 'HELLO WORLD[1016]' in THREAD[Thread-7]
</code></pre>
<p>å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬çš„ <code>echo server</code> æ­£ç¡®åœ°è¿”å›äº†å“åº”ï¼Œ<code>wake up. nfd = 3</code> è¡¨ç¤ºæœ‰3ä¸ªäº‹ä»¶åŒæ—¶å°±ç»ªï¼Œè¿™è¯´æ˜ <code>server</code> ç¡®å®åœ¨å¹¶å‘åœ°å¤„ç†å¤šä¸ªè¯·æ±‚ï¼</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
