<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pin - async in rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A book which aims to introduce the theory and mechanism of async/await syntax and async runtime in the Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../异步编程.html"><strong aria-hidden="true">2.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="../async-await.html"><strong aria-hidden="true">3.</strong> async/await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async-await/async-await的使用.html"><strong aria-hidden="true">3.1.</strong> async/await 的使用</a></li><li class="chapter-item expanded "><a href="../async-await/Future-trait.html"><strong aria-hidden="true">3.2.</strong> Future trait</a></li><li class="chapter-item expanded "><a href="../async-await/Generator.html"><strong aria-hidden="true">3.3.</strong> Generator</a></li><li class="chapter-item expanded "><a href="../async-await/状态机.html"><strong aria-hidden="true">3.4.</strong> 状态机</a></li><li class="chapter-item expanded "><a href="../async-await/Pin.html" class="active"><strong aria-hidden="true">3.5.</strong> Pin</a></li></ol></li><li class="chapter-item expanded "><a href="../IO模型.html"><strong aria-hidden="true">4.</strong> IO 模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO模型/阻塞IO.html"><strong aria-hidden="true">4.1.</strong> 阻塞 IO</a></li><li class="chapter-item expanded "><a href="../IO模型/非阻塞IO.html"><strong aria-hidden="true">4.2.</strong> 非阻塞 IO</a></li><li class="chapter-item expanded "><a href="../IO模型/信号驱动IO.html"><strong aria-hidden="true">4.3.</strong> 信号驱动 IO</a></li><li class="chapter-item expanded "><a href="../IO模型/IO多路复用.html"><strong aria-hidden="true">4.4.</strong> IO 多路复用</a></li><li class="chapter-item expanded "><a href="../IO模型/异步IO.html"><strong aria-hidden="true">4.5.</strong> 异步 IO</a></li></ol></li><li class="chapter-item expanded "><a href="../Epoll.html"><strong aria-hidden="true">5.</strong> Epoll</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Epoll/Epoll介绍.html"><strong aria-hidden="true">5.1.</strong> Epoll 介绍</a></li><li class="chapter-item expanded "><a href="../Epoll/Epoll-server-example.html"><strong aria-hidden="true">5.2.</strong> Epoll server example</a></li></ol></li><li class="chapter-item expanded "><a href="../异步运行时.html"><strong aria-hidden="true">6.</strong> 异步运行时</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../异步运行时/epoll.html"><strong aria-hidden="true">6.1.</strong> epoll</a></li><li class="chapter-item expanded "><a href="../异步运行时/reactor.html"><strong aria-hidden="true">6.2.</strong> reactor</a></li><li class="chapter-item expanded "><a href="../异步运行时/async_io.html"><strong aria-hidden="true">6.3.</strong> async_io</a></li><li class="chapter-item expanded "><a href="../异步运行时/task.html"><strong aria-hidden="true">6.4.</strong> task</a></li><li class="chapter-item expanded "><a href="../异步运行时/executor.html"><strong aria-hidden="true">6.5.</strong> executor</a></li><li class="chapter-item expanded "><a href="../异步运行时/example.html"><strong aria-hidden="true">6.6.</strong> example</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async in rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/night-cruise/async-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pin"><a class="header" href="#pin">Pin</a></h1>
<p>前文的 <code>Future trait</code>、<code>Geneartor</code> 和状态机中都出现了 <code>Pin</code>，那么 <code>Pin</code> 到底有什么用呢？ 在本节中，我们将会详细地介绍它。</p>
<h2 id="自引用结构"><a class="header" href="#自引用结构">自引用结构</a></h2>
<p>在 Safe Rust 中，我们无法创建自引用结构体：</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let s = &quot;Hello World&quot;.to_string();
    let _ = SelfReference {
        a: s,
        b: &amp;s
    };
}

struct SelfReference&lt;'a&gt; {
	a: String,
	b: &amp;'a String
}</code></pre></pre>
<p>如果编译，将会发生报错：</p>
<pre><code class="language-rust noplayground">error[E0382]: borrow of moved value: `s`
 --&gt; src/main.rs:5:12
  |
2 |     let s = &quot;Hello World&quot;.to_string();
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     let _ = SelfReference {
4 |         a: s,
  |            - value moved here
5 |         b: &amp;s
  |            ^^ value borrowed here after move</code></pre>
<p>这是因为 <code>s</code> 已经发生了 <code>move</code>，因此 <code>b</code> 就不能借用已经 <code>move</code> 了的 <code>s</code>。</p>
<p>为了创建自引用结构，我们需要使用裸指针：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(&amp;mut self) {
        let ptr_to_a = &amp;self.a as *const _;
        self.b = ptr_to_a;
    }
    
    fn get_a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }
    
    fn get_b(&amp;self) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>编译运行，结果如下所示：</p>
<pre><code class="language-rust noplayground">sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }</code></pre>
<p>接下来，让我们交换 <code>sr_1</code> 和 <code>sr_2</code> 的内存位置的数据，即 <code>sr_1</code> 和 <code>sr_2</code> 互相 <code>move</code> 给对方：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    sr_1.init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    sr_2.init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
    
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    println!(&quot;\nAfter swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.get_a(), sr_1.get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.get_a(), sr_2.get_b());
}

<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	 a: String,
</span><span class="boring">	 b: *const String
</span><span class="boring">}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   } 
</span><span class="boring">   fn init(&amp;mut self) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       self.b = ptr_to_a;
</span><span class="boring">   }   
</span><span class="boring">   fn get_a(&amp;self) -&gt; &amp;str {
</span><span class="boring">       &amp;self.a
</span><span class="boring">   }    
</span><span class="boring">   fn get_b(&amp;self) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译运行，结果如下所示：</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<p>可以看出，在交换 <code>sr_1</code> 和 <code>sr_2</code>  后，字段 <code>a</code> 的数据也发生了交换，但是字段 <code>b</code> 的数据没有改变，仍然指向之前的位置，如图所示：</p>
<p><img src="../imgs/swap_problem.jpg" alt="swap problem" /></p>
<p>这意味着，<code>sr</code>（<code>sr_1</code>、<code>sr_2</code>）将不再是自引用结构体，并保存了一个指向其他对象的裸指针。因此，<code>sr</code> 的字段 <code>b</code> 的生命周期将不再和其结构体本身相关联，我们将难以保证 <code>sr.b</code> 指针不会变成悬垂指针。</p>
<p>在上面的例子中，由于使用 <code>swap</code> 函数导致出现了我们不想要的结果，在后续的代码中对 <code>sr</code> 的使用很可能会出现段错误、UB 等其他类型的错误。</p>
<h2 id="lets-pin-it"><a class="header" href="#lets-pin-it">Let's pin it!</a></h2>
<p>Rust 是一门极为注重内存安全的语言，为了能够安全地使用自引用结构，Rust 发明了 <code>Pin</code>。</p>
<h3 id="pin-1"><a class="header" href="#pin-1">Pin</a></h3>
<p><code>Pin</code> 位于 <code>std</code> 库的 <code>pin</code> 模块中，源代码定义如下所示：</p>
<pre><code class="language-rust noplayground">#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
#[lang = &quot;pin&quot;]
#[fundamental]
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

#[stable(feature = &quot;pin&quot;, since = &quot;1.33.0&quot;)]
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}</code></pre>
<p><code>Pin</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code> <code>trait</code>，因此 <code>Pin</code> 是一个智能指针。并且 <code>Pin</code> 的内部包裹了另一个指针 <code>P</code>，因此我们一般使用 <code>Pin&lt;P&lt;T&gt;&gt;</code> 的方式来表示一个 <code>Pin</code> 结构（<code>T</code> 是指针 <code>P</code> 指向的类型）。</p>
<p>既然有 <code>Pin</code>，那么自然就有 <code>Unpin</code>，那么 <code>Unpin</code> 是什么呢？<code>Unpin</code> 是一个 <code>auto trait</code>，编译器会默认为所有的类型实现 <code>Unpin</code>，除非这些类型实现了 <code>!Unpin</code>。</p>
<p>要想获取 <code>Pin&lt;P&lt;T&gt;&gt;</code> 中 <code>T</code> 的可变引用 <code>&amp;mut T</code>，可以使用 <code>Pin</code> 提供的 <code>get_mut</code> 方法，这也是 <code>Pin</code> 提供的 <code>api</code> 中<strong>唯一</strong>可以<strong>安全地</strong>获取 <code>&amp;mut T</code> 的方法，其函数签名如下所示：</p>
<pre><code class="language-rust noplayground">pub fn get_mut(self) -&gt; &amp;'a mut T
where
    T: Unpin,</code></pre>
<p>发现了吗？要想安全地拿到 <code>&amp;mut T</code>，<code>T</code> 就必须实现 <code>Unpin</code>。如果 <code>T</code> 实现了 <code>!Unpin</code>，那么就不可能安全地拿到 <code>T</code> 的可变引用，我们自然也就无法使用 <code>std::mem::swap(x: &amp;mut T, y: &amp;mut T)</code> 等类似的函数 <code>move</code> <code>T</code>，就不会发生前文的例子中出现的未定义行为。</p>
<p>因此，<code>Pin&lt;P&lt;T&gt;&gt;</code> 利用 Rust 的类型系统保证：如果 <code>T</code> 实现了 <code>!Unpin</code>，那么就不可能在 Safe Rust 中获取 <code>T</code> 的可变引用。相反，如果 <code>T</code> 实现了 <code>Unpin</code>，那么 <code>Pin</code> 就仅仅是对 <code>P&lt;T&gt;</code> 的一层包装，我么可以随意地拿到 <code>&amp;mut T</code>。</p>
<p>接下来，我们将会使用 <code>Pin</code> 解决上面的那个例子中出现的问题。</p>
<h3 id="pin-to-stack"><a class="header" href="#pin-to-stack">Pin to stack</a></h3>
<p><code>Pin</code> 到栈上是指我们想要 <code>Pin</code> 住的值在栈上，使用 <code>Pin::new_unchecked</code> 函数把 <code>&amp;mut T</code> 包装成 <code>Pin&lt;&amp;mut T&gt;</code> 即可：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1 = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2 = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Self {
        Self {
            a: msg.to_string(),
            b: std::ptr::null()
        }
    }
    
    fn init(self: Pin&lt;&amp;mut Self&gt;) {
        let ptr_to_a = &amp;self.a as *const _;
        unsafe {
            self.get_unchecked_mut().b = ptr_to_a;
        }
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>此时代码将不会通过编译：</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:25
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:18:41
    |
18  |     std::mem::swap(sr_1.get_mut(), sr_2.get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>这说明当我们把 <code>&amp;mut SelfReference</code> <code>Pin</code> 到栈上之后，无法通过 <code>get_mut</code> 方法拿到 <code>&amp;mut SelfReference</code>，那么自然就无法使用 <code>swap</code> 函数，在编译阶段就保证了不会出现内存安全问题。</p>
<p><code>Pin::new_unchecked</code> 是一个 <code>unsafe</code> 函数，这是因为<strong>需要使用者自己遵守约定</strong>只使用 <code>Pin</code> 提供的 <code>api</code> 来获取并使用可变引用。</p>
<p>假如使用者提前 <code>drop</code> 掉 <code>Pin</code>，这样就可以直接获取 <code>T</code> 的可变引用，仍然会导致内存安全问题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    sr_1_pin.as_mut().init();
    
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    let mut sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    sr_2_pin.as_mut().init();
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
    
    drop(sr_1_pin);
    drop(sr_2_pin);
    

    println!(&quot;\nAfter swap:&quot;);
    std::mem::swap(&amp;mut sr_1, &amp;mut sr_2);
    
    let sr_1_pin = unsafe { Pin::new_unchecked(&amp;mut sr_1) };
    let sr_2_pin = unsafe { Pin::new_unchecked(&amp;mut sr_2) };
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1_pin.as_ref().get_a(), sr_1_pin.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2_pin.as_ref().get_a(), sr_2_pin.as_ref().get_b());
}
<span class="boring">#[derive(Debug)]
</span><span class="boring">struct SelfReference {
</span><span class="boring">	a: String,
</span><span class="boring">	b: *const String
</span><span class="boring">}
</span><span class="boring">impl !Unpin for SelfReference {}
</span><span class="boring">impl SelfReference {
</span><span class="boring">   fn new(msg: &amp;str) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">           a: msg.to_string(),
</span><span class="boring">           b: std::ptr::null()
</span><span class="boring">       }
</span><span class="boring">   }    
</span><span class="boring">   fn init(self: Pin&lt;&amp;mut Self&gt;) {
</span><span class="boring">       let ptr_to_a = &amp;self.a as *const _;
</span><span class="boring">       unsafe {
</span><span class="boring">           self.get_unchecked_mut().b = ptr_to_a;
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       &amp;self.get_ref().a
</span><span class="boring">   }   
</span><span class="boring">   fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
</span><span class="boring">       unsafe {
</span><span class="boring">           &amp;*self.b
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}    </span></code></pre></pre>
<p>编译运行，将会出现和之前的例子中一样的问题：</p>
<pre><code class="language-rust noplayground">Before swap:
sr_1: { a: Hello, b: Hello }
sr_2: { a: World, b: World }

After swap:
sr_1: { a: World, b: Hello }
sr_2: { a: Hello, b: World }</code></pre>
<h3 id="pin-to-heap"><a class="header" href="#pin-to-heap">Pin to heap</a></h3>
<p><code>Pin</code> 到堆上是指把我们想要 <code>Pin</code> 住的值装箱到堆上面，使用<code>Box::pin</code> 函数即可把 <code>T</code> 包装成 <code>Pin&lt;Box&lt;T&gt;&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
use std::pin::Pin;

fn main() {
    let mut sr_1 = SelfReference::new(&quot;Hello&quot;);
    let mut sr_2 = SelfReference::new(&quot;World&quot;);
    
    println!(&quot;Before swap:&quot;);
    println!(&quot;sr_1: {{ a: {}, b: {} }}&quot;, sr_1.as_ref().get_a(), sr_1.as_ref().get_b());
    println!(&quot;sr_2: {{ a: {}, b: {} }}&quot;, sr_2.as_ref().get_a(), sr_2.as_ref().get_b());
    
    println!(&quot;If we want to swap:&quot;);
    std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    
}

#[derive(Debug)]
struct SelfReference {
	a: String,
	b: *const String
}

impl !Unpin for SelfReference {}

impl SelfReference {
    fn new(msg: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let sr = Self {
            a: msg.to_string(),
            b: std::ptr::null()
        };
        let mut boxed = Box::pin(sr);
        let ptr_to_a = &amp;boxed.a as *const _;
        unsafe {
            boxed.as_mut().get_unchecked_mut().b = ptr_to_a;
        }
        
        boxed
    }
    
    fn get_a(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        &amp;self.get_ref().a
    }
    
    fn get_b(self: Pin&lt;&amp;Self&gt;) -&gt; &amp;str {
        unsafe {
            &amp;*self.b
        }
    }
}</code></pre></pre>
<p>此时代码将不会通过编译：</p>
<pre><code class="language-rust noplayground">error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:34
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                  ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `SelfReference` cannot be unpinned
   --&gt; src/main.rs:13:59
    |
13  |     std::mem::swap(sr_1.as_mut().get_mut(), sr_2.as_mut().get_mut());
    |                                                           ^^^^^^^ the trait `Unpin` is not implemented for `SelfReference`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p><code>Pin</code> 到堆上的优点是不需要使用者编写 <code>unsafe</code> 函数来构造 <code>Pin</code>，也不需要使用者自己遵守约定只使用 <code>Pin</code> 提供的 <code>api</code> 来获取可变引用，因为 <code>Pin</code> 到堆上后，用户只能使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code>；缺点是 <code>Pin</code> 到堆上会有额外的性能开销。</p>
<h2 id="pin-and-async"><a class="header" href="#pin-and-async">Pin and async</a></h2>
<p>在前文中我们给出了 <code>Future</code> 和 <code>Generator</code> 的定义：</p>
<pre><code class="language-rust noplayground">pub trait Future {
    type Output;	
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub trait Generator&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(
        self: Pin&lt;&amp;mut Self&gt;, 
        arg: R
    ) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;
}</code></pre>
<p>还有将 <code>Generator</code> 转化为 <code>Future</code> 的函数：</p>
<pre><code class="language-rust noplayground">pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;
    where T: Generator&lt;ResumeTy, Yield = ()&gt;
{
    struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T);

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

    impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
        type Output = T::Return;
        
        fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
   
            match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
                GeneratorState::Yielded(()) =&gt; Poll::Pending,
                GeneratorState::Complete(x) =&gt; Poll::Ready(x),
            }
        }
    }

    GenFuture(gen)
}</code></pre>
<p>可以看到要调用 <code>Future</code> 的 <code>Poll</code> 方法和 <code>Generator</code> 的 <code>resume</code> 方法必须使用 <code>Pin&lt;&amp;mut Self&gt;</code> 才行。并且在 <code>from_generator</code> 函数中为 <code>GenFuture</code> 实现了 <code>!Unpin</code>。</p>
<p>经过前面的学习，我们知道为 <code>T</code> 实现了 <code>!Unpin</code> 后，就无法在 Safe Rust 中获取 <code>T</code> 的可变引用，而 Rust 会主动为 <code>Future</code> 实现 <code>!Unpin</code>，那么为什么 Rust 需要 <code>Pin</code> 住 <code>Future</code> 呢？</p>
<p>假设我们编写了一个生成器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

fn main(){
    let _gen = || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
}</code></pre></pre>
<p>编译后将会发生报错：</p>
<pre><code class="language-rust noplayground">error[E0626]: borrow may still be in use when generator yields
 --&gt; src/main.rs:6:26
  |
6 |         let borrowed_s = &amp;s;
  |                          ^^
7 |         
8 |         yield borrowed_s.len();
  |         ---------------------- possible yield occurs here
</code></pre>
<p>编译器提示我们生成器中存在跨 <code>yield</code> 借用，那么为什么编译器不允许跨 <code>yield</code> 借用呢？</p>
<p>想要知道原因，我们还要继续深入底层，上述的生成器会被编译成一个状态机：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = Gen::new();
    
    loop {
        match Pin::new(&amp;mut gen).resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}


impl&lt;R&gt; Generator&lt;R&gt; for Gen {
    type Yield = usize;
    type Return = ();
    
    fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
        let mut_gen = self.get_mut();
        match mut_gen {
            Gen::Enter =&gt; {
                let s = &quot;Hello World&quot;.to_string();
                let borrowed_s = &amp;s;
                let len = borrowed_s.len();
                
                *mut_gen = Gen::Yielded {
                    s,
                    borrowed_s: std::ptr::null()
                };
                if let Gen::Yielded { s, borrowed_s } = mut_gen {
                    *borrowed_s = s as *const _;
                }
                
                GeneratorState::Yielded(len)
            }
            Gen::Yielded{ borrowed_s, .. } =&gt; {
                let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
                println!(&quot;{}&quot;, borrowed_s);
                *mut_gen = Gen::Exit;
                
                GeneratorState::Complete(())
            }
            Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
        }
    }
}

impl Gen {
    fn new() -&gt; Self {
        Self::Enter
    }
}</code></pre></pre>
<p>编译上述代码，结果似乎就是我们所期待的：</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<p>从上述的代码中可以看出，<strong>生成的状态机中存在自引用结构</strong>。因此如果生成器中存在跨 <code>yield</code> 点借用，那么就可能产生内存安全问题，编译器干脆就禁止存在跨 <code>yield</code> 点借用的生成器通过编译。</p>
<p>例如，如果我们使用 <code>swap</code> 函数 <code>move</code> 生成器就可能发生异常：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(&amp;mut gen_1, &amp;mut gen_2);
    
    match Pin::new(&amp;mut gen_1).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match Pin::new(&amp;mut gen_2).resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
}
<span class="boring">enum Gen {
</span><span class="boring">   Enter,
</span><span class="boring">   Yielded{
</span><span class="boring">       s: String,
</span><span class="boring">       borrowed_s: *const String
</span><span class="boring">   },
</span><span class="boring">   Exit
</span><span class="boring">}
</span><span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = self.get_mut();
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译运行将会发生段错误：</p>
<pre><code class="language-rust noplayground">/playground/tools/entrypoint.sh: line 11:    12 Segmentation fault
Yielded: 11
Yielded: 11
Hello World
Complete: ()</code></pre>
<p>为了防止 <code>move</code> 掉生成器，我们需要为 <code>Gen</code> 实现 <code>!Unpin</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(negative_impls)]
#![feature(generators, generator_trait)]

use std::pin::Pin;
use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen_1 = Gen::new();
    let mut gen_2 = Gen::new();
    
    let mut boxed_pin_1 = Box::pin(gen_1);
    let mut boxed_pin_2 = Box::pin(gen_2);
    
    match boxed_pin_1.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    match boxed_pin_2.as_mut().resume(()) {
        GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
        GeneratorState::Complete(c) =&gt; println!(&quot;Complete: {:?}&quot;, c)
    }
    
    std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
}

enum Gen {
    Enter,
    Yielded{
        s: String,
        borrowed_s: *const String
    },
    Exit
}

impl !Unpin for Gen {}

<span class="boring">impl&lt;R&gt; Generator&lt;R&gt; for Gen {
</span><span class="boring">   type Yield = usize;
</span><span class="boring">   type Return = ();    
</span><span class="boring">   fn resume(self: Pin&lt;&amp;mut Self&gt;, _arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt; {
</span><span class="boring">       let mut_gen = unsafe { self.get_unchecked_mut() };
</span><span class="boring">       match mut_gen {
</span><span class="boring">           Gen::Enter =&gt; {
</span><span class="boring">               let s = &quot;Hello World&quot;.to_string();
</span><span class="boring">               let borrowed_s = &amp;s;
</span><span class="boring">               let len = borrowed_s.len();
</span><span class="boring">               
</span><span class="boring">               *mut_gen = Gen::Yielded {
</span><span class="boring">                   s,
</span><span class="boring">                   borrowed_s: std::ptr::null()
</span><span class="boring">               };
</span><span class="boring">               if let Gen::Yielded { s, borrowed_s } = mut_gen {
</span><span class="boring">                   *borrowed_s = s as *const _;
</span><span class="boring">               }               
</span><span class="boring">               GeneratorState::Yielded(len)
</span><span class="boring">           }
</span><span class="boring">           Gen::Yielded{ borrowed_s, .. } =&gt; {
</span><span class="boring">               let borrowed_s: &amp;String = unsafe { &amp;**borrowed_s };
</span><span class="boring">               println!(&quot;{}&quot;, borrowed_s);
</span><span class="boring">               *mut_gen = Gen::Exit;               
</span><span class="boring">               GeneratorState::Complete(())
</span><span class="boring">           }
</span><span class="boring">           Gen::Exit =&gt; panic!(&quot;Generator has been completed.&quot;)
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Gen {
</span><span class="boring">   fn new() -&gt; Self {
</span><span class="boring">       Self::Enter
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre></pre>
<p>编译修改后的代码将会直接报错：</p>
<pre><code class="language-rust noplayground">error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:41
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`

error[E0277]: `Gen` cannot be unpinned
   --&gt; src/main.rs:23:73
    |
23  |     std::mem::swap(boxed_pin_1.as_mut().get_mut(), boxed_pin_2.as_mut().get_mut());
    |                                                                         ^^^^^^^ the trait `Unpin` is not implemented for `Gen`
    |
    = note: consider using `Box::pin`
note: required by a bound in `Pin::&lt;&amp;'a mut T&gt;::get_mut`</code></pre>
<p>通过为生成器实现 <code>!Unpin</code>，我们有效的防止了可能会出现的内存安全问题。</p>
<p>但是，我们无法为使用闭包编写的生成器实现 <code>!Unpin</code>，那么怎么让我们的初版代码编译通过呢？答案是使用 <code>static</code> 关键字标记生成器，这就相当于为我们的生成器实现了 <code>!Unpin</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};


fn main(){
    let gen = static || {
        let s = &quot;Hello World&quot;.to_string();
        let borrowed_s = &amp;s;
        
        yield borrowed_s.len();
        
        println!(&quot;{}&quot;, borrowed_s);
    };
    
    let mut boxed_pin_gen = Box::pin(gen);
    
    loop {
        match boxed_pin_gen.as_mut().resume(()) {
            GeneratorState::Yielded(y) =&gt; println!(&quot;Yielded: {}&quot;, y),
            GeneratorState::Complete(c) =&gt; {
                println!(&quot;Complete: {:?}&quot;, c);
                break;
            }
        }
    }
}</code></pre></pre>
<p>编译运行，一切正常：</p>
<pre><code class="language-rust noplayground">Yielded: 11
Hello World
Complete: ()</code></pre>
<h3 id="小总结"><a class="header" href="#小总结">小总结</a></h3>
<p><code>async</code> 创建的 <code>Future</code> 在编译后会生成一个状态机，如果 <code>async</code> 代码中存在跨 <code>await</code> 借用，那么对应的底层生成器中也会存在跨 <code>yield</code> 点借用，最终生成的状态机中就会存在自引用结构，为了避免可能发生的内存安全问题，Rust 自动为 <code>Future</code> 实现了 <code>!Unpin</code>，并且只能使用 <code>Pin&lt;&amp;mut Self&gt;</code> 来调用 <code>Future</code> 的 <code>poll</code> 方法和 <code>Generator</code> 的 <code>resume</code> 方法，从而避免了使用者在 Safe Rust 中获取 <code>Future</code> 或 <code>Generator</code> 的可变引用，最终避免了使用者使用 <code>swap</code> 之类的函数 <code>move</code> 掉 <code>Future</code> 或 <code>Generator</code> 而造成的内存安全问题。 </p>
<h2 id="pin-总结"><a class="header" href="#pin-总结">Pin 总结</a></h2>
<p>官方的 <code>Async Book</code> 上给出了关于 <code>Pin</code> 的黄金八条：</p>
<ol>
<li>
<p>如果 <code>T: Unpin</code>（默认会实现），那么 <code>Pin&lt;'a, T&gt;</code> 完全等价于 <code>&amp;'a mut T</code>。换言之： <code>Unpin</code> 意味着这个类型被移走也没关系，就算已经被固定了，所以 <code>Pin</code> 对这样的类型毫无影响。</p>
</li>
<li>
<p>如果 <code>T: !Unpin</code>， 获取已经被固定的 <code>T</code> 类型示例的 <code>&amp;mut T</code>需要 <code>unsafe</code>。</p>
</li>
<li>
<p>标准库中的大部分类型实现 <code>Unpin</code>，在 Rust 中遇到的多数普通类型也是一样。但是， <code>async/await</code> 生成的 <code>Future</code> 是个例外。</p>
</li>
<li>
<p>你可以在 <code>nightly</code> 通过特性标记来给类型添加 <code>!Unpin</code> 约束，或者在 <code>stable</code> 给你的类型加 <code>std::marker::PhatomPinned</code> 字段。</p>
</li>
<li>
<p>你可以将数据固定到栈上或堆上。</p>
</li>
<li>
<p>固定 <code>!Unpin</code> 对象到栈上需要 <code>unsafe</code></p>
</li>
<li>
<p>固定 <code>!Unpin</code> 对象到堆上不需要<code> unsafe</code>，<code>Box::pin</code>可以快速完成这种固定。</p>
</li>
<li>
<p>对于 <code>T: !Unpin</code> 的被固定数据，你必须维护好数据内存不会无效的约定，或者叫固定时起直到释放。这是 <code>Pin</code> 约定中的重要部分。</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../async-await/状态机.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../IO模型.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../async-await/状态机.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../IO模型.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
